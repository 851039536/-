

# 代码开发规范

## 前端页面结构

```html
<body>
    <header>这是一个页面</header>
    <aside>
        广告位或者导航
    </aside>
    <main>
        页面内容
    </main>
    <footer>这个页面是xxx写的</footer>
</body>

```



## 使用注释

###  CSS 注释

```css
/* css 注释 */
```

### JavaScript 注释

```js
// 单行注释

/**
 * 多行注释，注意第一行最好用两个 *
 * ...
 */

/*
 当然，除了两端的 * 必须加以外，其他的 * 不加也行
 ...
*/
```



###  单行注释

一般情况下，单行注释会出现在代码的正上方，起到提示的作用：

```css
/* 用注释备注 CSS 类名的功能 */

/* 顶部组件 */
.hd {
  position: fixed;
  width: 100vw;
}

/* 版心 */
.container {
  margin: 16px auto;
  width: 1200px;
}

// 用单行注释备注简单的信息
const userName = ""; // 用户名
const userAvatar = ""; // 用户头像

// xxx函数
const myFunction = () => {};
复制代码
```

###  多行注释

多行注释一般用于需要备注的信息过多的情况，常常出没于 `JavaScript` 函数的附近。首先提出一个问题：为什么要用到多行注释，用单行注释不香吗？下面就来看看下面的代码：

```js
// xxx函数
const myFunction = ({ id, name, avatar, list, type }) => {
  // 此处省略 30 行代码
};
```

小伙伴们可能看到了，一个传入五个参数，内部数行代码的函数竟然只有短短的一行注释，也许你开发的时候能记住这个函数的用途以及参数的类型以及是否必传等，但是如果你隔了一段时间再回头看之前的代码，那么简短的注释就可能变成你的困扰。 ~~更不用说没有注释，不写注释一时爽，回看代码火葬场。~~ 写注释的目的在于提高代码的可读性。相比之下，下面的注释就清晰的多：

```js
/**
 * 调整滚动距离
 * 用于显示给定 id 元素
 * @param    id        string  必传    元素 id
 * @param    distance  number  非必传  距离视口最顶部距离(避免被顶部固定定位元素遮挡)
 * @returns  null
 */
export const scrollToShowElement = (id = "", distance = 0) => {
  return () => {
    if (!id) {
      return;
    };

    const element = document.getElementById(id);
    if (!element) {
      return;
    };

    const top = element?.offsetTop || 0;
    window.scroll(0, top - distance);
  };
};
```

对于复杂的函数，函数声明上面要加上统一格式的多行注释，同时内部的复杂逻辑和重要变量也需要加上单行注释，两者相互配合，相辅相成。函数声明的多行注释格式一般为：

```js
/**
 * 函数名称
 * 函数简介
 * @param    参数1    参数1数据类型  是否必传  参数1描述
 * @param    参数2    参数2数据类型  是否必传  参数2描述
 * @param    ...
 * @returns  返回值
 */
```

多行注释的优点是清晰明了，缺点是较为繁琐(可以借助编辑器生成 JavaScript 函数注释模板)。建议逻辑简单的函数使用单行注释，逻辑复杂的函数和公共/工具函数使用多行注释。



### 进阶使用

无论是 `css` 还是 `JavaScript` 中，当代码越来越多的时候，也使得寻找要改动的代码时变得越来越麻烦。所以我们有必要对代码按模块进行整理，并在每个模块的顶部用注释，结束时使用空行进行分割。



```css
 /* ------------------------ 模块1 ------------------------ */
 /* 类名1 */
 .class-a {}

 /* 类名2 */
 .class-b {}

 /* 类名3 */
 .class-c {}

 /* ------------------------ 模块2 ------------------------ */
 /* 类名4 */
 .class-d {}

 /* 类名5 */
 .class-e {}

 /* ... */

// 以下代码仅为示例

/* ======================== 模块1 ======================== */
// 变量1
const value1 = "";
// 变量2
const value2 = "";
// 变量3
const value3 = "";
// 函数1
const myFunction1 = () => {};

/* ======================== 模块2 ======================== */
// 变量4
const value4 = "";
// 变量5
const value5 = "";
// 变量6
const value6 = "";
// 函数2
const myFunction2 = () => {};

// ...
```

能直观的看出，加长版的注释分割效果更好，区分度更高。高质量的代码往往需要最朴实无华的注释进行分割。其中 `JavaScript` 的注释“分割线”建议使用多行注释。

------

“华丽的”分割线：

```js
 /* ------------------------ 华丽的分割线 ------------------------ */
 
/* ======================== 华丽的分割线 ======================== */
```



## VUE命名规范

### 组件命名

**命名组件时使用驼峰**

- NewComponent.vue ✅
- newcomponent.vue 🛑
- Newcomponent.vue 🛑

**如果有子组件，可以这样命名**

- FooterSection.vue
- FooterSectionHeading.vue
- FooterSectionIcons.vue
- FooterSectionButton.vue

**如果没有子组件，可以尝试加前缀 `the` 来命名**

- TheNavbar.vue

### 文件命名

- 文件名统一采用小写

- 模板中使用组件**必须**使用**短横线式**

### 命名原则

祖先模块不能出现下划线，除了是全站公用模块，如 `mod_` 系列的命名：

**推荐：**

```css
<div class="modulename">
	<div class="modulename_info">
		<div class="modulename_son"></div>
		<div class="modulename_son"></div>
		...
	</div>
</div>
	
<!-- 这个是全站公用模块，祖先模块允许直接出现下划线 -->
<div class="mod_info">
	<div class="mod_info_son"></div>
	<div class="mod_info_son"></div>
	...		
</div>
```



### 模块命名

全站公共模块：以 `mod_` 开头

```
<div class="mod_yours"></div>
```

业务公共模块：以 `业务名_mod_` 开头

```
<div class="paipai_mod_yours"></div>
```

### 常用命名推荐

**注意**：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名

| ClassName              | 含义                                     |
| :--------------------- | :--------------------------------------- |
| about                  | 关于                                     |
| account                | 账户                                     |
| arrow                  | 箭头图标                                 |
| article                | 文章                                     |
| aside                  | 边栏                                     |
| audio                  | 音频                                     |
| avatar                 | 头像                                     |
| bg,background          | 背景                                     |
| bar                    | 栏（工具类）                             |
| branding               | 品牌化                                   |
| crumb,breadcrumbs      | 面包屑                                   |
| btn,button             | 按钮                                     |
| caption                | 标题，说明                               |
| category               | 分类                                     |
| chart                  | 图表                                     |
| clearfix               | 清除浮动                                 |
| close                  | 关闭                                     |
| col,column             | 列                                       |
| comment                | 评论                                     |
| community              | 社区                                     |
| container              | 容器                                     |
| content                | 内容                                     |
| copyright              | 版权                                     |
| current                | 当前态，选中态                           |
| default                | 默认                                     |
| description            | 描述                                     |
| details                | 细节                                     |
| disabled               | 不可用                                   |
| entry                  | 文章，博文                               |
| error                  | 错误                                     |
| even                   | 偶数，常用于多行列表或表格中             |
| fail                   | 失败（提示）                             |
| feature                | 专题                                     |
| fewer                  | 收起                                     |
| field                  | 用于表单的输入区域                       |
| figure                 | 图                                       |
| filter                 | 筛选                                     |
| first                  | 第一个，常用于列表中                     |
| footer                 | 页脚                                     |
| forum                  | 论坛                                     |
| gallery                | 画廊                                     |
| group                  | 模块，清除浮动                           |
| header                 | 页头                                     |
| help                   | 帮助                                     |
| hide                   | 隐藏                                     |
| hightlight             | 高亮                                     |
| home                   | 主页                                     |
| icon                   | 图标                                     |
| info,information       | 信息                                     |
| last                   | 最后一个，常用于列表中                   |
| links                  | 链接                                     |
| login                  | 登录                                     |
| logout                 | 退出                                     |
| logo                   | 标志                                     |
| main                   | 主体                                     |
| menu                   | 菜单                                     |
| meta                   | 作者、更新时间等信息栏，一般位于标题之下 |
| module                 | 模块                                     |
| more                   | 更多（展开）                             |
| msg,message            | 消息                                     |
| nav,navigation         | 导航                                     |
| next                   | 下一页                                   |
| nub                    | 小块                                     |
| odd                    | 奇数，常用于多行列表或表格中             |
| off                    | 鼠标离开                                 |
| on                     | 鼠标移过                                 |
| output                 | 输出                                     |
| pagination             | 分页                                     |
| pop,popup              | 弹窗                                     |
| preview                | 预览                                     |
| previous               | 上一页                                   |
| primary                | 主要                                     |
| progress               | 进度条                                   |
| promotion              | 促销                                     |
| rcommd,recommendations | 推荐                                     |
| reg,register           | 注册                                     |
| save                   | 保存                                     |
| search                 | 搜索                                     |
| secondary              | 次要                                     |
| section                | 区块                                     |
| selected               | 已选                                     |
| share                  | 分享                                     |
| show                   | 显示                                     |
| sidebar                | 边栏，侧栏                               |
| slide                  | 幻灯片，图片切换                         |
| sort                   | 排序                                     |
| sub                    | 次级的，子级的                           |
| submit                 | 提交                                     |
| subscribe              | 订阅                                     |
| subtitle               | 副标题                                   |
| success                | 成功（提示）                             |
| summary                | 摘要                                     |
| tab                    | 标签页                                   |
| table                  | 表格                                     |
| txt,text               | 文本                                     |
| thumbnail              | 缩略图                                   |
| time                   | 时间                                     |
| tips                   | 提示                                     |
| title                  | 标题                                     |
| video                  | 视频                                     |
| wrap                   | 容器，包，一般用于最外层                 |
| wrapper                | 容器，包，一般用于最外层                 |



## CSS规范

### 代码大小写

样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。

### 选择器

- 尽量少用通用选择器 `*`
- 不使用 ID 选择器
- 不使用无具体语义定义的标签选择器

```css
/* 推荐 */
.jdc {}
.jdc li {}
.jdc li p{}
```

### 属性值引号

css属性值需要用到引号时，统一使用单引号

```css
/* 推荐 */
.jdc { 
	font-family: 'Hiragino Sans GB';
}

```

### 属性书写顺序

建议遵循以下顺序：

1. 布局定位属性：display / position / float / clear / visibility / overflow
2. 自身属性：width / height / margin / padding / border / background
3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word
4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …

```css
.jdc {
    display: block;
    position: relative;
    float: left;
    width: 100px;
    height: 100px;
    margin: 0 10px;
    padding: 20px 0;
    font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
    color: #333;
    background: rgba(0,0,0,.5);
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
```

### CSS3浏览器私有前缀写法

CSS3 浏览器私有前缀在前，标准前缀在后

```css
.jdc {
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
```

### 模块注释

```css
/* Module A
---------------------------------------------------------------- */
.mod_a {}

/* Module B
---------------------------------------------------------------- */
.mod_b {}
```

### 文件信息注释

在样式文件编码声明 `@charset` 语句下面注明页面名称、作者、创建日期等信息

```
@charset "UTF-8";
/**
 * @desc File Info
 * @author Author Name
 * @date 2015-10-10
 */
```

### 常用命名

 `css类名`

| **CSS类名**           | **说明**               |
| --------------------- | ---------------------- |
| **布局**              |                        |
| layout                | 布局容器               |
| wrapper/wrap          | 控制布局宽度的外围容器 |
| header/head/hd        | 头部/顶部              |
| main/bd               | 主体部分               |
| footer/foot/ft        | 底部                   |
| sidebar               | 侧边栏                 |
| **容器**              |                        |
| banner                | 广告栏                 |
| content               | 内容部分               |
| copyright             | 版权                   |
| list                  | 列表                   |
| menu/submenu          | 菜单/二级菜单          |
| nav/subnav            | 导航栏/二级导航        |
| **组件/细节**         |                        |
| arrow                 | 箭头                   |
| btn                   | 按钮                   |
| download              | 下载                   |
| logo                  | 徽标                   |
| message/msg           | 信息                   |
| news                  | 新闻                   |
| product               | 产品                   |
| search                | 搜索                   |
| status                | 状态                   |
| summary               | 摘要                   |
| tab                   | 标签页                 |
| tag                   | 标签                   |
| text/txt              | 文本                   |
| tip                   | 提示                   |
| title/subtitle        | 标题/二级标题          |
| **尺寸**              |                        |
| large                 | 大                     |
| middle                | 中等                   |
| small                 | 小                     |
| mini                  | 迷你                   |
| **位置**              |                        |
| top/right/bottom/left | 上/右/下/左            |
| **关系**              |                        |
| first                 | 第一个                 |
| last                  | 最后一个               |
| prev                  | 上一个                 |
| current               | 当前项                 |
| next                  | 下一个                 |
| forward               | 向前                   |
| back                  | 向后                   |
| **状态**              |                        |
| primary               | 主要                   |
| info                  | 提示信息               |
| success               | 成功                   |
| warning               | 一般警告               |
| danger/error          | 严重警告/错误警告      |
| link                  | 文字链接               |
| plain/ghost           | 按钮是否镂空           |
| light                 | 亮模式                 |
| dark                  | 暗模式                 |
| disabled              | 禁用                   |
| active                | 激活                   |
| checked               | 选中                   |
| loading               | 加载中                 |






## SASS规范

### 团队约定

SCSS 文件内

- 全部遵循 CSS 注释规范
- 不使用 `/*! */` 注释方式
- 注释内不放 SASS 变量

标准的注释规范如下：

```css
@charset "UTF-8";

/**
 * @desc File Info
 * @author liqinuo
 * @date 2015-10-10
 */

/* Module A
----------------------------------------------------------------*/
.mod_a {}

/* module A logo */
.mod_a_logo {}

/* module A nav */
.mod_a_nav {}


/* Module B
----------------------------------------------------------------*/
.mod_b {}

/* module B logo */
.mod_b_logo {}

/* module B nav */
.mod_b_nav {}
```

### 变量

可复用属性尽量抽离为页面变量，易于统一维护

```css
// CSS
.jdc {
    color: red;
    border-color: red;
}

// SCSS
$color: red;
.jdc {
    color: $color;
    border-color: $color;
}
```

### 混合(mixin)

根据功能定义模块，然后在需要使用的地方通过 `@include` 调用，避免编码时重复输入代码段

```css
// CSS
.jdc_1 {
    -webkit-border-radius: 5px;
    border-radius: 5px;
}
.jdc_2 {
    -webkit-border-radius: 10px;
    border-radius: 10px;
}

// SCSS
@mixin radius($radius:5px) {
    -webkit-border-radius: $radius;
    border-radius: $radius;
}
.jdc_1 {
    @include radius; //参数使用默认值
}
.jdc_2 {
    @include radius(10px);
}


// CSS
.jdc_1 {
    background: url(/img/icon.png) no-repeat -10px 0;
}
.jdc_2 {
    background: url(/img/icon.png) no-repeat -20px 0;
}

// SCSS
@mixin icon($x:0, $y:0) {
    background: url(/img/icon.png) no-repeat $x, $y;
}
.jdc_1 {
    @include icon(-10px, 0);
}
.jdc_2 {
    @include icon(-20px, 0);
}
```

### 占位选择器 %

如果不调用则不会有任何多余的 css 文件，占位选择器以 `%` 标识定义，通过 `@extend` 调用

```css
//scss
%borderbox {
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
.jdc {
    @extend %borderbox;
}
```

### extend 继承

```css
// CSS
.jdc_1 {
    font-size: 12px;
    color: red;
}
.jdc_2 {
    font-size: 12px;
    color: red;
    font-weight: bold;
}

// SCSS
.jdc_1 {
    font-size: 12px;
    color: red;
}
.jdc_2 {
    @extend .jdc_1;
    font-weight: bold;
}

// 或者
%font_red {
    font-size: 12px;
    color: red;
}
.jdc_1 {
    @extend %font_red;
}
.jdc_2 {
    @extend %font_red;
    font-weight: bold;
}
```

### for 循环

```css
// CSS
.jdc_1 {background-position: 0 -20px;}
.jdc_2 {background-position: 0 -40px;}
.jdc_3 {background-position: 0 -60px;}

// SCSS
@for $i from 1 through 3 {
    .jdc_#{$i} {
        background-position: 0 (-20px) * $i;
    }
}
```

注意：`#{}` 是连接符，变量连接使用时需要依赖

### each 循环

```css
// CSS
.jdc_list {
    background-image: url(/img/jdc_list.png);
}
.jdc_detail {
    background-image: url(/img/jdc_detail.png);
}

// SCSS
@each $name in list, detail {
    .jdc_#{$name} {
        background-image: url(/img/jdc_#{$name}.png);
    }
}


// CSS
.jdc_list {
    background-image: url(/img/jdc_list.png);
    background-color: red;
}
.jdc_detail {
    background-image: url(/img/jdc_detail.png);
    background-color: blue;
}

// SCSS
@each $name, $color in (list, red), (detail, blue) {
    .jdc_#{$name} {
        background-image: url(/img/jdc_#{$name}.png);
        background-color: $color;
    }
}
```

### function 函数

```css
@function pxToRem($px) {
    @return $px / 10px * 1rem;
}
.jdc {
    font-size: pxToRem(12px);
}
```

### 运算规范

运算符之间空出一个空格

```css
.jdc {
    width: 100px - 50px;
    height: 30px / 5;
}
```

注意运算单位，单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意

```css
// 正确的运算格式
.jdc {
    width: 100px - 50px;
    width: 100px + 50px;
    width: 100px * 2;
    width: 100px / 2;
}
```

### 重置样式



### 移动端

```
* { -webkit-tap-highlight-color: transparent; outline: 0; margin: 0; padding: 0; vertical-align: baseline; }
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin: 0; padding: 0; vertical-align: baseline; }
img { border: 0 none; vertical-align: top; }
i, em { font-style: normal; }
ol, ul { list-style: none; }
input, select, button, h1, h2, h3, h4, h5, h6 { font-size: 100%; font-family: inherit; }
table { border-collapse: collapse; border-spacing: 0; }
a { text-decoration: none; color: #666; }
body { margin: 0 auto; min-width: 320px; max-width: 640px; height: 100%; font-size: 14px; font-family: -apple-system,Helvetica,sans-serif; line-height: 1.5; color: #666; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; }
input[type="text"], textarea { -webkit-appearance: none; -moz-appearance: none; appearance: none; }
```

### PC端

```
html, body, div, h1, h2, h3, h4, h5, h6, p, dl, dt, dd, ol, ul, li, fieldset, form, label, input, legend, table, caption, tbody, tfoot, thead, tr, th, td, textarea, article, aside, audio, canvas, figure, footer, header, mark, menu, nav, section, time, video { margin: 0; padding: 0; }
h1, h2, h3, h4, h5, h6 { font-size: 100%; font-weight: normal }
article, aside, dialog, figure, footer, header, hgroup, nav, section, blockquote { display: block; }
ul, ol { list-style: none; }
img { border: 0 none; vertical-align: top; }
blockquote, q { quotes: none; }
blockquote:before, blockquote:after, q:before, q:after { content: none; }
table { border-collapse: collapse; border-spacing: 0; }
strong, em, i { font-style: normal; font-weight: normal; }
ins { text-decoration: underline; }
del { text-decoration: line-through; }
mark { background: none; }
input::-ms-clear { display: none !important; }
body { font: 12px/1.5 \5FAE\8F6F\96C5\9ED1, \5B8B\4F53, "Hiragino Sans GB", STHeiti, "WenQuanYi Micro Hei", "Droid Sans Fallback", SimSun, sans-serif; background: #fff; }
a { text-decoration: none; color: #333; }
a:hover { text-decoration: underline; }
```

### 移动端适配

目前移动端的适配方案一般就是两种，一个是 `rem` 方案，一个就是 `vw` 的方案。



#### 安装

- 要实现使用 `vw` 来实现移动端的适配，我们首先需要安装 [postcss (opens new window)](https://postcss.org/)这个工具。
- 因为我们使用 `webpack` 来作为打包工具，所以还需要安装官方提供的 [postcss-loader (opens new window)](https://github.com/webpack-contrib/postcss-loader)，但是由于我们的项目是用最新的 `vue-cli4.x` 来构建了，初始化项目内部默认就安装了它，所以这一步可以省略。

```bash
$ npm install postcss -D
```

- 安装 [postcss-px-to-viewport (opens new window)](https://github.com/evrone/postcss-px-to-viewport)这个插件，它可以将我们设置`px`值自动转化为相应的`vw`、`vh`之类的值。

```bash
$ npm install postcss-px-to-viewport --D
```



#### 配置

- 新建一个postcss.config.js 来配置转换规则。关于各参数的含义：[postcss-px-to-viewport (opens new window)](https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md)。

```javascript
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      unitToConvert: 'px',
      viewportWidth: 750,
      unitPrecision: 3,
      propList: ['*'],
      viewportUnit: 'vw',
      fontViewportUnit: 'vw',
      selectorBlackList: ['.ignore'],
      minPixelValue: 1,
      mediaQuery: false,
      replace: true,
      exclude: [],
      landscape: false,
      landscapeUnit: 'vw',
      landscapeWidth: 568,
    },
  },
};
```



- 然后因为是移动端的网页，所以我们应该在 `public/index.html` 中添加 `meta` 元信息标签禁止用户缩放页面。

```html
<meta
  name="viewport"
  content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"
/>
```



# CSS

## 选择器

CSS选择器的解析是从上到下，从右向左解析，为了避免对所有元素进行解析

- 可继承的样式：font-size, font-family, color，ul，li，dl，dt，dd；
- 不可继承的样式：border, padding, margin, width, height

**优先级**

| 选择器         | 权重值 |
| :------------- | :----- |
| !important标识 | 10000  |
| 行内样式       | 1000   |
| id选择器       | 100    |
| 类选择器       | 10     |
| 标签选择器     | 1      |
| 通配符 *       | 0      |

> !important>行内样式>ID选择器>类、伪类、属性>元素、伪元素>继承>通配符

### 标签选择器

```css
p{color:red;}
```

### ID选择器

```css
#warning{color:red;}
```

### 属性选择器

```html
<ul>
    <li foo>1</li>
    <li foo="abc">2</li>
    <li foo="abc efj">3</li>
    <li foo="abcefj">4</li>
    <li foo="efjabc">5</li>
    <li foo="ab">6</li>
</ul>
```

```css
//选择 attribute=value 的所有元素。
[foo=abc]{
    background-color:red;
}

//选择 attribute 属性包含单词 value 的所有元素。
[foo~=abc]{
    background-color:red;
}

//选择其 attribute 属性值以 value 开头的所有元素。类似正则的 ^,以什么开始
[foo^=abc]{
    background-color:red;
}

//选择其 attribute 属性值以 value 结束的所有元素。类似正则的 $,以什么结束
[foo$=abc]{
    background-color:red;
}

//选择其 attribute 属性中包含 value 子串的每个元素。
[foo*=abc]{
    background-color:red;
}

//选择 attribute 属性值以 value 开头的所有元素。
[foo|=abc]{
    background-color:red;
}

```

### 后代选择器

```CSS
ul li{
    border: 1px solid red;
}
```

### 子选择器

```css
 ul>li>p{
   border: 1px solid red;
}
```

### 相邻兄弟选择器

```css
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

//选择紧接在 element元素之后的 element 元素。
h1+p{
    color:red;
}

```

### 一般兄弟选择器 

```css
//选择前面有 element1 元素的每个 elem 元素。
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

 h1~p{
   border: 1px solid red;
}
```

### 伪类选择器

```css
//:root 文档根元素伪类
:root{
    background-color:red;
}

//:nth-child(n) 孩子选择器
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

div :nth-child(1){
    color:red;
}

//:nth-of-type(n) 同类型的第n个元素
div p:nth-of-type(2){
    color: red;
}

//选择属于父元素element的第一个子元素。 等同 :nth-child(1)
element:first-child

//选择属于父元素element的最后一个子元素。
element:last-child

//同类型的第一个子元素
element:first-of-type

//同类型的最后一个子元素
element:last-of-type

<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>
<div>
    <h1>h2</h1>  
</div>

 div :only-child{
    color: red;
 }

//没有访问过的状态
a:link

//链接正在被点击
a:active

//选择鼠标指针位于其上的链接。
a:hover

//选择所有已被访问的链接。
a:visited

//:focus 选择器用于选取获得焦点的元素。
:focus

//选择每个启用的 input 元素 / 选择每个禁用的 input 元素
:enabled / :disabled

//选择每个被选中的 input 元素。自定义开关可以用这个实现
:checked

//选择非 selector 元素的每个元素。（反向选择）
:not(selector)
```



### 伪元素选择器

```css
element::first-line

//p 元素的第一行发生改变
p:first-line{
	background-color:yellow;
}


element::first-letter
//直接第一个字符变黄，如果JavaScript做的话，需要获取字符串，再获取第一个字符，再改变其颜色
h1:first-letter{
	color:yellow;
}

//在每个 element 元素的内容之前插入内容。我们更多的可能是当作一个div来用
element::before

//在每个element元素的内容之后插入内容。我们可能更多的是用来清除浮动或验证表单提示等其它
element::after

//选择被用户选取的元素部分。
::selection
```



##  background

```css
    /* 背景图片 */
background: no-repeat center/100% url("../img/index.png");
	/* 背景颜色 */
  background-color: #ffffff;
  /*背景透明*/
  background-color: hsla(0,0%,100%,.7);
```

### **使用多个背景图片**

```css
body {
  background-image: url(https://image.flaticon.com/icons/svg/748/748122.svg), url(https://images.unsplash.com/photo-1478719059408-592965723cbc?ixlib=rb-1.2.1&auto=format&fit=crop&w=2212&q=80);
  background-position: center, top;
  background-repeat: repeat, no-repeat;
  background-size: contain, cover;
}
```



### **添加叠加渐变**

```css
body {
  background-image: 
    linear-gradient(4deg, rgba(38,8,31,0.75) 30%, rgba(213,49,127,0.3) 45%, rgba(232,120,12,0.3) 100%),
    url("https://images.unsplash.com/photo-1503803548695-c2a7b4a5b875?ixlib=rb-1.2.1&auto=format&fit=crop&w=2250&q=80");
  background-size: cover;
  background-repeat: no-repeat;
  background-attachment: fixed;
  background-position: center
}
```

### **网格背景图像**

```html
<body>
<div class="container">
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
</div>
</body>
```

```css
body {
 margin: 0;
  padding: 0;
}

.container {
  position: absolute;
  width: 100%;
  height: 100%;
  background: black;
  display: grid;
  grid-template-columns: 25fr 30fr 40fr 15fr;
  grid-template-rows: 20fr 45fr 5fr 30fr;
  grid-gap: 20px;
  .item_img {
    background-image: url('https://images.unsplash.com/photo-1499856871958-5b9627545d1a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2207&q=80');
  background-repeat: no-repeat;
  background-position: center;
  background-attachment: fixed;
  background-size: cover;
}
}

```

### vue全局背景颜色

```js
mounted() {
  document.querySelector('body').setAttribute('style', 'background-color:#f7f7f7')
},
beforeDestroy() {
  document.querySelector('body').removeAttribute('style')
}
```



## 字体 font

```css
/* 字体颜色 */
  color: #888888;
/* 字体粗细 */
  font-weight: 400;
/* 字体大小 */
  font-size: 14px;
/* 文字居中 */
  text-align: center;
/* 字体行内居中 */
  line-height: 45px;
 /*字体加深*/
 text-shadow: 0 0 1px rgba(0,0,0,.3);
 /*起始段落空2格*/
 text-indent: 2em;
```

### 字体发光

```css
 color: white;
  text-shadow:
  0px 0px 5px white,
  0px 0px 5px white,
  0px 0px 5px white,
  0px 0px 20px rgba(171, 126, 177, 0.7),
  0px 0px 20px rgba(171, 126, 177, 0.7),
  0px 0px 20px rgba(171, 126, 177, 0.7),
  0px 0px 20px rgba(171, 126, 177, 0.7);
```

##  margin | padding

```css
/* 外边距 */
  margin: 60px 0 0 -40px;
/* 居中显示 */
  margin: 0 auto;
/* 向下10px */
  margin-bottom: 10px;
/* 外边距 */
  padding: 15px 0 10px 12px;
```

## 透明

```css
 opacity: 0.9;
```

## 边框 border

```css
/* 边框宽度1px 样式 颜色 */
  border: 1px solid #868686;
/* 边框边角弧度 */
  border-radius: 5px;
/* 边框下划线 */
  border-bottom: 1px solid #edeef0;
/* 样式 1px */
  border-style: ridge;
  border-width: 1px;
```

### border-radius 的斜线语法

```css
.border-radius {
  border-radius: 50px 25px / 25px 50px;
}
```



### 实线边框

```css
    -webkit-box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);
    box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);
```



## 2D动画

### 动画效果

```css
 /* 动画效果 */
  transition: all 5s;
```

### 动画触发

```css
:hover {
  /* 放大2倍 */
  /* transform: scale(2, 2); */
  /* 旋转 */
  transform: rotate(720deg);
  /* 上移 */
  transform: translateY(-3px);
}

box-shadow: 0px 0px 2px 2px rgba(0, 0, 0, 0.3);
```



## 3D动画

### 3D转换 translate3d

```css
transform: translate3d(0,100px,100px);
```

### 透视 perspective

```css
/* 透视写在被观察元素的父盒子上面 */
perspective: 500px;
```

### 旋转 rotate3d

```css
  transform: rotateX(45deg);
  transform: rotateY();
  transform: rotateZ();
  /* 自定义 */
  transform: rotate3d(x,y,z,deg);
```

### 3d呈现 transform-style

```css
  /* 让子元素保持3d立体空间环境 */
transform-style: preserve-3d;
```

## img

### 设置图像的最大宽度

```css
img {
    max-width: 100%;
}
```

### 悬停放大图片特效

```css
.img-wrapper img {
  -webkit-transition: 0.3s linear;
  transition: 0.3s linear;
}

.img-wrapper img:hover {
  transform: scale(1.1);
}

```

### 颜色过滤

```css
/* ============== 
* 灰度过滤 
* ==============*/
.grayscale-img {
  -webkit-filter: grayscale(100%);
  filter: grayscale(100%);
}

.grayscale-img:hover {
  -webkit-filter: grayscale(0);
  filter: grayscale(0);
}

/* ============== 
* 深褐色过滤
* ==============*/
.sepia-img {
  -webkit-filter: sepia(100%);
  filter: sepia(100%);
}

.sepia-img:hover {
  -webkit-filter: sepia(0);
  filter: sepia(0);
}
```



## 定位

### 元素固定

```css
@media (min-height: 500px) {
    .site-header {
        position: sticky;
        top: 0;
        /*other styles*/
    }
}
```

### 居中定位

示例1

```c#
   position: absolute;
    width: 50%;
    height: 80%;
    overflow: auto;
    margin: auto;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
```

示例2

```css
.tag_search {
    
  @apply relative;
  height: 50px;

  div {
    @apply absolute top-1/2 left-1/2;
    width: 40%;
    transform: translate(-50%, -50%);
  }
}
```



## css 技巧

### 图片模糊

```css
        filter: blur(1px);
        -webkit-filter: blur(1px); /* chrome, opera */
        -ms-filter: blur(1px);
        -moz-filter: blur(1px);
```



### 元素隐藏

```css
visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；
opacity: 0;``CSS3属性，设置0可以使一个元素完全透明；
position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外；
display: none; 元素会变得不可见，并且不会再占用文档的空间；
transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；
<div hidden="hidden"> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态；
height: 0; 将元素高度设为 0 ，并消除边框；
filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中；

```

### 三角形

```css
/** 正三角 */
.triangle {
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 0 25px 40px 25px;
  border-color: transparent transparent rgb(245, 129, 127) transparent;
}
```

### 倒三角

```css
/** 倒三角 */
.triangle {
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 40px 25px 0 25px;
  border-color:  rgb(245, 129, 127) transparent transparent transparent;
}
```

### 虚线效果

```css
.dotted-line{
    border: 1px dashed transparent;
    background: linear-gradient(white,white) padding-box, repeating-linear-gradient(-45deg,#ccc 0, #ccc .25em,white 0,white .75em);
}
```

### 文本超出省略号

单行文本

```css
.single-ellipsis{
  width: 500px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

多行文本

```css
.multiline-ellipsis {
  display: -webkit-box;
  word-break: break-all;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4; //需要显示的行数
  overflow: hidden;
  text-overflow: ellipsis;
}
```

### 排版竖文

```vue
<div class="bruce flex-ct-x">
	<div class="vertical-text">
		<h3>情</h3>
		<p>我见犹怜，<br>爱不释手。<br>雅俗共赏，<br>君子好逑。</p>
	</div>
</div>

```

```css
.vertical-text {
	writing-mode: vertical-rl;
	h3 {
		padding-left: 20px;
		font-weight: bold;
		font-size: 18px;
		color: #f66;
	}
	p {
		line-height: 30px;
		color: #66f;
	}
}
```

### 灰度模式

```css
filter: grayscale(100%);
```

### 描绘波浪线

```vue
<div class="bruce flex-ct-x">
	<p class="waveline-text">波浪线文字</p>
</div>
```

```css
@mixin waveline($h, $color: #f66) {
	position: relative;
	&::after {
		position: absolute;
		left: 0;
		top: 100%;
		width: 100%;
		height: $h;
		background: linear-gradient(135deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%), linear-gradient(45deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%);
		background-size: $h * 2 $h * 2;
		content: "";
	}
}
.waveline-text {
	height: 20px;
	line-height: 20px;
	letter-spacing: 10px;
	@include waveline(10px);
}
```

### 格子背景

```css
  background-image: linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%),
            linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%);
            background-position: 0 0, 20px 20px;
            background-size: 40px 40px;
```

### 下划线跟随导航栏

```vue
<div class="bruce flex-ct-x">
	<ul class="underline-navbar">
		<li>Alibaba阿里巴巴</li>
		<li>Tencent腾讯</li>
		<li>Baidu百度</li>
		<li>Jingdong京东</li>
		<li>Ant蚂蚁金服</li>
		<li>Netease网易</li>
	</ul>
</div>
```

```css
.underline-navbar {
	display: flex;
	li {
		position: relative;
		padding: 10px;
		cursor: pointer;
		font-size: 20px;
		color: #09f;
		transition: all 300ms;
		&::before {
			position: absolute;
			left: 100%;
			top: 0;
			border-bottom: 2px solid transparent;
			width: 0;
			height: 100%;
			content: "";
			transition: all 300ms;
		}
		&:active {
			background-color: #09f;
			color: #fff;
		}
		&:hover {
			&::before {
				left: 0;
				top: 0;
				z-index: -1;
				border-bottom-color: #09f;
				width: 100%;
				transition-delay: 100ms;
			}
			& + li::before {
				left: 0;
			}
		}
	}
}
```

### 动态边框

```vue
<div class="bruce flex-ct-x">
	<div class="dynamic-border">iCSS</div>
</div>
```

```css
.dynamic-border {
	width: 200px;
	height: 80px;
	background: linear-gradient(0, #f66 2px, #f66 2px) no-repeat left top/0 2px,
		linear-gradient(-90deg, #f66 2px, #f66 2px) no-repeat right top/2px 0,
		linear-gradient(-180deg, #f66 2px, #f66 2px) no-repeat right bottom/0 2px,
		linear-gradient(-270deg, #f66 2px, #f66 2px) no-repeat left bottom/2px 0;
	cursor: pointer;
	line-height: 80px;
	text-align: center;
	font-weight: bold;
	font-size: 50px;
	color: #f66;
	transition: all 300ms;
	&:hover {
		background-size: 100% 2px, 2px 100%, 100% 2px, 2px 100%;
	}
}
```

### 自动打字

```html
<div class="bruce flex-ct-x">
	<div class="auto-typing">Do You Want To Know More About CSS Development Skill</div>
</div>
```

```css
@mixin typing($count: 0, $duration: 0, $delay: 0) {
	overflow: hidden;
	border-right: 1px solid transparent;
	width: #{$count + 1}ch;
	font-family: Consolas, Monaco, Monospace;
	white-space: nowrap;
	animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards, caret 500ms steps(1) #{$delay}s $duration * 2 forwards;
}
.auto-typing {
	font-weight: bold;
	font-size: 30px;
	color: #09f;
	@include typing(52, 5);
}
@keyframes typing {
	from {
		width: 0;
	}
}
@keyframes caret {
	50% {
		border-right-color: currentColor;
	}
}
```

### 渐变色文字

```css
<h2 class="gradient-text">Gradient text</h2>
<style>
.gradient-text {
  background-image: linear-gradient(90deg, red, blue);
  background-clip: text;
  color: transparent;
}
</style>
```

### 顺滑滚动

```css
html {
  scroll-behavior: smooth;
}
```

### text-shadow多阴影

```css
<h2 class="so-many-shadows">This is fun</h2>

<style>
.so-many-shadows {
  text-shadow: 
    3px 3px 0 yellow, 
    6px 6px 0 blue, 
    9px 9px red,
    12px 12px 0 black;
 }
</style>

```

### text-shadow多边框叠加

```css
.content {
  box-shadow:
    0 0 0 10px #EE6352,
    0 0 0 20px #D45379,
    0 0 0 30px #A4558F,
    0 0 0 40px #6D588E,
    0 0 0 50px #405378;
}
```



### 响应式多列布局

```css
.content {
  columns: 200px;
}

```



### 动画链接下划线

```css
 h5 > a {
                position: relative;
                text-decoration: none;
            }
            h5 > a:hover {
                cursor: pointer;
            }
            h5 > a::before {
                content: "";
                position: absolute;
                width: 100%;
                height: 2px;
                bottom: 0;
                left: 0;
                background-color: #7f828f;
                visibility: hidden;
                transform: scaleX(0);
                transition: all 0.3s ease-in-out 0s;
            }
            h5 > a:hover::before {
                visibility: visible;
                transform: scaleX(1);
            }
```

### 使用linear-gradient控制背景渐变

```css
.gradient-bg {
        background: linear-gradient(135deg, #f66, #f90, #3c9, #09f, #66f) left center/400% 400%;
        animation: move 10s infinite;
    }
    @keyframes move {
        0%,
        100% {
            background-position-x: left;
        }
        50% {
            background-position-x: right;
        }
    }
```

### 清除 overflow: auto;的滚动条

```css

.div{
  overflow: auto
}
 
.div::-webkit-scrollbar{
    display: none;
}
```



### 控制文本渐变

```css
                        background-image: linear-gradient(90deg, #f66, #f90);
                        background-clip: text;
                        animation: hue 5s linear infinite;
                        -webkit-text-fill-color: transparent;
                        @keyframes hue {
                            from {
                                filter: hue-rotate(0);
                            }
                            to {
                                filter: hue-rotate(-1turn);
                            }
                        }
                    }
```

### 气泡背景墙

```html
<div class="bruce" data-title="气泡背景墙">
	<ul class="bubble-bgwall">
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
	</ul>
</div>
```

```css
.bruce {
	background-image: linear-gradient(270deg, #8146b4, #6990f6);
}
.bubble-bgwall {
	overflow: hidden;
	position: relative;
	margin: 0 auto;
	width: 100%;
	max-width: 1200px;
	height: 100%;
	li {
		display: flex;
		position: absolute;
		bottom: -200px;
		justify-content: center;
		align-items: center;
		border-radius: 10px;
		width: 50px;
		height: 50px;
		background-color: rgba(#fff, .15);
		color: #ccc;
		animation: bubble 15s infinite;
		&:nth-child(1) {
			left: 10%;
		}
		&:nth-child(2) {
			left: 20%;
			width: 90px;
			height: 90px;
			animation-duration: 7s;
			animation-delay: 2s;
		}
		&:nth-child(3) {
			left: 25%;
			animation-delay: 4s;
		}
		&:nth-child(4) {
			left: 40%;
			width: 60px;
			height: 60px;
			background-color: rgba(#fff, .3);
			animation-duration: 8s;
		}
		&:nth-child(5) {
			left: 70%;
		}
		&:nth-child(6) {
			left: 80%;
			width: 120px;
			height: 120px;
			background-color: rgba(#fff, .2);
			animation-delay: 3s;
		}
		&:nth-child(7) {
			left: 32%;
			width: 160px;
			height: 160px;
			animation-delay: 2s;
		}
		&:nth-child(8) {
			left: 55%;
			width: 40px;
			height: 40px;
			font-size: 12px;
			animation-duration: 15s;
			animation-delay: 4s;
		}
		&:nth-child(9) {
			left: 25%;
			width: 40px;
			height: 40px;
			background-color: rgba(#fff, .3);
			font-size: 12px;
			animation-duration: 12s;
			animation-delay: 2s;
		}
		&:nth-child(10) {
			left: 85%;
			width: 160px;
			height: 160px;
			animation-delay: 5s;
		}
	}
}
@keyframes bubble {
	0% {
		opacity: .5;
		transform: translateY(0) rotate(45deg);
	}
	25% {
		opacity: .75;
		transform: translateY(-400px) rotate(90deg);
	}
	50% {
		opacity: 1;
		transform: translateY(-600px) rotate(135deg);
	}
	100% {
		opacity: 0;
		transform: translateY(-1000px) rotate(180deg);
	}
}
```

### 自动打字器

```html
<div class="bruce flex-ct-x" data-title="自动打字">
	<div class="auto-typing">Do You Want To Know More About CSS Development Skill</div>
</div>
```

```css
@mixin typing($count: 0, $duration: 0, $delay: 0) {
	overflow: hidden;
	border-right: 1px solid transparent;
	width: #{$count + 1}ch;
	font-family: Consolas, Monaco, monospace;
	white-space: nowrap;
	animation: typing #{$duration}s steps($count + 1) #{$delay}s infinite backwards,
		caret 500ms steps(1) #{$delay}s infinite forwards;
	// animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards,
	// 	caret 500ms steps(1) #{$delay}s $duration * 2 forwards;
}
.auto-typing {
	font-weight: bold;
	font-size: 30px;
	color: #09f;
	@include typing(52, 5);
}
@keyframes caret {
	50% {
		border-right-color: currentColor;
	}
}
@keyframes typing {
	from {
		width: 0;
	}
}
```



### 鼠标样式cursor

**default**小白 默认

**pointer**小手

**move**移动

**text**文本

**not-allowed**禁止



# JavaScript

#### 输入输出语句

alert(msg) 浏览器弹出警示框

console.log(msg) 浏览器打印输出信息

prompt(info) 浏览器弹出输入框

#### 网页跳转

```js
  //当前窗口跳转
   self.location.href=url
  //新窗口跳转
   window.open(url)
  //跳转链接 返回上一页
   window.history.back(-1);
```

 self 指代当前窗口对象，属于window 最上层的对象。

  location.href 指的是某window对象的url的地址

  self.location.href 指当前窗口的url地址，去掉self默认为当前窗口的url地址，一般用于防止外部的引用

top.location.href:为引用test.html页面url的**父窗口对象的url**

#### 滚动到页面顶部

```js
const goToTop = () => window.scrollTo(0, 0);
goToTop();
```



# TypeScript



### TypeScript 基础类型

#### Boolean 类型

```javascript
let isDone: boolean = false; // tsc => var isDone = false;
```

#### Number 类型

```javascript
let count: number = 10;  // tsc => var count = 10
```

#### String 类型

```javascript
let name: string = 'Semliker'; // tsc => var name = 'Semlinker'
```

#### Array 类型

```javascript
let list: number[] = [1,2,3]; // tsc => var list = [1,2,3];   

let list: Array<number> = [1,2,3]; 
// tsc => var list = [1,2,3];
```

#### Enum 类型

```javascript
enum Direction {
	NORTH,
    SOUTH,
    EAST,
    WEST
};

let dir: Direction = Direction.NORTH;
```

默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。

当然我们也可以设置 NORTH 的初始值，比如：

```javascript
enum Direction {
	NORTH = 3,
  SOUTH,
  EAST,
  WEST
};
```

在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。

```javascript
enum Direction {
  NORTH = 'NORTH',
  SOUTH = 'SOUTH',
  EAST = 'EAST',
  WEST = 'WEST',
}
```

#### Any (动态类型)

```javascript
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; 

=> tsc =>  

var notSure = 4;
notSure = "maybe a string instead";
notSure = false;
```

#### Tuple

元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。

```javascript
let x: [string, number];

x = ['semlinker', 10]; // 正常赋值

x = [10, 'semlinker']; // 类型不匹配
```

当访问一个已知索引的元素，会得到正确的类型：

```javascript
console.log(x[0].substr(1)); // OK

// Error, 'number' does not have 'substr' method
console.log(x[1].substr(1));
```

当访问一个越界的元素，会使用联合类型替代：

```javascript
x[3] = 'world'; // OK, 字符串可以赋值给(string | number) 类型

console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString 方法

x[6] = true; // Error, 布尔不是(string | number) 类型
```

#### Void

某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：

```javascript
// 声明函数返回值为void
function warnUser(): void { 
    console.log("This is my warning message");
}

=> tsc =>  

function warnUser() {
	console.log("This is my warning message");
}
```

需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 `undefined` 或 `null`：

```javascript
let unusable: void = undefined;
```



#### Never

`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。

```javascript
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {}
}
```

### 类型断言

通过这种方式可以告诉编译器，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。

类型断言有两种形式：

- “尖括号”语法

```javascript
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```

- as 语法

```javascript
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```





### TypeScript Function

#### 

#### 箭头函数

- 常见语法

```javascript
myBooks.forEach(() => console.log('Done reading'));

myBooks.forEach(title => console.log(title));

myBooks.forEach((title, idx, arr) => 
  console.log(idx + '-' + title);
);

myBooks.forEach((title, idx, arr) => {
  console.log(idx + '-' + title);
});
```

- 使用示例

```javascript
// 未使用箭头函数
function Book() {
  let self = this;
  self.publishDate = 2016;
  setInterval(function() {
    console.log(self.publishDate);
  }, 1000);
}

// 使用箭头函数
function Book() {
  this.publishDate = 2016;
  setInterval(() => {
    console.log(this.publishDate);
  }, 1000);
}
```

#### 参数类型和返回类型

```javascript
function createUserId(name: string, id: number): string {
  return name + id;
}
```

#### 函数类型

```javascript
let IdGenerator: (chars: string, nums: number) => string;

function createUserId(name: string, id: number): string {
  return name + id;
}

IdGenerator = createUserId;
```

#### 可选参数及默认参数

```javascript
// 可选参数
function createUserId(name: string, age?: number, 
  id: number): string {
    return name + id;
}

// 默认参数
function createUserId(name: string = 'Semlinker', age?: number, 
  id: number): string {
    return name + id;
}
```

#### 剩余参数

```javascript
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
  });
}

let a = [];
push(a, 1, 2, 3);
```

### TypeScript Array

#### 数组解构

```javascript
let x: number, let y: number ,let z: number;
let five_array = [0,1,2,3,4];
[x,y,z] = five_array;
```

#### 数组展开运算符

```javascript
let two_array = [0,1];
let five_array = [...two_array,2,3,4];
```

#### 数组循环

```javascript
let colors: string[] = ["red", "green", "blue"];
for(let i in colors) {
  console.log(i);
}
```

### TypeScript Object

#### 对象解构

```javascript
let person = {
  name: 'Semlinker',
  gender: 'male'
};

let {name, gender} = person;
```

#### 对象展开运算符

```javascript
let person = {
  name: 'Semlinker',
  gender: 'male',
  address: 'Xiamen'
};

// 组装对象
let personWithAge = {...person, age: 31};

// 获取除了某些项外的其它项
let {name, ...rest} = person;
```

### TypeScript Interface

在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。

TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象](https://ts.xcatliu.com/advanced/class-and-interfaces.html#类实现接口)以外，也常用于对「对象的形状（Shape）」进行描述。

#### 对象的形状

```javascript
interface Person {
  name: string;
  age: number;
}

let semlinker: Person = {
  name: 'Semlinker',
  age: 31
};
```

#### 可选 | 只读属性

```javascript
interface Person {
  readonly name: string;
  age?: number;
}
```

只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。

```javascript
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

### TypeScript Class

在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。

在 TypeScript 中，我们可以通过 `Class` 关键字来定义一个类：

```javascript
class Greeter {
   static cname: string = 'Greeter'; // 静态属性
   greeting: string; // 成员属行

   constructor(message: string) { // 构造函数 - 执行初始化操作
     this.greeting = message;
   }

    static getClassName() { // 静态方法
      return 'Class name is Greeter';
    }
    
    greet() { // 成员方法
      return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
```

### TypeScript Accessors

在 TypeScript 中，我们可以通过 `getter` 和 `setter` 方法来实现数据的封装和有效性校验，防止出现异常数据。

```javascript
let passcode = "hello angular 5";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "hello angular 5") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}
```

### TypeScript Inheritance

继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类 (称为子类、子接口) 继承另外的一个类 (称为父类、父接口) 的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种 [is-a](https://zh.wikipedia.org/wiki/Is-a) 关系。

![img](https://ask.qcloudimg.com/http-save/6430184/zpsfvhpn85.jpeg?imageView2/2/w/1620)

在 TypeScripe 中，我们可以通过 `extends` 关键字来实现继承：

```javascript
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
sam.move();
```

### TypeScript Generics

泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。

#### 泛型接口

```javascript
interface GenericIdentityFn<T> {
    (arg: T): T;
}
```

#### 泛型类

```javascript
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

#### 使用示例

```javascript
interface Hero { // Hero 接口
    id: number;
    name: string;
}

getHeroes(): Observable<Hero[]> {
  return Observable.of([
     { id: 1, name: 'Windstorm' },
     { id: 13, name: 'Bombasto' },
     { id: 15, name: 'Magneta' },
     { id: 20, name: 'Tornado' }
  ]);
}
```

上面 `getHeroes(): Observable<Hero[]>` 表示调用 `getHeroes()` 方法后返回的是一个 Observable 对象，`<Hero[]>` 用于表示该 Observable 对象的观察者，将会收到的数据类型。示例中表示将会返回 `<Hero[]>` 英雄列表。

### tsconfig.json 简介

#### tsconfig.json 的作用

- 用于标识 TypeScript 项目的根路径；
- 用于配置 TypeScript 编译器；
- 用于指定编译的文件。

#### tsconfig.json 重要字段

- files - 设置要编译的文件的名称；
- include - 设置需要进行编译的文件，支持路径模式匹配；
- exclude - 设置无需进行编译的文件，支持路径模式匹配；
- compilerOptions - 设置与编译流程相关的选项。

compilerOptions 支持很多选项，常见的有 `baseUrl`、 `target`、`baseUrl`、 `moduleResolution` 和 `lib` 等。

#### tsconfig.json 示例

```javascript
{
  "compileOnSave": false,
  "compilerOptions": {
    "baseUrl": "./",
    "outDir": "./dist/out-tsc",
    "sourceMap": true,
    "declaration": false,
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "es5",
    "typeRoots": [
      "node_modules/@types"
    ],
    "lib": [
      "es2017",
      "dom"
    ],
    "paths": {
      "ngx-example-library": [
        "dist/ngx-example-library"
      ]
    }
  },
  "angularCompilerOptions": {
    "preserveWhitespaces": false
  }
}
```

### 编码规范

#### 变量和函数

使用驼峰（camelCase）命名变量和函数名

```javascript
var FooVar;
function BarFunc() { }
```

**Good**

```javascript
var fooVar;
function barFunc() { }
```

#### 类

使用帕斯卡（PascalCase）命名类名

**Bad**

```javascript
class foo { }
```

**Good**

```javascript
class Foo { }
```

使用帕斯卡（PascalCase）命名类成员与方法

**Bad**

```javascript
class Foo {
    Bar: number;
    Baz() { }
}
```

**Good**

```javascript
class Foo {
    bar: number;
    baz() { }
}
```

#### 接口

- 使用帕斯卡（PascalCase）命名接口
- 使用驼峰（camelCase）命令成员
- 误使用 `I` 前缀

**Bad**

```javascript
interface IFoo { }
```

**Good**

```javascript
interface Foo { }
```

#### 类型

- 使用帕斯卡（PascalCase）命名
- 使用驼峰（camelCase）命令成员

#### 命名空间

使用帕斯卡（PascalCase）命名

**Bad**

```javascript
namespace foo { }
```

**Good**

```javascript
namespace Foo { }
```

#### 枚举

使用帕斯卡（PascalCase）命名枚举

**Bad**

```javascript
enum color { }
```

**Good**

```javascript
enum Color { }
```

使用帕斯卡（PascalCase）命名枚举成员

**Bad**

```javascript
enum Color {
    red
}
```

**Good**

```javascript
enum Color {
    Red
}
```

#### Null vs Undefined

最好不好显式使用不可用的值

**Bad**

```javascript
let foo = { x:123, y:undefined };
```

**Good**

```javascript
let foo: { x:number, y?:number } = { x:123 };
```

通常使用 undefined（ 而不是返回一个类似于 { valid:boolean, value?:Foo } 的对象 ）

**Bad**

```javascript
return null;
```

**Good**

```javascript
return undefined;
```

参考 Node.js 回调函数 Error First 风格（若未发生异常，error 参数值设置为 null）

**Bad**

```javascript
cb(undefined)
```

**Good**

```javascript
cb(null)
```

避免使用值比较判断对象是否为 null 或 undefined

**Bad**

```javascript
if (error === null)
```

**Good**

```javascript
if (error)
```

#### 数组

声明数组时使用 `foos:Foo[]` 而不是 `foos:Array<Foo>`，便于阅读

#### 类型 vs 接口

当你需要复合类型时，使用 type

```javascript
type Foo = number | { someProperty: number }
```

当你需要继承或实现时，使用 interface

```javascript
interface Foo {
  foo: string;
}

interface FooBar extends Foo {
  bar: string;
}

class X implements FooBar {
  foo: string;
  bar: string;
}
```

### 风格指南

1. 使用箭头函数代替匿名函数表达式。

2. 只要需要的时候才把箭头函数的参数括起来。比如，

   ```
   (x) => x + x
   ```

    是错误的，下面是正确的做法：

   - `x => x + x`
   - `(x,y) => x + y`
   - `<T>(x: T, y: T) => x === y`

3. 总是使用 `{}` 把循环体和条件语句括起来。

4. 小括号里开始不要有空白。逗号，冒号，分号后要有一个空格。比如：

   - `for (let i = 0, n = str.length; i < 10; i++) { }`
   - `if (x < 10) { }`
   - `function f(x: number, y: string): void { }`

5. 每个变量声明语句只声明一个变量 。比如：使用 `let x = 1; var y = 2;` 而不是 `let x = 1, y = 2;`）。

6. 如果函数没有返回值，最好使用 `void`



### 接口(interface)

#### 定义使用

```tsx
interface User {
  brief: string;
}

const state: User = reactive({
  brief: "",
});
```

#### 非必填(?)



字段为**非必填**, 用"?"标记:

```ts
interface User {
  brief: string;
  test?: string;
}
const state: User = reactive({
  brief: "",
});
```

#### 用接口定义函数
接口不仅可以定义对象, 还可以定义函数:

```tsx
// 声明接口
interface Core {
    (n:number, s:string):[number,string]
}

// 声明函数遵循接口定义
const core:Core = (a,b)=>{
    return [a,b];
}
```

#### 用接口定义类
先简单看下如何给类定义接口, 后面的课程具体讲类:

```tsx
// 定义
interface Animate {
    head:number;
    body:number;
    foot:number;
    eat(food:string):void;
    say(word:string):string;
}
```

```tsx
// implements
class Dog implements Animate{
    head=1;
    body=1;
    foot=1;
    eat(food){
        console.log(food);
    }
    say(word){
        return word;
    }
}
```

#### 交叉类型(&)
交叉类型是将多个类型合并为一个类型, 表示"并且"的关系,用&连接多个类型, 常用于对象合并:

```tsx
interface A {a:number};
interface B {b:string};

const a:A = {a:1};
const b:B = {b:'1'};
const ab:A&B = {...a,...b};
```

#### 联合类型(|)
交叉类型也是将多个类型合并为一个类型, 表示"或"的关系,用|连接多个类型:

```tsx
function setWidth(el: HTMLElement, width: string | number) {
    el.style.width = 'number' === typeof width ? `${width}px` : width;
}
```

### 定义倒计时

```ts
      setTimeout(async () => {
        await ConutSort();
        await GetFySortTitleAsync();
        dataList.spinning = false;
      }, 2000);
    });
```



# VUE



##  vue3生命周期

```js
setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method
onBeforeMount() : 组件挂载到节点上之前执行的函数。
onMounted() : 组件挂载完成后执行的函数。
onBeforeUpdate(): 组件更新之前执行的函数。
onUpdated(): 组件更新完成之后执行的函数。
onBeforeUnmount(): 组件卸载之前执行的函数。
onUnmounted(): 组件卸载完成后执行的函数
onActivated(): 被包含在<keep-alive>中的组件，会多出两个生命周期钩子函数。被激活时执行。
onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。
onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数（不太会用。还在了解中）
```



## 基础指令

### 文本插值

```
{{ }}
```

### v-once

- v-once 用于指定元素或者组件只渲染一次
- 当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过；
- 该指令可以用于性能优化；
- 如果是子节点，也是只会渲染一次

```html
<span v-once>这个将不会改变: {{ msg }}</span>
```

### v-html

该指令后面往往会跟上一个string类型会将string的html解析出来并且进行渲染

```html
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

### v-if

```vue
<h1 v-if="awesome">Vue is awesome!</h1>
<h1 v-else>Oh no 😢</h1>
```

### v-show

cbbaa tfftt只是简单地切换元素的 CSS property `display`。

```vue
<h1 v-show="ok">Hello!</h1>
```

### v-for

- v-for的基本格式是 "item in 数组
- v-for也支持遍历对象，并且支持有一二三个参数

1. 一个参数： "value in object";
2. 二个参数： "(value, key) in object";
3. 三个参数： "(value, key, index) in object";

- v-for同时也支持数字的遍历

#### 基于一个数组来渲染一个列表

```vue
<ul id="example-1">
  <li v-for="item in items" :key="item.message">
    {{ item.message }}
  </li>
</ul>
```

```js
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
```

可选的第二个参数，即当前项的索引。

```vue
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
```

###### 以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法：

```vue
<div v-for="item of items"></div>
```

####   遍历对象

```vue
<ul id="v-for-object" class="demo">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>
```

```js
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
```

提供第二个的参数为 property 名称 (也就是键名)：

```vue
<div v-for="(value, name) in object">
  {{ name }}: {{ value }}
</div>
```

还可以用第三个参数作为索引：

```vue
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```

唯一key

```vue
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
```



####  使用值范围

`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。

```vue
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
```

#### 在template使用

```vue
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
```

#### 自定义组件上使用

```vue
<my-component v-for="item in items" :key="item.id"></my-component>
```



##### for if同时使用

当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量，这时，可以把 v-for 移到 <template> 中

```vue
//示例1
<template v-for="(item, index) in ResultList" :key="index">
   <a @click="onk(item.path)" v-if="item.identity">
    {{item.title}}
   </a>
</template>
//示例2
<template v-for="todo in todos" :key="todo.name">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```



### v-bind

```vue
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a :[key]="url"> ... </a>
```

#### img绑定属性

```vue
<img v-bind:src="imgUrl"/>
```

#### 动态绑定

```vue
<a v-bind:[attributeName]="url"> ... </a>
```

> **v-bind 动态绑定class（对象语法）**
>
> - 可以通过{ }绑定一个类
> - 也可以通过判断，传入多个值
> - 和普通类同时存在，并不冲突
> - 如果过于复杂，可以放在一个methods或者computed中

#### 对象语法

```js

<template>
  <div id="snHeader">
      <el-menu
        :class="{active: isActive , line: isLine}"
      >
        <button @click="but()">a</button>
      </el-menu>
  </div>
</template>

<script>

  export default {
    name: "SnHeader",
    components: {},
    data() {
      return {
        active: 'el-menu',
        isActive: true,  //设置boolean值决定是否启用
        isLine: true
      };
    },

    methods: {
      but() {
        this.isActive = !this.isActive
        // return { active: this.isActive, line: this.isLine }
      },
    }
  };
</script>

<style lang="scss" scoped>
    
    .active {
      color: blue;
      @apply bg-red-400;
    }
  }

</style>

```

#### **数组语法**

```vue
<div id="app">
  <!-- 如果在[]数组里的元素加了引号，代表他是一个字符串，而不是引用一个变量 -->
  <h2 :class="[active,line]">{{massage}}</h2>
  <h2 :class="['active','line']">{{massage}}</h2>
</div>
```

####  绑定style

```vue
<div id="app">
<!-- <h2 :style="{key(属性名):value(属性值)}">{{massage}}</h2> -->
  <!-- 这里要加' '要不然vue会去解析50px这个变量然后报错 -->
  <h2 :style="{fontSize: '50px'}">{{massage}}</h2>
  
  <!-- finalSize当成一个变量在使用 -->
  <h2 :style="{fontSize: finalSize}">{{massage}}</h2>

  <!-- 也可以拼接 -->
  <h2 :style="{fontSize: finalSize + 'px',color:finalColor}">{{massage}}</h2>

  <!-- 数组语法 -->
  <h2 :style="[baseStyle,baseStyle1]">{{massage}}</h2>
</div>

<body>
	<script src="../js/vue.js"></script>
	<script>
		const app = new Vue({
			el: "#app",
			data: {
				massage: "你好",
        finalSize: 100,
        finalColor: 'red',
        baseStyle:{color:'red'},
        baseStyle1:{fontSize:'75px'}
			}
		})
	</script>
</body>
```

### v-on:click

#### 基础语法

```vue
<a v-on:click="doSomething">...</a>
```

动态的事件名绑定处理函数

```vue
<a v-on:[eventName]="doSomething"> ... </a>
```

```vue
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a @[event]="doSomething"> ... </a>
```

#### 事件修饰符

```vue
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a
    
    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

#### 按键修饰符

```vue
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```

#### .exact 修饰符

修饰符允许你控制由精确的系统修饰符组合触发的事件

```vue
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button v-on:click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button v-on:click.exact="onClick">A</button>
```

#### 鼠标按钮修饰符

```
.left
.right
.middle
```

### v-model

`v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。

#### 文本

```vue
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```

#### 多行文本

```vue
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
```

#### 复选框

单个复选框，绑定到布尔值：

```vue
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
```

多个复选框，绑定到同一个数组：

```vue
<div id='example-3'>
  <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
  <label for="jack">Jack</label>
  <input type="checkbox" id="john" value="John" v-model="checkedNames">
  <label for="john">John</label>
  <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
  <label for="mike">Mike</label>
  <br>
  <span>Checked names: {{ checkedNames }}</span>
</div>
```

```js
new Vue({
  el: '#example-3',
  data: {
    checkedNames: []
  }
})
```

单选按钮

```vue
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br>
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>
```

```js
new Vue({
  el: '#example-4',
  data: {
    picked: ''
  }
})
```

#### 选择框

单选时：

```vue
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>
```

```js
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
```

多选时 (绑定到一个数组)：

```vue
<div id="example-6">
  <select v-model="selected" multiple style="width: 50px;">
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <br>
  <span>Selected: {{ selected }}</span>
</div>
```

```js
new Vue({
  el: '#example-6',
  data: {
    selected: []
  }
})
```

用 `v-for` 渲染的动态选项：

```vue
<select v-model="selected">
  <option v-for="option in options" v-bind:value="option.value">
    {{ option.text }}
  </option>
</select>
<span>Selected: {{ selected }}</span>
```

```js
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})
```

#### 值绑定

```vue
<!-- 当选中时，`picked` 为字符串 "a" -->
<input type="radio" v-model="picked" value="a">

<!-- `toggle` 为 true 或 false -->
<input type="checkbox" v-model="toggle">

<!-- 当选中第一个选项时，`selected` 为字符串 "abc" -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>
```

### 修饰符

- .lazy：默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步：

  ```html
  <!-- 在“change”时而非“input”时更新 -->
  <input v-model.lazy="msg" />
  复制代码
  ```

- .number：如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：

  ```html
  <input v-model.number="age" type="number" />
  复制代码
  ```

- .trim：如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：

```html
<input v-model.trim="msg" />
```








### v-text

都是用于将数据显示在界面中，但是通常只接受一个string类型

用于更新元素的 textContent

```vue
<div v-text="message"></div>
<div v-text="msg"></div> 等价于 <div>{{msg}}</div>
```

### v-pre

- v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签
- 跳过不需要编译的节点，加快编译的速度

```html
<h2 v-pre>{{massage}}</h2> <!-- {{massage}} -->
```

### v-cloak

保持在元素上直到关联组件实例结束编译； 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实 例准备完毕。

### watch

侦听的是data中的数据 默认情况下侦听data数据本身的改变（内部侦听的改变是不能侦听的） 如：侦听data中的 msg 的变化，由`msg: { name: "wx", age: 20 }`改变成`msg: { name: "wxwx", age: 20 }`是侦听不到`msg.name`的变化的。

需要侦听到内部的变化需要做如下处理: 对msg做深度侦听，不在是写成函数形式，而写成对象形式

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("侦听msg内部数据是不是变化了", msg.name);
      },
      deep: true, // 深度侦听
    }
}
methods: {
    changeMsgName() {
      this.msg.name = "wxwx"
    }
}
```

可执行了以上代码的console，所以msg内部数据的改变有被侦听到。

watch还可以在页面渲染的时候对需要立即执行的data数据进行侦听，需要在对象中加上一个 immediate 就行

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("newInfo", newInfo, "oldInfo", oldInfo)
      },
      deep: true, // 深度侦听
      immediate: true // 立即执行
    }
}
```

页面渲染时会有以上console的打印，但是 oldInfo 是 undefined。

注意：当去改变data数据中对象的内部值时，newInfo 和 oldInfo 的值都是改变后的值

通过一下方式可以拿到oldInfo（旧值）

```js
watch: {
    "msg.name": function(newName, oldName) {
      console.log(newName, oldName);
    },
},
```

以上console打印 wx wxx

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("newValue:", newInfo.name, "oldValue:", oldInfo.name);
      },
      deep: true, // 深度侦听
    }
},
methods: {
    changeMsgName() {
      this.msg.name = "wxwx";
    },
}
```

以上console输出的 newInfo 和 oldInfo 都是 "wxwx"

#### watch 实现侦听的其他方式

1. 只侦听某个对象中的值

```js
watch: {
    "msg.name": function(newName, oldName) {
      console.log(newName, oldName);
    },
},
```

1. 使用this.$watch来侦听

```js
created() {
    this.$watch("msg", function(newInfo, oldInfo) {
      console.log(newInfo, oldInfo);
    }, {
      deep: true,
      immediate: true
    })
}
```



## 组件基础

##### 基本示例：

```js
// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})
```

创建的 Vue 根实例中，把这个组件作为自定义元素来使用：

```vue
<div id="components-demo">
  <button-counter></button-counter>
</div>

new Vue({ el: '#components-demo' })
```

##### 组件名

```js
Vue.component('my-component-name', { /* ... */ })
```

这些组件是**全局注册的**。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (`new Vue`) 的模板中

##### 局部注册

通过一个普通的 JavaScript 对象来定义组件：

```js
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
```

然后在 `components` 选项中定义你想要使用的组件：

```js
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```

##### 在模块中局部注册

```js
import ComponentA from './ComponentA'
import ComponentC from './ComponentC'

export default {
  components: {
    ComponentA,
    ComponentC
  },
  // ...
}
```

##### 自动化全局注册

可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为[基础组件](https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐)，它们会在各个组件中被频繁的用到。

```js
import Vue from 'vue'
import upperFirst from 'lodash/upperFirst'
import camelCase from 'lodash/camelCase'

const requireComponent = require.context(
  // 其组件目录的相对路径
  './components',
  // 是否查询其子目录
  false,
  // 匹配基础组件文件名的正则表达式
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName => {
  // 获取组件配置
  const componentConfig = requireComponent(fileName)

  // 获取组件的 PascalCase 命名
  const componentName = upperFirst(
    camelCase(
      // 获取和目录深度无关的文件名
      fileName
        .split('/')
        .pop()
        .replace(/\.\w+$/, '')
    )
  )

  // 全局注册组件
  Vue.component(
    componentName,
    // 如果这个组件选项是通过 `export default` 导出的，
    // 那么就会优先使用 `.default`，
    // 否则回退到使用模块的根。
    componentConfig.default || componentConfig
  )
})
```

**全局注册的行为必须在根 Vue 实例 (通过 `new Vue`) 创建之前发生**

##### 通过 Prop 向子组件传递数据

Prop 是你可以在组件上注册的一些自定义 attribute。为了给博文组件传递内容

创建子组件

BlogInformation.vue

```vue

<template>
  <div class="index-si-count">
        <div class="index-si-count-frame-title">文章数量:</div>
        <div class="index-si-count-frame-text">{{ ArticleCount }} 篇</div>
        <div class="index-si-count-frame-title">总字段数:</div>
        <div class="index-si-count-frame-text">{{ TextCount }} 字</div>
        <div class="index-si-count-frame-title">总访问量:</div>
        <div class="index-si-count-frame-text">{{ ReadCount }} ℃</div>
        <div class="index-si-count-frame-title">最后更新:</div>
        <div class="index-si-count-frame-text">{{ Articledata }}</div>
  </div>
</template>

<script>
  export default {
    props: ['ArticleCount', 'TextCount', 'ReadCount', 'Articledata'],
  }
</script>

```

```vue
      <!-- 站点统计框 -->
      <blog-information
        :ArticleCount="ArticleCount"
        :TextCount="textCount"
        :ReadCount="readCount"
        :Articledata="articledata"
      ></blog-information>
```

数组：

```tsx
<template>
      <a>{{ title }}</a>
</template>

<script>
  export default {
    props: ['title'],
  }
</script>

```

并想要为每篇博文渲染一个组件：

```html
      <!-- 标签框内容 -->
      <div class="index-si-tag">
        <div class="index-si-tag-title">标签</div>
        <blog-tag
          v-for="Labeslss in Labels"
          :key="Labeslss.labelId"
          :title=" Labeslss.labelName"
          @click="TagSkip(Labeslss.labelId)"
        ></blog-tag>
      </div>
```

## 事件处理

### 内联处理器中的方法

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：

```javascript
<button @click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>

    let warn = async (message: any, event: any) => {
      // 现在可以访问到原生事件
      if (event) {
        event.preventDefault()
      }
      alert(message)
    }
```

### 多事件处理器

事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：

```javascript
<button @click="one($event), two($event)">
  Submit
</button>

methods: {
  one(event) {
    // 第一个事件处理器逻辑...
  },
  two(event) {
   // 第二个事件处理器逻辑...
  }
}
```

### 事件修饰符

- .stop：阻止事件冒泡
- .prevent：阻止默认事件发生
- .capture：捕获冒泡，即有冒泡发生时，有该修饰符的dom元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件
- .self：将事件绑定到自身，只有自身才能触发，通常用于避免冒泡事件的影响
- .once：设置事件只触发一次
- .passive：用于对DOM的默认事件进行性能优化
- .native：在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加'. native'事件是无法触 发的。

### 按键别名

- .enter
- .tab
- .delete (捕获“删除”和“退格”键)
- .esc
- .space
- .up
- .down
- .left
- .right

### 系统修饰键

可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。

- .ctrl
- .alt
- .shift
- .meta

注意修饰键与常规按键不同，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 `ctrl` 的情况下释放其它按键，才能触发 `keyup.ctrl`。而单单释放 `ctrl` 也不会触发事件。

### .exact 修饰符

`.exact` 修饰符允许你控制由精确的系统修饰符组合触发的事件。

```html
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button @click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button @click.exact="onClick">A</button>
```

## **keep-alive**



### 默认缓存所有组件

```vue
<router-view  class="content" v-slot="{ Component }">
  <keep-alive>
    <component :is="Component" />
  </keep-alive>
</router-view>
```

### 缓存指定组件

Vue3.0配合的slot插槽使用，使用is来绑定对应路由的组件。

```vue
<template> 
    <!-- vue3.0配置 --> 
    <router-view v-slot="{ Component }"> 
    <keep-alive> 
        <component :is="Component" v-if="$route.meta.keepAlive"/> 
    </keep-alive> 
        <component :is="Component" v-if="!$route.meta.keepAlive"/> 
    </router-view> 
</template>
```

 路由router添加meta配置

可以注释哪一页面需要使用缓存，但是也可以不设置，不设置的情况需要将上面的属性都删掉。如果需要更多的缓存限制，可以看底下的参考网站。

```js
const routes = [
  {
    path: '/keepalive',
    name: 'keepalive',
    component: ()=>import('../views/keepalive.vue'),
    meta: {
          keepAlive: false //设置页面是否需要使用缓存
    }
  }
 ]
```

## script setup**props和emit**

因为3.0中 我们的思想都是 先import 再使用 并非一次性把所有api 都全部加载了 所以 用props 和emit 也是一样的啦 用前先引用

需要先去引入defineProps和defineEmit。这样引入是因为用了script setup标签，就相当于props和emit

```vue
<template>
  <div>
    {{ msg }}
    <button @click="onClick">点击按钮</button>
  </div>
</template>

<script setup>
import { defineProps, defineEmit } from "vue";// props emit
let props = defineProps({
  msg: String,
});
console.log(props);

let emit = defineEmit(["click"]);
const onClick = () => {
  emit("click");
console.log("click。。。");

};
</script>
```

app,vue中

```vue
<template>
  <img alt="Vue logo" src="./assets/logo.png" />
  <HelloWorld msg="Hello Vue 3.0 + Vite" />
  <msg msg="天气很好" @click="onClick"></msg>
</template>

<script setup>
import HelloWorld from './components/HelloWorld.vue'
import msg from "./components/msg.vue"
</script>
```

## Compostition API

### ref和toRef的区别

- ref 和toRef 修改响应式数据都会会影响以前的数据
- ref 数据发生改变，界面就会自动更新
- toRef数据发生改变，界面也不会自动更新

### toRefs

将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 [`ref`](https://link.juejin.cn?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Frefs-api.html%23ref)。

或者说将一个对象身上的所有属性变为响应式数据可以使用。 **以上这些方法都是为了提升性能。主要用的多的还是ref和reactive**

### watchEffect

这个也是用来监听数据变化，默认就会执行一次所以这里就不需要配置，而且不用指定 `data`,使用哪些响应式数据就监听哪些

```js
let user = reactive({
    name: '小浪',
    age: 21,
})
// 只有 user.name 发生改变这个就会执行
watchEffect(() => {
    console.log(user.name)
});
```

### provide / inject

提供 和 注入 是很简单理解的

> 实现跨层级组件(祖孙)间通信

在多层嵌套组件中使用，不需要将数据一层一层地向下传递

可以实现 跨层级组件 通信

在 父组件中

```js
setup() {
    const info = reactive({
        title: 'Vue3学习'
        date: '2021/7/23'
    })
    //  提供的数据名，数据值
    provide('info', info)
    
    return {
        info
    }
}
```

在 子孙 层级组件使用注入就能够获取到了

```js
setup() {
    //获取对应数据的值
    const color = inject('info')
    return {
        info
    }
}
```



### `Teleport` 传送组件

 (瞬移)这个组件特别有趣，可以把组件进行传送

```html
<teleport v-if="flag" to=".test">
    <div class="dog">狗子</div>
</teleport>
复制代码
```

`to` 是目标的地址 `body` , `#XXX` , `.XXX` 这些都是 `css` 选择器

### defineProps

#### 单字段使用

##### 子组件

```tsx
<script setup lang="ts">
defineProps({
  title: {
    type: String,
    default: () => 'title',
  },
  oneText: String,
  oneRead: Number,
})
</script>
<template>
   <a class="text-lg">{{ title }}</a>
   <div class="One-top-give">{{ oneText }}</div>
   <div>({{ oneRead }})</div>
</template>
```

##### 父组件

```tsx
   <OneTop
     :title="state.dataOne.oneTitle"
     :oneText="state.dataOne.oneText"
     :oneRead="state.dataOne.oneRead"
   ></OneTop>
```

#### 数组泛型方式

##### 子组件

```tsx
<script lang="ts" setup>
import { method } from '../index'

interface one {
  oneId: number
  oneTitle: string
  oneText: string
  oneImg: string
  oneTypeId: number
  oneAuthor: string
  oneData: string
  oneRead: number
  oneGive: number
  oneComment: number
}

defineProps({
  resultData: {
    type: Array as () => Array<one>, //(string也可以是其他你自定义的接口)
    required: true,
    default: () => [],
  },
})
</script>

<template>
    <div class="One-list-div" v-for="data in resultData" :key="data.oneId">
          <a @click="method.setModal1Visible(true, data.oneId)">
            {{ data.oneTitle }}
          </a>
        <p class="One-list-div-frame-text">{{ data.oneText }}</p>
    </div>
</template>
```

##### 父组件

```vue
   <!-- list -->
   <OneContent :resultData="state.resultData"></OneContent>
   <!-- end list -->
```

#### Unexpected mutation of "props" prop

```js
<script setup lang="ts">
import { onBeforeUpdate, reactive } from 'vue'
//v-model 不能直接修改
const props = defineProps<{
  result: string
  loading?: boolean
}>()

const state = reactive({
  result: props.result,
})
//在更新之前赋值
onBeforeUpdate(async () => {
  state.result = props.result
})
</script>

 <v-md-editor v-model="state.result" mode="preview"></v-md-editor>
```



## 数组方法

```vue
  <script>
    const app = new Vue({
      el: "#app",
      data: {
        letters: ['A', 'C', 'B', 'D', 'E']
      },
      methods: {
        btnClick() {
          // 1.push()   在数组最后添加元素
          this.letters.push('aaa','bbb')

          // 2.pop()      在数组最后删除一个元素
          this.letters.pop();

          // 3.shift()   删除在数组第一个元素
          this.letters.shift();

          // 4.unshift() 在数组最前面添加元素
          this.letters.unshift('ddd','ddd');

          // 5.splice()   删除/插入/替换元素
          // 删除元素: 第一参数传入你从第几个元素开始删除，第二参数传入你要删除的几个元素(如果没有传,就删除后面所有元素)
          // 插入元素: 第二个传入0，后面跟上要添加的值
          // 替换元素: 第二参数传入你要删除元素，后面追加你要写入的元素完成替换
          this.letters.splice(1,3,'m','n','l')

          // 6.sort()     排序
          this.letters.sort()

          // 7.reverse()  反转
          this.letters.reverse()

          // 注意：通过索引值直接来修改数组中的元素 不是响应式
          // this.letters[0]='bbbbbbbbbbbb'
          // set(要修改的对象，索引值，修改后的值)
          Vue.set(this.letters,0,'bbbbbb')
        }
      }
    })

    // 扩展知识：可变参数
    // function sum(...sum){
    //   console.log(sum);
    // }
    // sum(11,223,44,56,77,889,9,1)
  </script>

```



## vue.config.js

```js
/*
 * @Author: your name
 * @Date: 2020-12-14 17:16:33
 * @LastEditTime: 2021-09-14 14:51:51
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \blogs-s\src\vue.config.js
 */
// const CompressionWebpackPlugin = require("compression-webpack-plugin");

const path = require("path");
const resolve = dir => path.join(__dirname, dir);

module.exports = {

  // devServer: {
  //   host: '10.175.112.61', // ip
  //   port: 8082, // 设置端口号
  //   https: false, // https:{type:Boolean}
  //   open: false, //配置自动启动浏览器
  //   proxy: null //设置代理
  // },
  chainWebpack: config => {
    config.resolve.extensions
      .add('ts')
      .add('tsx');
    // 修复热更新失效
    config.resolve.symlinks(true);
    //  如果使用多页打包，使用vue inspect --plugins 查看html是都在结果数组中

    // eslint-disable-next-line no-undef
    config.plugin('cache').use(HardSourceWebpackPlugin);
    // 文件引入时，自定义别名
    // eslint-disable-next-line no-undef
    config.resolve.alias
      .set("@", resolve("src"))
      .set("vue$", "vue/dist/vue.esm.js")
      .set("a", resolve("src/assets"))
      .set("c", resolve("src/components"))
      .set("v", resolve("src/views"))
      .set("r", resolve("src/router"))
      .set("api", resolve("src/api"))
      .set("s", resolve("src/store"));

    // 字体文件自定义配置
    config.module
      .rule("fonts")
      .test(/\.(woff2?|eot|ttf|otf)(\?.*)?$/i)
      .use("url-loader")
      .loader("url-loader")
      .options({
        limit: 4096,
        fallback: {
          loader: "file-loader",
          options: {
            name: `/static/fonts/[name].[ext]`
          }
        }
      });


  },

  // 基本路径
  publicPath: "./",
  // 相对于打包路径index.html的路径
  indexPath: "index.html",
  // 文件输出目录
  outputDir: "dist",
  // eslint-loader 是否在保存的时候检查
  lintOnSave: false,
  // 生成的静态资源存放的目录
  assetsDir: "static",
  // 以多页模式构建应用程序
  pages: undefined,
  // 是否使用包含运行时编译器的vue构建版本
  runtimeCompiler: false,
  // 是否为babel或typescript使用thread-loader，在系统的CPU有多于一个内核时自动启用，仅作用于生产环境，在适当的时候开启多线程去并发的执行压缩
  parallel: require("os").cpus().length > 1,
  // 生产环境是否生成sourceMap 文件，一般不建议打开
  productionSourceMap: false,
  // 调整webpack配置
  configureWebpack: (config) => {

    // 取消webpack警告性能的提示
    config.performance = {};
    // 打包分离js
    config.optimization = {
      splitChunks: {
        chunks: "async",
        minChunks: 2,
        minSize: 100000,
        cacheGroups: {
          base: {
            name: "base",
            minChunks: 1,
            test: /[\\/]node_modules[\\/]vue[\\/]|[\\/]node_modules[\\/]vue-router[\\/]|[\\/]node_modules[\\/]vuex[\\/]|[\\/]node_modules[\\/]axios[\\/]/,
            chunks: "initial",
            priority: -3
          },
          antd: {
            name: "ant-design",
            test: /[\\/]node_modules[\\/]ant-design-vue[\\/]/,
            chunks: "initial",
            minChunks: 1,
            priority: -4,
            reuseExistingChunk: true,
            enforce: true
          }
        }
      }
    };
    config.optimization.runtimeChunk = {
      name: "manifest"
    };
  },
  // css相关配置
  css: {
    // 将组件内的 CSS 提取到一个单独的 CSS 文件 (只用在生产环境中)
    // 也可以是一个传递给 `extract-text-webpack-plugin` 的选项对象
    extract: true,
    // 是否开启 CSS source map？
    sourceMap: true,
    // 为所有的 CSS 及其预处理文件开启 CSS Modules。
    // 这个选项不会影响 `*.vue` 文件。
    modules: false,
    requireModuleExtension: true, // 是否仅对文件名包含module的css相关文件使用 CSS Modules
    // 为预处理器的 loader 传递自定义选项。比如传递给
    // sass-loader 时，使用 `{ sass: { ... } }`。
    loaderOptions: {
      css: {
        module: {
          rules: [
            // ... 其它规则省略
            {
              test: /\.css$/,
              use: [
                'vue-style-loader',
                "style-loader",
                // Translates CSS into CommonJS
                "css-loader",
                // Compiles Sass to CSS
                "sass-loader",
                {
                  loader: 'css-loader',
                  options: {
                    // 开启 CSS Modules
                    modules: true,
                    // 自定义生成的类名
                    localIdentName: '[local]_[hash:base64:8]'
                  }
                },
              ]
            }
          ]
        }
      }, // css预设器配置项 详见https://cli.vuejs.org/zh/config/#css-loaderoptions
      sass: {
        data: `@import "./styles/uitl.scss";`,
      },
    },

  },
  // PWA插件相关配置
  pwa: {},
  // 第三方插件配置
  pluginOptions: {}

}
```

## transitiond过度动画

```vue
<transition :name="transitionName" mode="out-in">
      <router-view class="home-router"></router-view>
    </transition>
```

```js
<script>
export default {
  name: 'App',
  data () {
    return {
      transitionName: 'slide-right'
    }
  },
  methods: {
  },
}
</script>
```

```css
<style>
  .home-router {
    transition: all 0.5s ease;
  }
   /*过度前*/
   .slide-left-enter,
  .slide-right-leave-active {
    opacity: 0;
    -webkit-transform: translate(0, 0);
    transform: translate(0, 0);
  }
  /*后*/
  .slide-left-leave-active,
  .slide-right-enter {
    opacity: 0;
    -webkit-transform: translate(-100%, 0);
    transform: translate(-100% 0);
  }
</style>
```

## 给封装好的组件加click事件

```vue
<MenuItem name="/" to="/" @click.native="handclick(1)">我的项目</MenuItem>
```

## 回到顶部功能

```vue
 <div id="backtop">
            <p @click="backtop">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#icon-globaltop"></use>
                </svg>
            </p>
        </div>
```

```js
<script>
  export default {
    mounted() {
       window.addEventListener("scroll",this.showbtn,true);
    },
    methods: {
        // 显示回到顶部按钮
       showbtn(){
          let that = this;
          let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
          that.scrollTop = scrollTop
       },
      /**
        * 回到顶部功能实现过程：
        * 1. 获取页面当前距离顶部的滚动距离（虽然IE不常用了，但还是需要考虑一下兼容性的）
        * 2. 计算出每次向上移动的距离，用负的滚动距离除以5，因为滚动的距离是一个正数，想向上移动就是做一个减法
        * 3. 用当前距离加上计算出的距离，然后赋值给当前距离，就可以达到向上移动的效果
        * 4. 最后记得在移动到顶部时，清除定时器
      */
      backtop(){
          var timer = setInterval(function(){
            let osTop = document.documentElement.scrollTop || document.body.scrollTop;
            let ispeed = Math.floor(-osTop / 5); 
            document.documentElement.scrollTop = document.body.scrollTop = osTop + ispeed;
            this.isTop = true;
            if(osTop === 0){
              clearInterval(timer);
            }
          },30)
      }
    }
  }
</script>
```



## vue3中的模块化使用

如果当前组件内声明的变量和方法多了以后。还是会增加代码量和可读性。这时候我们可以将耦合性低的一些代码和方法作为模块化提取出去。在需要使用的组建内直接引用即可。例如一个时间组件

```tsx

 //FilePath: \blogs-s\src\views\common\hooks\index.ts
import router from '../router/index';

const Routers = async (path: string) => {
  await router.push({
    path: path,
    query: {
      t: +new Date()
    }
  })
};

export {
  Routers
}

```



VUE

```tsx
<script lang="ts">
import { defineComponent } from "vue";
import { Routers } from "../../hooks/index";

export default defineComponent({
  setup() {
    return {
      Routers,
    };
  },
});
</script>
```

## vue动态导入css样式

### dynamicScss.ts

```ts
const SCSS: number = 1;
async function toScss(nameCss: string) {

  switch (nameCss) {
    case "sAbout":
      if (SCSS === 1) {
        import('../views/sAbout/index.scss').then(() => {
          console.log("import css 1")
        })
      } else {
        console.log("import css 2")
      }
      break;
  }

}
export {
  toScss
}
```

### vue组件导入

```tsx
import { toScss } from "../../hooks/dynamicScss";

await toScss("sAbout");
```

##  vue 封装ts属性

### **data.ts**

```tsx

import { reactive } from "vue";
export interface BlogsList {
  dataResult: any, // 显示的数据
  page: number, //页码
  pagesize: number, //每页条数
  count: number, //总数
}

export const blogsList: BlogsList = reactive({
  dataResult: [],
  page: 1,
  pagesize: 10,
  count: 0,
})

```

### **vue**

```tsx
import { blogsList } from "../Blogs/components/data";
```

## vue封装函数

### index.ts

```tsx

import { article } from '@/api/index';
import { blogsList } from "./components/data";
export class blogs {

  static async GetFySortTitle() {
    await article.GetFySortTitleAsync(blogsList.page, blogsList.pagesize).then((result: any) => {
      return blogsList.dataResult = result.data;
    });
  }

}
```

### index.vue

```ts
import { blogs } from "./index";
await blogs.GetFySortTitle();
```

##  全局挂载

```tsx
main
import axios from './api/axios'
const app = createApp(App);
// 全局ctx(this) 上挂载 $axios
app.config.globalProperties.$api = axios

vue
const { proxy }: any = getCurrentInstance() //获取上下文实例，ctx=vue2的this
 proxy.$api
```

## Props

经常这样写 prop:

```tsx
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：

```tsx
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
```

## vue-cli4中使用jquery

### 1. 安装jquery

```javascript
npm install jquery --save
```

### 2. 添加vue.config.js文件

```js
config.plugin('provide').use(webpack.ProvidePlugin, [{
            $: 'jquery',
            jquery: 'jquery',
            jQuery: 'jquery',
            'window.jQuery': 'jquery'
        }])
```

### 3. 引入jquery

```
 import $ from 'jquery'
```

## Vue3防抖节流

- 函数防抖（debounce）

就是指触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间。
简单的说，当一个动作连续触发，只执行最后一次。

- 函数节流（throttle）

   在一段时间内，函数最多可以触发一次执行,限制一个函数在一定时间内只能执行一次

### 防抖节流封装

```tsx
/**
 * @description: 防抖 debounce
 * @param {any} fn
 * @param {number} delay
 * @return {*}
 */
function debounce(fn: any, delay: number) {
  let timer: any
  return function () {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn()
    }, delay)
  }
}

export {
  debounce
}
```

### 使用

```tsx
import { debounce,throttle } from '@/utils/dethrottle'
   //防抖
    const num = ref(1)
    const add = debounce(() => {
      alert(num.value++)
    }, 1000)
    //节流
    const add = throttle(() => {
    console.log('节流')
    }, 5000)  
    const UpGive = throttle(() => {
    message.info('已点赞')
    state.article_String.give++
    article.UpdatePortionAsync(state.article_String, 'Give')
    }, 1000)
```



# vue-router

## 基本使用

### 安装路由

```
npm install vue-router
```

### main.js

```js
import router from './router/index'
const app = createApp(App);
app.use(router)
```

### 建文件夹router

index.js

```js
import {
  createRouter,
  createWebHistory,
  createWebHashHistory
} from 'vue-router'
import BlogHome from '@/components/home/Home.vue'

const routes = [{
  path: '/',
  //重定向，当前路径'/'没有对应的组件，需要重定向到其他路由页面
  redirect: '/BlogHome',
  name: 'Home',
  component: BlogHome,
},
{
  path: '/BlogHome',
  name: 'BlogHome',
  component: () => import('@/components/home/Home.vue'),
  meta: {
    keepAlive: false
  },
},

{
  path: '/Admin-index',
  name: 'Admin-index',
  component: () => import('@/views/admin/index/index.vue'),
  children: [   // 添加子路由
    {
      path: 'ArticleTable',
      name: 'ArticleTable',
      component: () => import('@/views/admin/article/ArticleTable.vue'),
    },
    {
      path: 'Logins',
      name: 'Logins',
      component: () => import('@/views/admin/login/Login.vue')
    },
  ]
},
]
//createWebHashHistory createWebHistory
const router = createRouter({
  history: createWebHistory(), //HTML5模式
  routes,
})
export default router
```



##  路由跳转

### 导入使用

```tsx
 import {useRoute,useRouter} from 'vue-router'
   const route = useRoute()  // 参数的获取  this.$route
   const router= useRouter() // 方法使用  this.$router
           router.push({
              path: num,
              query: {
                t: +new Date()
              }
            })
```

### 无参跳转

```js
// 字符串
router.push('home')
// 对象
router.push({ path: 'home' })
```

### 带参数跳转

```js
this.$router.push({ path: '/Index-text', query: { id: cid } })
 await router.push({
          path: "/IndexText",
          query: {
            id: id,
          },
        });
```

###  路由调用

示例1

```js
data () {
    return {
      id: this.$route.query.id,
    }
url: '/api/Contents/AsyGetTestID?id=' + this.id
```

示例2

```tsx
import { useRoute } from 'vue-router'
 const route = useRoute()
 const state = reactive({
      id: route.query.id,
 })
```



###  点击刷新当前路由

```js
   this.$router.push({
     path: "./SnNavigation",
     query: {
       t: +new Date() //保证每次点击路由的query项都是不一样的，确保会重新刷新view
      }
    })
```

### 跳转新窗口

```ts
       const { href } = await router.resolve({
          path: "/IndexText",
          query: { id: id }
        });
        window.open(href, '_blank');
```

###  replace

 跟 `router.push` 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。（下面会具体说明）

| 声明式                            | 编程式                |
| :-------------------------------- | :-------------------- |
| `<router-link :to="..." replace>` | `router.replace(...)` |

### router.go(n)

这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。

```tsx
// 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)
// 后退一步记录，等同于 history.back()
router.go(-1)
// 前进 3 步记录
router.go(3)
// 如果 history 记录不够用，那就默默地失败呗
router.go(-100)
router.go(100)
```

### 比较说明

1.this.$router.push()：

   跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面。

2.this.$router.replace()

   同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。

3.this.$router.go(n)

   相对于当前页面向前或向后跳转多少个页面,类似 `window.history.go(n)`。n可为正数可为负数。正数返回上一个页面



## 路由嵌套

实现嵌套路由有两个要点：

- 在组件内部使用<router-view>标签
- `VueRouter 的参数中使用 `children 配置

### 父路由 index

引入子路由

```vue
<div>
<a-menu-item key="1" @click="Routers('/Admin-index/ArticleTable')">文章列表</a-menu-item>
<a-menu-item key="2" @click="Routers('/Admin-index/Logins')">option2</a-menu-item>
<router-view></router-view>
</div>
```

### 路由配置

```tsx
{
  path: '/Admin-index',
  name: 'Admin-index',
  component: () => import('@/views/admin/index/index.vue'),
  children: [   // 添加子路由
    {
      path: 'ArticleTable',
      name: 'ArticleTable',
      component: () => import('@/views/admin/article/ArticleTable.vue'),
    },
    {
      path: 'Logins',
      name: 'Logins',
      component: () => import('@/views/admin/login/Login.vue')
    },
  ]
},
```



# vuex

## vue3 中调用

```ts
 import { useStore } from "vuex";
      const stores = useStore();
      stores.state.SetPage
```

# axios

## 安装

```vue
npm install --save axios vue-axios
```

## main.js 导入

```js
import request from '@/network/request' //封装的js

new Vue({
  router,
  request, //注册axios
  render: h => h(App),
}).$mount('#app')
```

## 封装公共实例

建network 文件夹 下新建 request.js

```js
 import axios from 'axios'
 export function request(config) {
   // 1创建axios实例
   const intstance = axios.create({
     baseURL: 'https://localhost:44398/',
     timeout: 5000
     // contentType: 'application/json;charset=UTF-8',
     // dataType: 'json'
   })
   // 1.axios拦截器
   intstance.interceptors.request.use(config => {
     return config
   }, er => {
   })

   // 1.axios响应拦截拦截
   intstance.interceptors.response.use(res => {
     return res
   }, er => {
   })
   return intstance(config)
 }
 export default request
```

## 调用

在vue的页面导入

```js
import Headers from './Headers'
```

```js
methods: {
    AsyGetTest () {
      request({
        url: '/api/Contents/AsyGetTest'
      }).then(res => {
        // 只获取0到4之间的数据
        this.newinfo = res.data.slice(0, 4);
        console.log(this.newinfo)
      }).catch((e) => {
        console.log('获取数据失败');
      });
    }
  }
```

展示接口内容

```js
v-for="info in newinfo" :key="info.cid"
{{ info.title }}
```

## vue3封装

src\utils\http\axios.ts

```tsx
import axios from 'axios';
import qs from "qs";
import store from "@/store/index";
import router from '@/router/index';
import { dataList } from '@/components/aspin/data';
import { message } from 'ant-design-vue';
import { storage } from '../storage/storage';

//数据请求字符
axios.defaults.baseURL = process.env.VUE_APP_API_URL,
  // 如果请求话费了超过 `timeout` 的时间，请求将被中断
  axios.defaults.timeout = 5000;
// 表示跨域请求时是否需要使用凭证
axios.defaults.withCredentials = false;
// axios.defaults.headers.common['token'] =  AUTH_TOKEN
axios.defaults.headers.post['Content-Type'] = 'application/json;charset=UTF-8';
// 允许跨域
axios.defaults.headers.post["Access-Control-Allow-Origin-Type"] = "*";

// 请求拦截器
axios.interceptors.request.use(function (config) {
  if (
    config.method === "post" ||
    config.method === "put" ||
    config.method === "delete"
  ) {
    // qs序列化
    config.data = qs.parse(config.data);
  }
  // 若是有做鉴权token , 就给头部带上token
  if (storage.get(store.state.Roles)) {
    store.state.Roles
    config.headers.Authorization = storage.get(store.state.Roles);
  }
  return config;
}, error => {
  message.error(error.data.error.message);
  return Promise.reject(error.data.error.message);
})

// 响应拦截器
axios.interceptors.response.use(function (config) {
  dataList.show = true
  if (config.status === 200 || config.status === 204) {
    setTimeout(() => {
      dataList.show = false
    }, 400)
    return Promise.resolve(config);
  } else {
    return Promise.reject(config);
  }
},
  function (error) {

    if (error.response.status) {
      switch (error.response.status) {
        // 401: 未登录
        // 未登录则跳转登录页面，并携带当前页面的路径
        // 在登录成功后返回当前页面，这一步需要在登录页操作。                
        case 401: //重定向
          message.error("token:登录失效" + error.response.status + store.state.Roles)
          storage.remove(store.state.Roles)
          storage.get(store.state.Roles)
          console.log('%c [  storage.get("token") 401]', 'font-size:13px; background:pink; color:#bf2c9f;', storage.get('token'))
          router.replace({
            path: '/Login',
          });
          break;
        // 403 token过期
        // 登录过期对用户进行提示
        // 清除本地token和清空vuex中token对象
        // 跳转登录页面                
        case 403:
          message.error("token过期" + error.response.status)
          break;

        // 404请求不存在
        case 404:
          message.error("网络请求不存在" + error.response.status)
          break;
        // 其他错误，直接抛出错误提示
        default:
          message.error("错误" + error.response.status)
      }
      return Promise.reject(error.response);
    } else {
      // 处理断网的情况
      // eg:请求超时或断网时，更新state的network状态
      // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏
      // 关于断网组件中的刷新重新获取数据，会在断网组件中说明
      store.commit('changeNetwork', false);
    }
  }
)
export default axios
```

## vue3 调用

```tsx
import request from '@/utils/http/axios'
export class article {

  /**
   * @description: 查询总条数
   */
  static async GetCountAsync(): Promise<any> {
    return await request({
      url: "/api/SnArticle/GetCountAsync",
      method: 'get',
    })
  }

  /**
   * @description: 更新
   * @param {any} resultData
   * @param {string} type
   */
  static async UpdatePortionAsync(resultData: any, type: string): Promise<any> {
    return await
      request({
        // 更新
        url: "/api/SnArticle/UpdatePortionAsync?type=" + type,
        method: "put",
        data: resultData,
      })
  }
}
```

#### axios 并发请求

并发

处理并发请求的助手函数

 axios.all(iterable)

 axios.spread(callback)

```js
//示例:
import { article } from '@/api/index';
import { blogsList } from "./components/data";
import axios from '@/utils/http/axios'
class methods {
  static async GetFySortTitle() {
    await article.GetFySortTitleAsync(blogsList.page, blogsList.pagesize, true).then((res: any) => {
      blogsList.dataResult = res.data;
    });
  }
  static async ConutSort() {
    await article.ConutSort(7).then((result: any) => {
      blogsList.count = result.data;
    });
  }
}
async function QueryAll() {
  // axios.all([await methods.ConutSort(), await methods.GetFySortTitle()]).then(axios.spread((Fy, co: any) => {
  //   blogsList.count = co.data;
  //   blogsList.dataResult = Fy.data;
  // }))
  axios.all([await methods.ConutSort(), await methods.GetFySortTitle()])
}

export {
  methods,
  QueryAll
}
```



# VUE 插件

## mavon-editor



### 安装引用

```
$ npm install mavon-editor --save
```

```js
// 全局注册
    // import with ES6
    import Vue from 'vue'
    import mavonEditor from 'mavon-editor'
    import 'mavon-editor/dist/css/index.css'
    // use
    Vue.use(mavonEditor)
    new Vue({
        'el': '#main',
        data() {
            return { value: '' }
        }
    })
```

### 调用

```vue
<div id="main">
    <mavon-editor v-model="value"/>
</div>
```

### 获取数据预览

```vue
<template>
  <div class="editor-text">
    <mavon-editor
      v-model="newinfo.text"
      :subfield="false"
      :boxShadow="false"
      defaultOpen="preview"
      :toolbarsFlag="false"
    />
  </div>
</template>
```

### highlight 高亮

1.安装

```js
npm i highlight.js
```

2.组件页面 引入

```js
import 'highlight.js/styles/googlecode.css'
import hljs from 'highlight.js' //导入代码高亮文件
```

3.methods 建方法

```js
async highlighthandle(){
                await hljs;
                let highlight = document.querySelectorAll('code,pre');
                highlight.forEach((block)=>{
                    hljs.highlightBlock(block);
                })
            },
```

4.钩子

```js
 updated() {
            this.highlighthandle()
        },
```

5.编译器调用

```vue
<mavon-editor
                    :toolbars="markdownOption"
                    :subfield="false"
                    :boxShadow="false"
                    :ishljs="true"
                    defaultOpen="preview"
                    :toolbarsFlag="false"
                    :navigation="true"
                    v-model="newinfo.text"
            />
```





## 字体图标

一.首先下载好的iconfont.js放到assets/icon

二.引入css 文件
        在同级目录下创建一个icon.css文件

```css
.icon {
    width: 1em;
    height: 1em;
    vertical-align: -0.15em;
    fill: currentColor;
    overflow: hidden;
}
```

main.js导入

```js
import './assets/icon/fonts/iconfont.js'

import './assets/icon/icon.css'
```

引用

```vue
 <svg class="icon" aria-hidden="true">
   <use xlink:href="#icon-bingqilinqiu"></use>
  </svg>
```



## 时间线组件

安装

```
yarn add vue-light-timeline
npm i vue-light-timeline
```

导入

```js
import Vue from 'vue';
import LightTimeline from 'vue-light-timeline';

Vue.use(LightTimeline);
```

调用

```vue
<template>
  <light-timeline :items='items'></light-timeline>
</template>
<script>
const theme = 'red';
export default {
  data () {
    return {
      items: [
        {
          tag: '2018-01-12',
          content: 'hallo'
        },
        {
          tag: '2018-01-13',
          color: '#dcdcdc',
          type: 'circle',
          content: 'world'
        },
        {
          type: 'star',
          tag: '2018-01-14',
          htmlMode: true,
          content: `<div style="color: ${theme};"> =v = </div>`
        }
      ]
    }
  }
}
</script>
```

## 背景粒子组件

### 如何使用

```
npm install vue-particles --save-dev
```

### Main.js文件

```
import Vue from 'vue'
import VueParticles from 'vue-particles'
Vue.use(VueParticles)
```

### 简单示例

```html
<template>
    <div id="app">
      <vue-particles color="#dedede"></vue-particles>
    </div>
 </template>
```

### 完整示例

```html
<template>
    <div id="app">
         <vue-particles class="bgys"
                       color="#dedede" 颗粒颜色
                       :particleOpacity="0.7" 粒子不透明度
                       :particlesNumber="60" 颗粒数量
                       shapeType="circle" 可用的形状类
                       :particleSize="4" 单颗粒大小
                       linesColor="#dedede" 线条颜色
                       :linesWidth="1" 线宽
                       :lineLinked="true"  启用线
                       :lineOpacity="0.4" 线不透明度
                       :linesDistance="150 行距
                       :moveSpeed="3"   粒子速度
                       :hoverEffect="true"  启用悬停效果
                       hoverMode="grab"  可用的悬停模式：“抓取”，“排斥”，“气泡”
                       :clickEffect="true"  启用点击效果
                       clickMode="push"  可用的点击模式：“推”，“删除”，“排斥”，“气泡”
        >
        </vue-particles>
    </div>
 </template>

bgys{
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
        }
```



## vue-aplayeryer



### 安装

```css
yarn add @moefe/vue-aplayer
```



### 使用

```vue
     <aplayer :audio="audio" :lrcType="3" fixed />
```



### main

```js
import APlayer from '@moefe/vue-aplayer';
Vue.use(APlayer, {
  defaultCover: 'https://github.com/u3u.png',
  productionTip: true,
});
```

### js

```js
  export default {
        name: "Vueaplayer",
        components: {
        },
        data() {
            return {
                audio: [{
                    name: '东西（Cover：林俊呈）',
                    artist: '纳豆',
                    url: 'http://localhost:8081/mp3/0003.mp3',
                    cover: 'https://p1.music.126.net/5zs7IvmLv7KahY3BFzUmrg==/109951163635241613.jpg?param=300y300', // prettier-ignore
                    lrc: 'https://cdn.moefe.org/music/lrc/thing.lrc',
                },
                    {
                        name: "0001",
                        artist: "0001",
                        url: 'http://localhost:8081/mp3/0001.mp3',
                        cover: "",
                        lrc: "[00:00.00]lrc here\n[00:01.00]aplayer"
                    }
                ]
            }
        },        
    }
```



## [v-md-editor](https://ckang1229.gitee.io/vue-markdown-editor/zh/)



### 安装支持 vue3 的版本

```bash
# 使用 npm
npm i @kangc/v-md-editor@next -S

# 使用 yarn
yarn add @kangc/v-md-editor@next
```

### 在 vue3 中注册

```tsx
// v-md
import VueMarkdownEditor from '@kangc/v-md-editor';
import '@kangc/v-md-editor/lib/style/base-editor.css';
// vuepress github 主题
// import vuepressTheme from '@kangc/v-md-editor/lib/theme/vuepress.js';
// import '@kangc/v-md-editor/lib/theme/style/vuepress.css';
import githubTheme from '@kangc/v-md-editor/lib/theme/github.js';
import '@kangc/v-md-editor/lib/theme/style/github.css';

// import Prism from 'prismjs';
import hljs from 'highlight.js';

VueMarkdownEditor.use(githubTheme, {
  // Prism,
  Hljs: hljs,
  // extend(md) {
  //   // md为 markdown-it 实例，可以在此处进行修改配置,并使用 plugin 进行语法扩展
  //   // md.set(option).use(plugin);
  // },
});
//  end v-md
```

### 使用

```vue
      <v-md-editor
        v-model="state.blog"
        left-toolbar=""
        right-toolbar="toc"
        :include-level="[2, 3]"
        mode="preview"
      />
```

### 渲染html文本

```tsx
// main.js
import VMdPreviewHtml from '@kangc/v-md-editor/lib/preview-html';
import '@kangc/v-md-editor/lib/style/preview-html.css';

// 引入使用主题的样式
import '@kangc/v-md-editor/lib/theme/style/vuepress';

Vue.use(VMdPreviewHtml);


<template>
  <!-- preview-class 为主题的样式类名，例如vuepress就是vuepress-markdown-body -->
  <v-md-preview-html :html="html" preview-class="vuepress-markdown-body"></v-md-preview-html>
</template>

<script>
export default {
  data() {
    return {
      html: '<div data-v-md-line="1"><h1 align="center">Markdown Editor built on Vue</h1>',
    };
  },
};
</script>
```

### 渲染 markdown



```tsx
// main.js
import VMdPreview from '@kangc/v-md-editor/lib/preview';
import '@kangc/v-md-editor/lib/style/preview.css';
// 引入你所使用的主题 此处以 github 主题为例
import githubTheme from '@kangc/v-md-editor/lib/theme/github';
import '@kangc/v-md-editor/lib/theme/style/github.css';

// highlightjs
import hljs from 'highlight.js';

VMdPreview.use(githubTheme, {
  Hljs: hljs,
});
Vue.use(VMdPreview);
```

vue

```vue
<template>
  <v-md-preview :text="markdown"></v-md-preview>
</template>

<script>
export default {
  data() {
    return {
      markdown: '### 标题',
    };
  },
};
</script>
```





# SCSS



## 封装调用

```js
 //vue
<style lang="scss" >
  @import "./scss/indexTitle.scss";
</style>

 //indexTitle.scss
@import "../../assets/sass/com";
@import "../../assets/sass/uitl";
.IndexTitle {
  @include initialize($w, null, $Text_height, null, $ml, null, null);
}
```



## Scss语法

### 声明变量

变量用来存储需要在CSS中复用的信息，如颜色和字体,通过$符号去声明一个变量。

```scss
$name
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 `!global` 声明：

```scss
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```



### 插值语句 `#{}`

通过 `#{}` 插值语句可以在选择器或属性名中使用变量：

```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```

编译为

```css
p.foo {
  border-color: blue; }
```

### 嵌套

```css
.container{
  .left-area{
    ...
  }
}
```

### 父选择器(&)

`&` 在 scss中表示自身的意思。

```css
.container{
  &.right-area{
   background-color : #0000
 }
}
```

###  Mixin(混合)

用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。

```css
@mixin button {  
    font-size: 1em;  
    padding: 0.5em 1.0em;  
    text-decoration: none;  
    color: #fff;  
}
.button-green {  
    @include button;  
    background-color: green;  
}

@mixin border-radius($radius) {
          border-radius: $radius;
      -ms-border-radius: $radius;
     -moz-border-radius: $radius;
  -webkit-border-radius: $radius;
}

.box {
  @include border-radius(10px);
}
```

### 继承

继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码

```scss
// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。
%message-common {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

.message {
  @extend %message-common;
}

.success {
  @extend %message-common;
  border-color: green;
}

```

### 函数指令

Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用：

```scss
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar { width: grid-width(5); }
```

编译为

```css
#sidebar {
  width: 240px; }
```

与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 `@return` 输出结果。

自定义的函数也可以使用关键词参数，上面的例子还可以这样写：

```scss
#sidebar { width: grid-width($n: 5); }
```

建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。

### 技巧

#### 居中

使用 Flexbox 实现子元素的居中效果，只需三行代码：

```scss
@mixin center-children {
    display: flex;
    justify-content: center;
    align-items: center;
}
```

由于 Flexbox 还是比较新的属性，那么添加上相关的浏览器前缀的话，会让它拥有更广泛的兼容性。

```scss
.parent {
    @include center-children;
}
```

## 常用封装

### 背景3d边框

```css
/**
 * @description: 背景3d边框
 */
@mixin boxshow {
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  overflow: hidden;
  border-radius: 3px;
  -webkit-box-shadow: $boxshow1, $boxshow2, $boxshow3;
  box-shadow: $boxshow1, $boxshow2, $boxshow3;
}
$boxshow11: 0 1px 1px -2px rgba(0, 0, 0, .2);
$boxshow22: 0 1px 2px 0 rgba(0, 0, 0, .14);
$boxshow33: 0 1px 3px 0 rgba(0, 0, 0, .12);
```



#  Tailwind CSS

官网链接 https://www.tailwindcss.com





# 移动端适配

### 1.index.html

```html
 <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0,
    user-scalable=no">
```

### 2.main.js

```js
// rem 适配
var falses = true;
//----------------------------------
const setHtmlFontSize = () => {
  const htmlDom = document.getElementsByTagName('html')[0];
  let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;
  if (htmlWidth > 413 && htmlWidth<735) {
    htmlWidth = 414;
    console.log( htmlWidth);
    htmlDom.style.fontSize = `${htmlWidth / 16}px`;
  }
  //小米8适配
  if (htmlWidth == 393 ) {
    htmlWidth = 393;
    console.log( htmlWidth);
    htmlDom.style.fontSize = `${htmlWidth / 16}px`;
  }

  if (htmlWidth <= 375) {
    htmlWidth = 375;
    htmlDom.style.fontSize = `${htmlWidth / 16}px`;
  }
  if (htmlWidth > 1000) {
    falses =false
  }
};
if (falses){
window.onresize = setHtmlFontSize;
setHtmlFontSize();

}
```

### 3. 查看当期机型屏幕尺寸

```js
            const screenWidth = document.body.clientWidth
            const screenHeight = document.body.clientHeight
            alert(`当前设备的屏幕尺寸（宽 x 高）：${screenWidth} x ${screenHeight}`)
```



### 4.手机查看vue项目

vue.config.js

```js
 devServer: {
        host: '111.11.11.11', // ip
        port: 8081, // 设置端口号
        https: false, // https:{type:Boolean}
        open: false, //配置自动启动浏览器
        proxy: null  //设置代理
    },
```



# uni App



## 下拉刷新

### pages.json开启刷新

enablePullDownRefresh

```js
    "pages": [{
        "path": "pages/index/index",
        "style": {
            "navigationBarTitleText": "首页",
			"enablePullDownRefresh":true
        }
    }],
```

### 使用下拉刷新

```js
//下拉刷新
		onPullDownRefresh() {
			setTimeout(()=>{
					// 刷新关闭
				uni.stopPullDownRefresh()
				alert("刷新成功")
			},2000)
```



### 页面触底事件

```js
	// 页面触底事件
		onReachBottom() {
			setTimeout(()=>{
				alert("刷新成功")
			},2000)
		},
```



## 请求封装

### 创建一个http.js

```js
const baseUrl = 'http://11111/';
const httpRequest = (opts, data) => {
	let httpDefaultOpts = {
		url: baseUrl + opts.url,
		data: data,
		method: opts.method,
		header: opts.method == 'get' ? {
			'X-Requested-With': 'XMLHttpRequest',
			"Accept": "application/json",
			"Content-Type": "application/json; charset=UTF-8"
		} : {
			'X-Requested-With': 'XMLHttpRequest',
			'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
		},
		dataType: 'json',
	}
	let promise = new Promise(function(resolve, reject) {
		uni.request(httpDefaultOpts).then(
			(res) => {
				resolve(res[1])
			}
		).catch(
			(response) => {
				reject(response)
			}
		)
	})
	return promise
};
//带Token请求
const httpTokenRequest = (opts, data) => {
	let token = "";
	uni.getStorage({
		key: 'token',
		success: function(ress) {
			token = ress.data
		}
	});
	//此token是登录成功后后台返回保存在storage中的
	let httpDefaultOpts = {
		url: baseUrl + opts.url,
		data: data,
		method: opts.method,
		header: opts.method == 'get' ? {
			'Token': token,
			'X-Requested-With': 'XMLHttpRequest',
			"Accept": "application/json",
			"Content-Type": "application/json; charset=UTF-8"
		} : {
			'Token': token,
			'X-Requested-With': 'XMLHttpRequest',
			'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
		},
		dataType: 'json',
	}
	let promise = new Promise(function(resolve, reject) {
		uni.request(httpDefaultOpts).then(
			(res) => {
				resolve(res[1])
			}
		).catch(
			(response) => {
				reject(response)
			}
		)
	})
	return promise
};

export default {
	baseUrl,
	httpRequest,
	httpTokenRequest
}

```

### 将http.js引入

​	

```js
import http from '@/commons/http.js';
```

```js
let opts = {
					url: 'api/SnArticle/GetTest',
					method: 'get'
				};
				let param = {
					deviceId: this.deviceCode,
					deviceName: this.deviceName
				};
				http.httpTokenRequest(opts, param).then(res => {
					
					this.newinfo= res.data;
         // console.log(newinfo);
				}, error => {
					console.log(error);
				})
```







# 后端应用



## C# 编码规范

####  **模块头部注释规范**

以一个物理文件为单元的都需要有模块头部注释规范，例如：C#中的.cs文件

用于每个模块开头的说明，主要包括：（**粗体字**为必需部分，其余为可选部分）

1. **文件名称**(File Name)： 此文件的名称
2. **功能描述**(Description)：  此模块的功能描述与大概流程说明
3. **数据表**(Tables)：       所用到的数据表，视图，存储过程的说明，如关系比较复杂，则应说明哪些是可擦写的，哪些表为只读的。
4. **作者**(Author)：
5. **日期**(Create Date)：
6. 参考文档(Reference)(可选)：     该档所对应的分析文档，设计文檔。
7. 引用(Using) (可选)﹕      开发的系统中引用其它系统的Dll、对象时，要列出其对应的出处，是否与系统有关﹙不清楚的可以不写﹚，以方便制作安装档。
8. **修改记录**(Revision History)：若档案的所有者改变，则需要有修改人员的名字、修改日期及修改理由。
9. **分割符：***************************** (前后都要)

#### 方法注释规范

具体应用当中，类、接口、属性、方法必须有<Summary>节，另外方法如果有参数及返回值，则必须有<Param>及<Returns>节。示例如下：

```xml
　　　　/// <summary>
　　　　/// …
　　　　/// </summary>
　　　　/// <param name=””></param>
　　　　/// <returns></returns>
```

#### 命名的基本约定

下表描述了不同类型标识符的大小写规则：

| **标识符** | **大小写** | **示例**                                 |
| ---------- | ---------- | ---------------------------------------- |
| 命名空间   | Pascal     | namespace Com.Techstar.ProductionCenter  |
| 类型       | Pascal     | public class DevsList                    |
| 接口       | Pascal     | public interface ITableModel             |
| 方法       | Pascal     | public void UpdateData()                 |
| 属性       | Pascal     | Public int Length{…}                     |
| 事件       | Pascal     | public event EventHandler Changed;       |
| 私有字段   | Camel      | private string fieldName;                |
| 非私有字段 | Pascal     | public string FieldName；                |
| 枚举值     | Pascal     | FileMode{Append}                         |
| 参数       | Camel      | public void UpdateData(string fieldName) |
| 局部变量   | Camel      | string fieldName;                        |

#### 命名规范

- Pascal法：首字母大写，连接词的首字母也都大写
  →GetInfo
- Camel：第一个单词的首字母小写
  →getInfo
- MENTIONS:

1. 成员变量最好加一个“_”
2. 接口的名称前加前缀“*I*”



#### 代码编写规则

- 尽量使用接口
- 局部变量尽量在最接近的地方使用
- 不要使用goto系列语句（除非是在跳出深层循环时）
- 构建和构建一个长的字符串时，一定要使用**StringBuilder**类型
- switch语句要有**default**来处理意外情况



### 语法糖

####  集合类的声明

之前我们声明一个List并给list赋初始值，必须得这么写：

```c#
List<string> list = new List<string>();
list.Add("a一");
list.Add("b二");
```

现在不需要了，直接写就可以了

```c#
List<string> list = new List<string> {
            "def","OK"
};
```

#### **集合类各个项的操作**

我们为了逐个处理集合中的项，需要这么写：

```c#
foreach (string item in list)
{
Console.WriteLine(item);
}
```

现在不需要了，这样就可以了

```c#
list.ForEach(a => Console.WriteLine(a));
```

#### **using == try finally**

为了在使用完毕时释放资源，我们经常要用using，using实质上就是try fiannaly的一个语法糖而已。例如

```c#
StreamWriter sw = null;
try
{
    sw = new StreamWriter("d:\abc.txt");
    sw.WriteLine("test");
}
finally {
    if(sw!= null) sw.Dispose();
}
```

简化为：

```c#
using (var sw = new StreamWriter("d:\abc.txt")) {
    sw.WriteLine("test");
}
```

#### **问号的演变**

表示左边的变量如果为null则值为右边的变量，否则就是左边的变量值

```c#
string a = null;
var b = a??””;
```

#### **类型实例化的语法糖**

```c#
public class Abc
{
    public int ID { get; set; }
    public string Name { get; set; }
    public string Url { get; set; }
}

public static void Main(string[] args) {
        var abc = new Abc{
            ID=1,
            Name="yukaizhao",
            Url="http://yukaizhao.cnblogs.com/"
        };
    }
```

#### 匿名类

匿名类在linq to sql或者entity framework中返回查询数据时很好用。

```c#
var a = new {
    ID = 1,
    Name=”yukaizhao”,
    BlogUrl=”http://www.cnblogs.com/yukaizhao/”
};
```

#### **NULL条件运算符**

```c#
使用代码
Customer customer = new Customer();
string name = customer?.Name;
编译代码
Customer customer = new Customer();
if (customer != null)
{
    string name = customer.Name;
}
和??组合起来使用
if (customer?.Face()??false)
还可以两个一起组合来使用
int? contactNameLen = contact?.Name?.Length; 
```

这个语法糖的目的是在对象使用前检查是否为null。如果对象为空，则赋值给变量为空值，所以例子中需要一个可以为空的int类型、即int?。如果对象不为空，则调用对象的成员取值，并赋值给变量。

#### **字符串格式化**

String.Format有些不方便的地方是：必须输入String.Format，使用{0}占位符、必须顺序来格式化、这点容易出错。

```c#
    var contactInfo = string.Format("Id:{0} Name:{1} EmailAddr:{2} PhoneNum:{3}", 
    contact.Id, contact.Name, contact.EmailAddress, contact.PhoneNum);
    
    新的语法
    var contactInfo2 = $"Id:{contact.Id} Name:{contact.Name} EmailAddr:
    {contact.EmailAddress} PhoneNum:{contact.PhoneNum}";
        
    新格式化方式还支持任何表达式的直接赋值：
    var contactInfo = $"Id:{contact.Id} Name:{(contact.Name.Length == 0 ? "Frank" : 
    contact.Name)} EmailAddr:{contact.EmailAddress} PhoneNum:{contact.PhoneNum}";
    
```



## efcore



### 连接Mysql DBFirst模式

一：**创建EF的类库，同时将此项目设置为启动项(为Scaffold-DbContext -tables指令使用)，同时安装2个包**  

​      ①Microsoft.EntityFrameworkCore.Tools

​      ②Pomelo.EntityFrameworkCore.MySql (这个是第三方的ef mysql 中间件)

 **Scaffold-DBcontext命令**

```c#
Scaffold-DbContext "server=localhost;userid=root;pwd=woshishui;port=3306;database=snblog;sslmode=none;" Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Force
```

​     server：数据库地址，User Id：账号，Password：登录密码

​      如果是针对单表的更新,加一个-Tables 后面是要更新的表名

```c#
Scaffold-DbContext "server=localhost;userid=root;pwd=woshishui;port=3306;database=snblog;sslmode=none;" Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Tables "sn_interface" -Force
```

 执行完成之后会生成指定的是Model ，注意：表必须有主键，才会生成，如果没有主机会报 Unable to generate entity type for table “xxxx” 警告，当然实体也不会生成

**Scaffold-DbContext命令参数说明:**

-OutputDir (-o) ：实体文件所存放的文件目录

-ContextDir ： DbContext文件存放的目录

-Context ： DbContext文件名

-Schemas ： 需要生成实体数据的数据表所在的模式

-Tables(-t) ： 需要生成实体数据的数据表的集合

-Force (-f)强制执行，重写已经存在的实体文件



### 查询数据

**IQueryable**

就是C#中Linq To SQL语句的返回类型，简单来说IQueryable就是可以叠加处理SQL语句，最后统一访问数据库，这个处理过程就叫`延迟执行`，这一步只是生成了SQL语句，并没有真正执行数据库查询

执行数据库查询

```c#
` ToList()`、`First()`、`FirstOrDefault()`
`Single()`、`SingleOrDefault()`、`Last()`、`LastOrDefault()`//Single只能是一个数据
`Count()`、`LongCount()`、`Min()`、`Max()`、`Average()`、`Sum()`
`Find()`、 `foreach()
```

First返回符合添加的第一条数据；First与FirstOrDefault的区别，First必须有数据，否则会报错，FirstOrDefault可有可无

First()与FirstOrDefault()可以在方法参数里直接写Where查询条件

```C#
_dbContext.Leagues.FirstOrDefault(w => w.Country == "中国");
```





#### **无用追踪**

- 无须追踪的数据没有加AsNoTracking

#### 跟踪与非跟踪查询

跟踪行为决定了 Entity Framework Core 是否将有关实体实例的信息保留在其更改跟踪器中。 如果已跟踪某个实体，则该实体中检测到的任何更改都会在 SaveChanges() 期间永久保存到数据库。 EF Core 还将修复跟踪查询结果中的实体与更改跟踪器中的实体之间的导航属性。

从不跟踪无键实体类型。 无论在何处提到实体类型，它都是指定义了键的实体类型。

#### 跟踪查询

返回实体类型的查询是默认会被跟踪的。 这表示可以更改这些实体实例，然后通过 SaveChanges() 持久化这些更改。 在以下示例中，将检测到对博客评分所做的更改，并在 SaveChanges() 期间将这些更改持久化到数据库中。

```c#
var blog = context.Blogs.SingleOrDefault(b => b.BlogId == 1);
blog.Rating = 5;
context.SaveChanges();
```



#### 非跟踪查询

AsNoTracking 称之为获取不带变动跟踪的实体查询

在一些情况下，我们只需要查询返回一个只读的数据记录，而不会对数据记录进行任何的修改。

在只读方案中使用结果时，非跟踪查询十分有用。 可以更快速地执行非跟踪查询，因为无需设置更改跟踪信息。 如果不需要更新从数据库中检索到的实体，则应使用非跟踪查询。 可以将单个查询替换为非跟踪查询。

AsNoTracking方法查询返回无变动跟踪的DbSet，由于是无变动跟踪，所以对返回的实体集中数据的任何修改，在SaveChanges()时，都不会提交到数据库中。

```c#
var blogs = context.Blogs
   .AsNoTracking()
   .ToList();
```

还可以在上下文实例级别更改默认跟踪行为：

```c#
context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
var blogs = context.Blogs.ToList();
```





#### 查询单个数据

```c#
//第一种
result = await _service.SnArticle.FindAsync(id);
//第一种
var leagues = _service.SnArticle.SingleOrDefault(l => l.Id == _id);
```



#### 模糊查询

```c#
 s => s.XianWID.StartsWith(str)
 匹配以str开头的
 s => s.XianWID.EndsWith(str)
 匹配以str结尾的
 s => s.XianWID.Contains(str)
 匹配包含str的
            //第一种
           result_List = await _service.SnArticle
           .Where(l => l.Title.Contains(name))//查询条件
           .ToListAsync();

           //第二种
           var league_ef = _dbContext.Leagues
            .Where(l => EF.Functions.Like(l.Country, "中%"))
            .ToList();
```

#### 预加载（Eager Loading）

```c#
[HttpGet("Eager")]
public IActionResult GetEager()
{
    var clubs = _dbContext.Clubs
        .Where(c => c.Name.Contains("足球队"))//过滤条件
        .Include(c => c.League)//关联数据
        .ToList();
    return Ok(clubs);
}
```



### 添加数据

```c#
        public async Task<bool> AddAsync(SnArticle entity)
        {
            _logger.LogInformation("添加数据_SnArticle" + entity);
            await _service.SnArticle.AddAsync(entity);
            return await _service.SaveChangesAsync() > 0;
        }
```



### 更新数据

更新指定列

1.第一种方式

```c#
  public async Task<bool> UpdatePortionAsync(SnArticle snArticle, string type)
        {
            _logger.LogInformation("更新部分参数");
            var date = _service.SnArticle.Update(snArticle);
            //默认不更新
            date.Property("UserId").IsModified = false;
            date.Property("Title").IsModified = false;
            date.Property("TitleText").IsModified = false;
            date.Property("Text").IsModified = false;
            date.Property("Time").IsModified = false;
            date.Property("LabelId").IsModified = false;
            date.Property("Read").IsModified = false;
            date.Property("Give").IsModified = false;
            date.Property("Comment").IsModified = false;
            date.Property("SortId").IsModified = false;
            date.Property("TypeTitle").IsModified = false;
            date.Property("UrlImg").IsModified = false;
            switch (type)
            {    //指定字段进行更新操作
                case "Read":
                    date.Property(type).IsModified = true;
                    break;
                case "Give":
                     date.Property(type).IsModified = true;
                    break;
                case "Comment":
                     date.Property(type).IsModified = true;
                    break;
            }
            return await _service.SaveChangesAsync() > 0;
        }
```

2.第二种方式

```c#
        public async Task<bool> UpdatePortionAsync(SnArticle snArticle, string type)
        {
            _logger.LogInformation("更新部分参数");
            var resulet = await _service.SnArticle.FindAsync(snArticle.ArticleId);
            if (resulet == null) return false;
            switch (type)
            {    //指定字段进行更新操作
                case "Read":
                    //修改属性，被追踪的Read状态属性就会变为Modify
                    resulet.Read = snArticle.Read;
                    break;
                case "Give":
                    resulet.Give = snArticle.Give;
                    break;
                case "Comment":
                    resulet.Comment = snArticle.Comment;
                    break;
            }
            //执行数据库操作
            return await _service.SaveChangesAsync() > 0;
        }
```

### 删除数据

第一种

```c#
        public async Task<bool> DeleteAsync(int id)
        {
            _logger.LogInformation("删除数据_SnArticle" + id);
            var todoItem = await _service.SnArticle.FindAsync(id);
            if (todoItem == null) return false;
            _service.SnArticle.Remove(todoItem);
            return await _service.SaveChangesAsync() > 0;
        }
```

第二种

```c#
        public async Task<bool> DeleteAsync(int id)
        {
            _logger.LogInformation("删除数据_SnArticle" + id);
            //先查询出来，因为只能删除被追踪的数据
            var todoItem = await  _service.SnArticle.FindAsync(id);
            if (todoItem == null) return false;
            //1、单独删除方法
            _service.SnArticle.Remove(todoItem);//删除单个todoItem
            _service.Remove(todoItem);//直接在context上Remove()方法传入model，它会判断类型
            return await _service.SaveChangesAsync() > 0;
        }

-----------------------------------------------------------------------------------------
    //批量删除方法
    var league2 = _dbContext.Leagues.SingleOrDefault(l => l.Country == "中国");
    _dbContext.Leagues.RemoveRange(league, league2);
    _dbContext.RemoveRange(league, league2);
```



##  netCoreApi

### api函数命名

```c#
        /// 查询总数 
        [HttpGet("GetCountAsync")]
        public async Task<IActionResult> GetCountAsync(bool cache)
            
        /// 条件查询总数
        [HttpGet("GetTypeCountAsync")]
        public IActionResult GetTypeCountAsync(int type, bool cache)
            
        
```



### 常用的 HTTP 状态码

| HTTP 状态码 | 涵义                  | 解释说明                                                     |
| ----------- | --------------------- | ------------------------------------------------------------ |
| 200         | OK                    | 用于一般性的成功返回，不可用于请求错误返回                   |
| 201         | Created               | 资源被创建                                                   |
| 202         | Accepted              | 用于资源异步处理的返回，仅表示请求已经收到。对于耗时比较久的处理，一般用异步处理来完成 |
| 204         | No Content            | 此状态可能会出现在 PUT、POST、DELETE 的请求中，一般表示资源存在，但消息体中不会返回任何资源相关的状态或信息 |
| 400         | Bad Request           | 用于客户端一般性错误信息返回, 在其它 4xx 错误以外的错误，也可以使用，错误信息一般置于 body 中 |
| 401         | Unauthorized          | 接口需要授权访问，为通过授权验证                             |
| 403         | Forbidden             | 当前的资源被禁止访问                                         |
| 404         | Not Found             | 找不到对应的信息                                             |
| 500         | Internal Server Error | 服务器内部错误                                               |

### ObjectResult 的方法来表明接口返回的状态码

web API会用到的状态码：

**200级别，表示成功：**

- **200 - OK**
- **201 - Created，表示资源创建成功了**
- **204 - No content，成功执行，但是不应该返回任何东西**

**400级别，表示客户端引起的错误：**

- **400 - Bad request，表示API的消费者发送到服务器的请求是错误的**
- **401 - Unauthorized，表示没有权限**
- **403 - Forbidden，表示用户验证成功，但是该用户仍然无法访问该资源**
- **404 - Not found，表示请求的资源不存在**
- **405 - Method not allowed，这就是当我们尝试发送请求给某个资源时，使用的HTTP方法却是不允许的，例如使用POST api/countries, 而该资源只实现了 GET，所以POST不被允许**
- **406 - Not acceptable，这里涉及到了media type，例如API消费者请求的是application/xml格式的media type，而API只支持application/json**
- **409 - Conflict，表示该请求无法完成，因为请求与当前资源的状态有冲突，例如你编辑某个资源数据以后，该资源又被其它人更新了，这时你再PUT你的数据就会出现409错误；有时也用在尝试创建资源时该资源已存在的情况。**
- **415 - Unsupported media type，这个和406正好返回来，比如说我向服务器提交数据的media type是xml的，而服务器只支持json，那么就会返回415**
- **422 - Unprocessable entity，表示请求的格式没问题，但是语义有错误，例如实体验证错误。**

**500级别，服务器错误：**

- **500 - Internal server error，这表示是服务器发生了错误**

### 接口命名规范

和 C# 命名规范一样，好的、统一的接口命名规范，不仅可以增强其可读性，而且还会减少很多不必要的口头/书面上的解释。可使用"驼峰命名法"按照实现接口的**业务类型、业务场景**等命名



#### 常见命名方式

- `接口名称动词前/后缀化`： 接口名称以接口数据操作的动词为前/后缀，常见动词有：`Add、Delete、Update、Query、Get、Send、Save、Detail、List`等，如：新建用户 `AddUser`、查询订单详情 `QueryOrderDetail`。

- 接口名称动词 + 请求方式

  接口路径中包含具体接口名称的名词，接口数据操作动作以 HTTP 请求方式来区分。常用的 HTTP 请求方式有：

  - `GET`：从服务器取出资源（一项或多项）
  - `POST`：在服务器新建一个资源
  - `PUT`：在服务器更新资源（客户端提供改变后的完整资源）
  - `PATCH`：在服务器更新资源（客户端提供改变的属性）
  - `DELETE`：从服务器删除资源

### 请求参数规范

- 请求方式

  ```
  GET、POST、PUT
  ```

  等含义定义，避免出现不一致现象，对人造成误解、歧义

  - `请求头`：请求头根据项目需求添加配置参数。如：请求数据格式，`accept=application/json` 等。如有需要，请求头可根据项目需求要求传入用户 token、唯一验签码等加密数据
  - `请求参数/请求体`： 请求参数字段，尽可能与数据库表字段、对象属性名等保持一致，因为保持一致是最省事，最舒服的一件事

###  返回数据规范

此处以 json 格式为例。返回数据应包含：**返回状态码、返回状态信息、具体数据**。**返回数据中的状态码、状态信息，常指具体的业务状态，不建议和 HTTP 状态码混在一起**。HTTP 状态，是用来体现 HTTP 链路状态情况，如：404-Not Found。HTTP 状态码和 json 结果中的状态码，并存尚可，用于体现不同维度的状态。



# mysql

## 数据表设计规则总结

数据库设计是有几大范式的，但是他们都比较高深莫测，实际开发中我们遵循下面的规则即可：

每张表只存储一类数据，比如用户表就存储用户信息；（做关联用的列不算，比如上面例子中人的表中还存储了房子的地址，但是地址是做关联用的）

设计表之前首先要划分清楚各模块是什么，比如用户模块、车、房子，然后理清楚各模块间的关系，两张表之间如果存在关联关系，则该关系可以分为三种：一对一，一对多，多对多。

分别先独立的设计各个表的结构，这样设计完后是一张张相互独立没有关联的表
然后按照两表之间的关系来进行完善即可。

那么两表之间的关系如何完善呢？

A和B之间是1对1关系，则将一张表的唯一字段（唯一能够确定一行数据的）放入另外一张表中：比如用户表和手机表是1对1的关系，那么我们可以将用户身份证号放入手机表中，作为手机表的列名（字段）之一。
A和B之间是1对多 关系，则将“一”这一端的唯一字段放入“多“的一端中：比如用户表和衣服表，一个用户有多件衣服，一件衣服只属于一个用户，那么就将身份证号放入衣服表中即可
A和B之间是 多对多 关系，则建立一张中间表，把AB两表中的唯一键放入中间表即可：比如手机表和APP表，一个手机可以安装多个APP，一个APP可以被多个手机安装。那么我们将APP的ID号和手机的手机号一同放入一张中间表（也叫关联表）中即可。



## MySQL 的最佳性能，需要遵循 3 个基本使用原则

首先是需要让 MySQL 回归存储的基本职能：MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离

其次是查询数据时，尽量单表查询，减少跨库查询和多表关联

还有就是要杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。

大 SQL，复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下

大批量，意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行

大字段，blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新



## 基本设置规则

必须指定默认存储引擎为 InnoDB，并且禁用 MyISAM 存储引擎，随着 MySQL 8.0 版本的发布，所有的数据字典表都已经转换成了 InnoDB，MyISAM 存储引擎已成为了历史。

默认字符集 UTF8mb4，以前版本的 UTF8 是 UTF8mb3，未包含个别特殊字符，新版本的 UTF8mb4 包含所有字符，官方强烈建议使用此字符集。

关闭区分大小写功能。设置 lower_case_tables_name=1，即可关闭区分大小写功能，即大写字母 T 和小写字母 t 一样


## 规范命名

命名规范如下，命名时的字符取值范围为：az，09 和 _（下画线）。

- 所有表名小写，不允许驼峰式命名；

- 不允许使用其他特殊字符作为名称，减少潜在风险。

  

- 命名使用具有意义的英文词汇，词汇中间以下划线分隔，一般为项目名称+代表库含义的简写，比如IM项目的工作流数据库，可以是 im_flow。

  ### 表命名规范

  1、常规表表名以t_开头，t代表table的意思，命名规则即 t + 模块（包含模块含义的简写）+ 表（包含表含义的简写），比如用户模块的教育信息表：t_user_eduinfo。

  2、临时表（RD、QA或DBA同学用于数据临时处理的表），命名规则：temp前缀+模块+表+日期后缀：temp_user_eduinfo_20210719

  3、备份表（用于保存和归档历史数据或者作为灾备恢复的数据）命名规则，bak前缀+模块+表+日期后缀：bak_user_eduinfo_20210719

  4、同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义

  5、多个单词以下划线 _ 分隔

  6、常规表表名尽量不超过30个字符，temp表和bak表视情况而定，也尽量简短为宜，命名应使用小写

  ### 字段命名规范

  1、字段命名需要表示其实际含义的英文单词或简写，单词之间用下划线 _ 进行连接，如 service_ip、service_port。

  2、各表之间相同意义的字段必须同名，比如a表和b表都有创建时间，应该统一为create_time，不一致会很混乱。

  3、多个单词以下划线 _ 分隔

  4、字段名尽量不超过30个字符，命名应该使用小写

### 常见业务表类型

- 临时表，tmp；
- 备份表，bak；
- 字典表，dic；
- 日志表，log。

字段名精确，遵循“见名知意”的原则，格式：名称_后缀。

避免普遍简单、有歧义的名称。

用户表中，用户名的字段为 UserName 比 Name 更好。

布尔型的字段，以助动词（has/is）开头。

用户是否有留言 hasmessage，用户是否通过检查 ischecked 等。

### 常见后缀

流水号/无意义主键，后缀为 id，比如 task_id；

时间，后缀为 time，insert_time。

程序账号与数据库名称保持一致。如果所有的程序账号都是 root@‘%’，密码也一样，很容易错连到其他的数据库，造成误操作。

索引命名格式，主要为了区分哪些对象是索引：

前缀_表名（或缩写）_字段名（或缩写）；

主键必须使用前缀“pk_”；

UNIQUE 约束必须使用前缀“uk_”；

普通索引必须使用前缀“idx_”。

数据库规范库表字段的命名，能够提高数据库的易读性，为数据库表设计打下基础。下面我们具体看看表设计的一些规则。

显式指定需要的属性；
创建表时显示指定字符集、存储引擎、注释信息等。

不同系统之间，统一规范；


### InnoDB 表的注意事项
主键列，UNSIGNED 整数，使用 auto_increment；禁止手动更新 auto_increment，可以删除。

必须添加 comment 注释。

必须显示指定的 engine。

表必备三字段：id、 xxx_create、 xxx_modified。

id 为主键，类型为 unsigned bigint 等数字类型；

xxx_create、xxx_modified 的类型均为 datetime 类型，分别记录该条数据的创建时间、修改时间。

## mysql的性能优化

### 尽量避免null列
not in ,!=等负向条件下null列返回的是空结果

对于null column，count(null column)是不计入统计结果的

null列会占用多一个字节的空间，来表明是否为空

大多数情况下，null列都是可以用默认值来替代的

### 尽量使用更简单的数据类型
简单意味着更低的磁盘存储，内存占用和cpu性能开销，特别是大数据量高并发的情况下，对性能影响比较大
对于索引列，越小的数据类型，意味着每个数据页能存更多的分支，减少索引的次数
###  整数
整数类型主要有： tinyint,smallint,mediumint,int,bigint,分别用8，16，24，32，64个位进行存储，存储范围是-2N-1-1 ~ 2N-1,N表示存储的位数。可以使用unsigned来表明正数，这样可以使存储的上限变成2N-1,将近扩大了一半。

另外特别要注意的是，mysql中整型可以指定宽度，但是这个宽度并不是用来限制这个列的长度的，只是用来对查询的结果进行补0显示。也就是说int(1)和int(7),int(100)都是只能存8个byte32位,范围都是-231-1 ~ 231，指定的宽度唯一的作用就是用来对客户端查询结果进行补0，而且得开启zero_fill才行，比如age int(3) ZEROFILL，如果插入值为10，那么查询的结果为010，插入1000，结果为1000。

如果确定没有负数，可以使用unsigned 类型，让可存储的上限能扩大一倍，间接的使用更小的数据类型

### 实数
 float和double来表示，属于浮点数，存在精度丢失问题，但是因为cpu原生支持浮点运算，所以性能更好,float最大支持存储4个字节，double最大支持8个字节

decimal 属于定点数，精确类型，但是由于是通过mysql实现的精度计算，相对于浮点型来讲性能要差点
**实数类型选择：**

1 如果精度要求不高，直接使用float或double

2 如果对精度要求高，性能要求不高，可以考虑使用decimal

3 如果对精度和性能都有要求，可以考虑将小数转为整型存储，

比如财务系统，需要精确为分，可以将金额乘以100进行保存到int或bigint里面

2.4 字符串
使用varchar要尽量设定小的字节数，因为mysql在创建临时表或排序的时候，会悲观的给varchar类型分配最大的长度

 总结：

1 字段设计时尽量选择小而简单的数据类型越好

2 除非必要，不使用可空列，用默认值代替

3 varchar类型虽然是变长，也应该按实际所需分配字节

4 整型不需要指定长度

5 只有正数考虑用unsigned,可以扩大上限

6 实数精度要求不高情况，优先使用浮点类型float，double,如果精度要求高可考虑用整型转化或直接使用decimal类型

## 数据表关系

### 关联映射

**一对多/多对一**

存在最普遍的映射关系，简单来讲就如球员与球队的关系；

一对多：从球队角度来说一个球队拥有多个球员 即为一对多

多对一：从球员角度来说多个球员属于一个球队 即为多对一

**一对一**

一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。

数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。

**多对多**

多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。

数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多

### 数据表之间的约束

约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。

**主键(PRIMARY KEY)**

是用于约束表中的一行，作为这一行的标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要。主键要求这一行的数据不能有重复且不能为空。

 还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识

===================================================

**默认值约束(DEFAULT)**

规定，当有DEFAULT约束的列，插入数据为空时该怎么办。

DEFAULT约束只会在使用INSERT语句（上一实验介绍过）时体现出来，INSERT语句中，如果被DEFAULT约束的位置没有值，那么这个位置将会被DEFAULT的值填充

===================================================

**唯一约束(UNIQUE)**

比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。

当INSERT语句新插入的数据和已有数据重复的时候，如果有UNIQUE约束，则INSERT失败.

===================================================

**外键(FOREIGN KEY)**

既能确保数据完整性，也能表现表之间的关系。

一个表可以有多个外键，每个外键必须REFERENCES(参考)另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。

在INSERT时，如果被外键约束的值没有在参考列中有对应，比如以下命令，参考列(department表的dpt_name)中没有dpt3，则INSERT失败



RESTRICT（约束）：如果出现在删除时，意思是约束外键主键did记录（主表中的记录）不能直接删除，必须先删除被约束的表（从表）字段中dept_id所有这个外键主键值对应的记录，才能删除外键约束（主表中的记录）

NO ACTION：

CASCADE：删除选择这个时，删除主表中的记录时，主表中的这个主键id关联的从表的这个id值所在的记录也会被删除。建议不选。

SET NULL ：删除选择这个时，如果从表（被约束的字段所在的表中）被约束的字段的值设置为可以为空时，那么当删除主表的记录时，主表中被删除的这个记录对应的主键值（约束从表字段的那个值）在从表中对应的字段中出现的那个记录的被约束字段的值就会变为NULL。

最常用的是选择RESTRICT不让删的这个约束、或者选择SET NULL删除后值表为空。

===================================================

**非空约束(NOT NULL)**

听名字就能理解，被非空约束的列，在插入值时必须非空。

在MySQL中违反非空约束，不会报错，只会有警告.



# VS常用快捷键

### Ctrl+K+S

使用region分割，快捷键：Ctrl+K+S

```
#region MyRegion
#endregion
```



#  VSCode

## vs快捷键

### 通过匹配文本打开文件

Windows: Ctrl + T



### 集成终端

Windows: Ctrl + `

通过 **Ctrl + `**可以打开或关闭终端

### 逐个选择文本

可以通过快捷键`Ctrl + Shift +右箭头`(Mac: `option + Shift +右箭头`)和`Ctrl + Shift +左箭头`(Mac: option + Shift +左箭头)逐个选择文本。

### 重复的行

一个非常强大和已知的功能是复制行。只需按 `Shift + Alt + 向下箭头` (Mac: `command + Shift + 向下箭头`)

### 移至文件的开头/结尾

要使光标移到文件的第一行或最后一行，最快的方法是按`Ctrl + Home` (`Mac: command + Home`)键开头，然后按`Ctrl + End` (Mac: `command + End`)键结尾。



## 代码片段

第一步，复制自己需要生成代码片段的代码； 第二步，[snippet-generator.app/](https://link.juejin.cn?target=https%3A%2F%2Fsnippet-generator.app%2F) 在该网站中生成代码片段； 第三步，在VSCode中配置代码片段；

### vscode代码片段过程

设置 - 用户代码片段 - - 粘贴生成的代码片段

1. 可以直接打开现有代码片段
2. 可以选择创建全局代码片段
3. 可以选择创建当前文件夹的代码片段

### 个人片段预设

#### v3

vue3+ts+scss 基础模板

```vue
{
  "vue3+ts+scss": {
    "prefix": "v3",
    "body": [
      "",
      "<template>",
      "  <div class=\"on\">",
      "  </div>",
      "</template>",
      "",
      "<script lang=\"ts\">",
      "import { defineComponent } from \"vue\";",
      "",
      "export default defineComponent({",
      "  name: \"\",",
      "  setup() {",
      "    return {",
      "    };",
      "  },",
      "});",
      "</script>",
      "",
      "<style lang=\"scss\" scoped>",
      "//@import \"./index.scss\";",
      "</style>"
    ],
    "description": "vue3+ts+scss"
  }
}
```

#### om

onMounted

```
{
  "onMounted-async": {
    "prefix": "om",
    "body": [
      "    onMounted(async () => {",
      "      ",
      "    });"
    ],
    "description": "onMounted-async"
  }
}
```



## .eslintrc.js

```js
/*
 * @Author: your name
 * @Date: 2020-12-14 17:18:11
 * @LastEditTime: 2021-08-03 08:55:21
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \blogs-s\src\.eslintrc.js
 */
module.exports = {
  extends: [
    'plugin:vue/vue3-essential',
    'eslint:recommended',
    '@vue/typescript/recommended'
  ],
  plugins: [
    'vue',
    '@typescript-eslint'
  ],
  rules: {
    '@typescript-eslint/no-var-requires': 0,
    '@typescript-eslint/no-unused-vars': 'error',
    // 允许非空断言
    '@typescript-eslint/no-non-null-assertion': 'off',
    // 允许自定义模块和命名空间
    '@typescript-eslint/no-namespace': 'off',
    "@typescript-eslint/no-inferrable-types": "off", // 关闭类型推断
    // 允许对this设置alias
    '@typescript-eslint/no-this-alias': 'off',
    // 允许使用any类型
    '@typescript-eslint/no-explicit-any': ['off'],
    //Missing return type on function
    "@typescript-eslint/explicit-module-boundary-types": "off",
  }
}
```



## 常用插件



### vite-plugin-restart

通过监听文件修改，自动重启 vite 服务。

最常用的场景就是监听 `vite.config.js` 和 `.env.development` 文件，我们知道，修改 vite 配置文件和环境配置文件，是需要重启 vite 才会生效，通过这个插件，我们将从反复重启中解脱出来。



### Code Spell Checker

检测你写代码时拼写的单词是否正确。

#### 安装方法

1. 在应用商店中搜索Code Spell Checker。
2. 点击安装，等待安装完成，然后重启VSCode。

#### Add Word to Workspace Dictionaries

（向工作区词典添加单词）

选中要添加的单词–>右击鼠标–>点击这个Add Word to Workspace Dictionaries，这样下次在拼写这个单词的时候便不会出现波浪线的提示。

#### Add Word to User Dictionary

（将单词添加到用户词典）
操作步骤如上，只需要选中不同的Add Word to User Dictionary功能即可。

#### Ignore Word

（忽略单词）

操作步骤如上，只需要选中不同的Ignore Word功能即可。


#### 删除单词解决方案：

Add Word to Workspace Dictionaries，这就是意味着添加进来了工作区词典，而在VSCode中创建项目时，系统会给我们生成一个.vscode的文件夹，修改settings.json即可




Add Word to User Dictionary，这就需要我们再我们再VSCode的系统设置中修改。

设置–>用户–>扩展–>找到安装的Code Spell Checker–>打开settings.json，在其中找到图6的内容，在其中修改添加错的单词，我在其中添加的是bindblur单词。

 Ignore Word，方法和第一个一样，因为都是在.vscode中的setting.json文件中。


#### 总结
Add Word to Workspace Dictionaries和Ignore Word仅是将word添加到该项目中，如果再新建一个项目以前添加的word将不再在新项目中生效，而Add Word to User Dictionary是将word添加到VSCode的系统中，所以即是新建一个项目也不会提示有波浪线。



### Code Runner

- 可以让你在 `vscode` 里方便的运行某个文件或者运行选取的某段代码。

### Bracket Pair Colorizer 2

- 给你的括号用颜色标记一下，这样当你的函数块里面有很多嵌套，就比较容易理清楚。

### Debugger for Chrome

- 我们知道可以在 `chrome` 浏览器中利用开发者工具打断点调试，那么如何在 `vscode` 进行 `debugger` 调试？
- [在 vscode 中调试 vue](https://xwhx.top/mall/other/vscode-debugger.html)

### ESLint

- 代码检查及错误提示。
- 结合 Prettier 插件可以让我们快速格式化代码。

### Prettier

- 格式化代码，规范代码风格。



### stylelint

#### 配置使用
npm安装stylelint及其用到的插件

```vue
npm i stylelint stylelint-config-standard stylelint-order stylelint-config-rational-order stylelint-scss -D
```

这里用到的插件有：

stylelint

stylelint-config-standard：stylelint官方共享的标准规则集成。里面包括了 Google's CSS Style Guide、

Airbnb's Styleguide、The Idiomatic CSS Principles以及@mdo's Code Guide。想看里面定义的源码可点击此。

stylelint-order：用于规范样式属性写作顺序的插件。

stylelint-config-rational-order：本人目前正在使用的css属性顺序的规则。配合stylelint-order使用。

stylelint-scss：用于支持校验scss语法的插件，例如@extend等。

关于上述插件更详细补充会在下文叙述。

#### 在根目录中创建stylelint配置文件
配置文件可以是.stylelintrc.json、stylelint.config.js的其中一种。或者可以写在package.json的stylelint变量中。这里就直接以.stylelintrc.json为例，配置文件如下所示：

```js
{
  "extends": ["stylelint-config-standard", "stylelint-config-rational-order"],
  "plugins": ["stylelint-order", "stylelint-scss"],
  "rules": {
    "indentation": 2,
    "no-missing-end-of-source-newline": null,
    "max-nesting-depth": 10,
    "selector-max-compound-selectors": 10,
    "at-rule-no-unknown": [
      true,
      {
        "ignoreAtRules": ["screen", "include", "mixin", "if", "layer"]
      }
    ]
  }
}

```

####  在vscode中安装stylelint

在vscode中打开setting.json（文件->首选项->设置）添加以下内容：

```json
 "editor.codeActionsOnSave": {
    "source.fixAll.stylelint": true
  },
  // stylelint配置
  "stylelint.enable": true,
  "css.validate": false,
  "less.validate": false,
  "scss.validate": false,
  "[scss]": {
    "editor.formatOnSave": true
  }
```

# 常用代码片段

## ts延时设定

```tsx
setTimeout(async () => {
dataList.show = false
}, 1200)
```

## bat命令复制文件

```bash

del xxxx.application
del setup.exe
del publish.htm
RD /S /Q "Application Files"
xcopy /E \\10.xx.x.x\mech_production_line_sharing\xxx
start xxxx.application

```

# Ant Design

## 分页

```js
          <section>
            <!-- 分页 -->
            <div class="blogs-page">
              <a-pagination
                size="small"
                @change="currentchange"
                :total="state.count"
                :pageSize="state.pagesize"
                show-quick-jumper
              ></a-pagination>
            </div>
            <!-- end 分页 -->
          </section>


async function currentchange(val: number) {
  state.page = val;
  await GetFyTit();
}

interface State {
  resultData: any;
  count: number;
  page: number; //页码
  pagesize: number; //每页条数
}
const state: State = reactive({
  resultData: [],
  count: 0,
  page: 1, //页码
  pagesize: 5, //每页条数
});

```



# 一些错误办法



## error ‘XXX‘ is not defined no-undef

在使用vue的时候，使用一个全局变量，ESLint的语法会出现ESLint: 'Aliplayer' is not defined. (no-undef)，说变量未定义，这时我们可以添加配置，取消这个校验。在.eslintrc.js文件中添加一个配置，位置如下图所示，我的全局变量就是Aliplayer。



```tsx
在eslintrc.js中的module.exports内添加如下代码块:
  "globals":{
    "Aliplayer": true
  }
```

# 开发计划

## 开发内容

NET 

1.one:分页查询 模糊查询

​    Tag:模糊查询(条件:标题)

Navigation: 分页查询

2.增加电影接口，书单接口，图册接口

博客：

1.样式调整优化

2.每个页面增加搜索框

3.右侧边栏内容增加

4.导航页面增加分页框

后台

搁置待重构



## BUG记录

### 未修复

IndexText: 点赞实现可重复点击 需更改数据库

### 已修复





## 项目结构

```
.
├── public # 公共静态资源目录
├── src # 主目录
│   ├── api # 接口文件
│   │   ├── data #实体类接口
│   │   ├── http #axios接口调用
│   ├── assets # 资源文件
│   │   ├── icons # icon sprite 图标文件夹
│   │   ├── img # 项目存放图片的文件夹
│   │   └── svg # 项目存放svg图片的文件夹
│   ├── components # 公共组件
│   ├── design # 样式文件
│   ├── hooks # 钩子
│   │   ├── xxxx # xxxx
│   │   ├── xxxx # xxxx
│   ├── main.ts # 主入口
│   ├── router # 路由配置
│   ├── store # 状态管理
│   ├── utils # 工具类
│   └── views # 页面
├── .env.development # 生产环境
├── .env.production # 生产环境
└── windi.config.ts # windcss配置文件
```

# 博客记录



### 博客园

https://www.cnblogs.com/ouyangkai/

### 掘金

https://juejin.cn/user/3087084382852375

### 51CTO

https://blog.51cto.com/u_12828212

### CSDN

https://blog.csdn.net/qq_35624605?spm=1011.2124.3001.5343

### segmentfault

https://segmentfault.com/u/shaonian_5f461fef28d3b



jwsn1995 woshishui.?12
