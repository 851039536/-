# 前端开发

## 代码开发规范

### ClassName命名



ClassName的命名应该尽量精短、明确，必须以**字母开头命名**，且**全部字母为小写**，单词之间**统一使用下划线** “_” 连接

#### 命名原则

祖先模块不能出现下划线，除了是全站公用模块，如 `mod_` 系列的命名：

**推荐：**

```css
<div class="modulename">
	<div class="modulename_info">
		<div class="modulename_son"></div>
		<div class="modulename_son"></div>
		...
	</div>
</div>
	
<!-- 这个是全站公用模块，祖先模块允许直接出现下划线 -->
<div class="mod_info">
	<div class="mod_info_son"></div>
	<div class="mod_info_son"></div>
	...		
</div>
```

在子孙模块数量可预测的情况下，严格继承祖先模块的命名前缀

```
<div class="modulename">
	<div class="modulename_cover"></div>
	<div class="modulename_info"></div>
</div>
```

当子孙模块超过4级或以上的时候，可以考虑在祖先模块内具有识辨性的独立缩写作为新的子孙模块

**推荐：**

```
<div class="modulename">
	<div class="modulename_cover"></div>
	<div class="modulename_info">
    	<div class="modulename_info_user">
    		<div class="modulename_info_user_img">
    			<img src="" alt="">
    			<!-- 这个时候 miui 为 modulename_info_user_img 首字母缩写-->
    			<div class="miui_tit"></div>
    			<div class="miui_txt"></div>
    			...
    		</div>
    	</div>
    	<div class="modulename_info_list"></div>
	</div>
</div>
```



#### 模块命名

全站公共模块：以 `mod_` 开头

```
<div class="mod_yours"></div>
```

业务公共模块：以 `业务名_mod_` 开头

```
<div class="paipai_mod_yours"></div>
```

#### 常用命名推荐

**注意**：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名

| ClassName              | 含义                                     |
| :--------------------- | :--------------------------------------- |
| about                  | 关于                                     |
| account                | 账户                                     |
| arrow                  | 箭头图标                                 |
| article                | 文章                                     |
| aside                  | 边栏                                     |
| audio                  | 音频                                     |
| avatar                 | 头像                                     |
| bg,background          | 背景                                     |
| bar                    | 栏（工具类）                             |
| branding               | 品牌化                                   |
| crumb,breadcrumbs      | 面包屑                                   |
| btn,button             | 按钮                                     |
| caption                | 标题，说明                               |
| category               | 分类                                     |
| chart                  | 图表                                     |
| clearfix               | 清除浮动                                 |
| close                  | 关闭                                     |
| col,column             | 列                                       |
| comment                | 评论                                     |
| community              | 社区                                     |
| container              | 容器                                     |
| content                | 内容                                     |
| copyright              | 版权                                     |
| current                | 当前态，选中态                           |
| default                | 默认                                     |
| description            | 描述                                     |
| details                | 细节                                     |
| disabled               | 不可用                                   |
| entry                  | 文章，博文                               |
| error                  | 错误                                     |
| even                   | 偶数，常用于多行列表或表格中             |
| fail                   | 失败（提示）                             |
| feature                | 专题                                     |
| fewer                  | 收起                                     |
| field                  | 用于表单的输入区域                       |
| figure                 | 图                                       |
| filter                 | 筛选                                     |
| first                  | 第一个，常用于列表中                     |
| footer                 | 页脚                                     |
| forum                  | 论坛                                     |
| gallery                | 画廊                                     |
| group                  | 模块，清除浮动                           |
| header                 | 页头                                     |
| help                   | 帮助                                     |
| hide                   | 隐藏                                     |
| hightlight             | 高亮                                     |
| home                   | 主页                                     |
| icon                   | 图标                                     |
| info,information       | 信息                                     |
| last                   | 最后一个，常用于列表中                   |
| links                  | 链接                                     |
| login                  | 登录                                     |
| logout                 | 退出                                     |
| logo                   | 标志                                     |
| main                   | 主体                                     |
| menu                   | 菜单                                     |
| meta                   | 作者、更新时间等信息栏，一般位于标题之下 |
| module                 | 模块                                     |
| more                   | 更多（展开）                             |
| msg,message            | 消息                                     |
| nav,navigation         | 导航                                     |
| next                   | 下一页                                   |
| nub                    | 小块                                     |
| odd                    | 奇数，常用于多行列表或表格中             |
| off                    | 鼠标离开                                 |
| on                     | 鼠标移过                                 |
| output                 | 输出                                     |
| pagination             | 分页                                     |
| pop,popup              | 弹窗                                     |
| preview                | 预览                                     |
| previous               | 上一页                                   |
| primary                | 主要                                     |
| progress               | 进度条                                   |
| promotion              | 促销                                     |
| rcommd,recommendations | 推荐                                     |
| reg,register           | 注册                                     |
| save                   | 保存                                     |
| search                 | 搜索                                     |
| secondary              | 次要                                     |
| section                | 区块                                     |
| selected               | 已选                                     |
| share                  | 分享                                     |
| show                   | 显示                                     |
| sidebar                | 边栏，侧栏                               |
| slide                  | 幻灯片，图片切换                         |
| sort                   | 排序                                     |
| sub                    | 次级的，子级的                           |
| submit                 | 提交                                     |
| subscribe              | 订阅                                     |
| subtitle               | 副标题                                   |
| success                | 成功（提示）                             |
| summary                | 摘要                                     |
| tab                    | 标签页                                   |
| table                  | 表格                                     |
| txt,text               | 文本                                     |
| thumbnail              | 缩略图                                   |
| time                   | 时间                                     |
| tips                   | 提示                                     |
| title                  | 标题                                     |
| video                  | 视频                                     |
| wrap                   | 容器，包，一般用于最外层                 |
| wrapper                | 容器，包，一般用于最外层                 |



### HTML/CSS文件命名

确保文件命名总是以字母开头而不是数字，且字母一律小写，以下划线连接且不带其他标点符号，如：

```vue
<!-- HTML -->
jdc.html
jdc_list.html
jdc_detail.html

<!-- SASS -->
jdc.scss
jdc_list.scss
jdc_detail.scss
```

### css规范

#### 代码大小写

样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。

#### 选择器

- 尽量少用通用选择器 `*`
- 不使用 ID 选择器
- 不使用无具体语义定义的标签选择器

```css
/* 推荐 */
.jdc {}
.jdc li {}
.jdc li p{}

/* 不推荐 */
*{}
#jdc {}
.jdc div{}
```

### 属性值引号

css属性值需要用到引号时，统一使用单引号

```css
/* 推荐 */
.jdc { 
	font-family: 'Hiragino Sans GB';
}

/* 不推荐 */
.jdc { 
	font-family: "Hiragino Sans GB";
}
```

### 属性书写顺序

建议遵循以下顺序：

1. 布局定位属性：display / position / float / clear / visibility / overflow
2. 自身属性：width / height / margin / padding / border / background
3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word
4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …

```css
.jdc {
    display: block;
    position: relative;
    float: left;
    width: 100px;
    height: 100px;
    margin: 0 10px;
    padding: 20px 0;
    font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
    color: #333;
    background: rgba(0,0,0,.5);
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
```

### CSS3浏览器私有前缀写法

CSS3 浏览器私有前缀在前，标准前缀在后

```css
.jdc {
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
```

#### 模块注释

```css
/* Module A
---------------------------------------------------------------- */
.mod_a {}


/* Module B
---------------------------------------------------------------- */
.mod_b {}
```

#### 文件信息注释

在样式文件编码声明 `@charset` 语句下面注明页面名称、作者、创建日期等信息

```
@charset "UTF-8";
/**
 * @desc File Info
 * @author Author Name
 * @date 2015-10-10
 */
```

### SASS规范

#### 团队约定

SCSS 文件内

- 全部遵循 CSS 注释规范
- 不使用 `/*! */` 注释方式
- 注释内不放 SASS 变量

标准的注释规范如下：

```css
@charset "UTF-8";

/**
 * @desc File Info
 * @author liqinuo
 * @date 2015-10-10
 */

/* Module A
----------------------------------------------------------------*/
.mod_a {}

/* module A logo */
.mod_a_logo {}

/* module A nav */
.mod_a_nav {}


/* Module B
----------------------------------------------------------------*/
.mod_b {}

/* module B logo */
.mod_b_logo {}

/* module B nav */
.mod_b_nav {}
```

#### 变量

可复用属性尽量抽离为页面变量，易于统一维护

```css
// CSS
.jdc {
    color: red;
    border-color: red;
}

// SCSS
$color: red;
.jdc {
    color: $color;
    border-color: $color;
}
```

#### 混合(mixin)

根据功能定义模块，然后在需要使用的地方通过 `@include` 调用，避免编码时重复输入代码段

```css
// CSS
.jdc_1 {
    -webkit-border-radius: 5px;
    border-radius: 5px;
}
.jdc_2 {
    -webkit-border-radius: 10px;
    border-radius: 10px;
}

// SCSS
@mixin radius($radius:5px) {
    -webkit-border-radius: $radius;
    border-radius: $radius;
}
.jdc_1 {
    @include radius; //参数使用默认值
}
.jdc_2 {
    @include radius(10px);
}


// CSS
.jdc_1 {
    background: url(/img/icon.png) no-repeat -10px 0;
}
.jdc_2 {
    background: url(/img/icon.png) no-repeat -20px 0;
}

// SCSS
@mixin icon($x:0, $y:0) {
    background: url(/img/icon.png) no-repeat $x, $y;
}
.jdc_1 {
    @include icon(-10px, 0);
}
.jdc_2 {
    @include icon(-20px, 0);
}
```

#### 占位选择器 %

如果不调用则不会有任何多余的 css 文件，占位选择器以 `%` 标识定义，通过 `@extend` 调用

```css
//scss
%borderbox {
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
.jdc {
    @extend %borderbox;
}
```

#### extend 继承

```css
// CSS
.jdc_1 {
    font-size: 12px;
    color: red;
}
.jdc_2 {
    font-size: 12px;
    color: red;
    font-weight: bold;
}

// SCSS
.jdc_1 {
    font-size: 12px;
    color: red;
}
.jdc_2 {
    @extend .jdc_1;
    font-weight: bold;
}

// 或者
%font_red {
    font-size: 12px;
    color: red;
}
.jdc_1 {
    @extend %font_red;
}
.jdc_2 {
    @extend %font_red;
    font-weight: bold;
}
```

#### for 循环

```css
// CSS
.jdc_1 {background-position: 0 -20px;}
.jdc_2 {background-position: 0 -40px;}
.jdc_3 {background-position: 0 -60px;}

// SCSS
@for $i from 1 through 3 {
    .jdc_#{$i} {
        background-position: 0 (-20px) * $i;
    }
}
```

注意：`#{}` 是连接符，变量连接使用时需要依赖

#### each 循环

```css
// CSS
.jdc_list {
    background-image: url(/img/jdc_list.png);
}
.jdc_detail {
    background-image: url(/img/jdc_detail.png);
}

// SCSS
@each $name in list, detail {
    .jdc_#{$name} {
        background-image: url(/img/jdc_#{$name}.png);
    }
}


// CSS
.jdc_list {
    background-image: url(/img/jdc_list.png);
    background-color: red;
}
.jdc_detail {
    background-image: url(/img/jdc_detail.png);
    background-color: blue;
}

// SCSS
@each $name, $color in (list, red), (detail, blue) {
    .jdc_#{$name} {
        background-image: url(/img/jdc_#{$name}.png);
        background-color: $color;
    }
}
```

#### function 函数

```css
@function pxToRem($px) {
    @return $px / 10px * 1rem;
}
.jdc {
    font-size: pxToRem(12px);
}
```

#### 运算规范

运算符之间空出一个空格

```css
.jdc {
    width: 100px - 50px;
    height: 30px / 5;
}
```

注意运算单位，单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意

```css
// 正确的运算格式
.jdc {
    width: 100px - 50px;
    width: 100px + 50px;
    width: 100px * 2;
    width: 100px / 2;
}
```

### 重置样式



### 移动端

```
* { -webkit-tap-highlight-color: transparent; outline: 0; margin: 0; padding: 0; vertical-align: baseline; }
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin: 0; padding: 0; vertical-align: baseline; }
img { border: 0 none; vertical-align: top; }
i, em { font-style: normal; }
ol, ul { list-style: none; }
input, select, button, h1, h2, h3, h4, h5, h6 { font-size: 100%; font-family: inherit; }
table { border-collapse: collapse; border-spacing: 0; }
a { text-decoration: none; color: #666; }
body { margin: 0 auto; min-width: 320px; max-width: 640px; height: 100%; font-size: 14px; font-family: -apple-system,Helvetica,sans-serif; line-height: 1.5; color: #666; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; }
input[type="text"], textarea { -webkit-appearance: none; -moz-appearance: none; appearance: none; }
```

### PC端

```
html, body, div, h1, h2, h3, h4, h5, h6, p, dl, dt, dd, ol, ul, li, fieldset, form, label, input, legend, table, caption, tbody, tfoot, thead, tr, th, td, textarea, article, aside, audio, canvas, figure, footer, header, mark, menu, nav, section, time, video { margin: 0; padding: 0; }
h1, h2, h3, h4, h5, h6 { font-size: 100%; font-weight: normal }
article, aside, dialog, figure, footer, header, hgroup, nav, section, blockquote { display: block; }
ul, ol { list-style: none; }
img { border: 0 none; vertical-align: top; }
blockquote, q { quotes: none; }
blockquote:before, blockquote:after, q:before, q:after { content: none; }
table { border-collapse: collapse; border-spacing: 0; }
strong, em, i { font-style: normal; font-weight: normal; }
ins { text-decoration: underline; }
del { text-decoration: line-through; }
mark { background: none; }
input::-ms-clear { display: none !important; }
body { font: 12px/1.5 \5FAE\8F6F\96C5\9ED1, \5B8B\4F53, "Hiragino Sans GB", STHeiti, "WenQuanYi Micro Hei", "Droid Sans Fallback", SimSun, sans-serif; background: #fff; }
a { text-decoration: none; color: #333; }
a:hover { text-decoration: underline; }
```

## html



### Emmet语法

#### 2-1. 后代：>

```html
nav>ul>li
```

```html
<nav>
    <ul>
        <li></li>
    </ul>
</nav>
```

#### 2-2. 兄弟：+

```html
div+p+bq
```

```
<div></div>
<p></p>
<blockquote></blockquote>
```

#### 2-3. 上级：^

```
div+div>p>span+em^bq
```

```html
<div></div>
<div>
    <p><span></span><em></em></p>
    <blockquote></blockquote>
</div>
```

```
div+div>p>span+em^^bq
```

```html
<div></div>
<div>
    <p><span></span><em></em></p>
</div>
<blockquote></blockquote>
```

#### 2-4. 分组：()

(1)缩写↓

```
div>(header>ul>li*2>a)+footer>p
```

```html
<div>
    <header>
        <ul>
            <li><a href=""></a><li>
            <li><a href=""></a><li>
        </ul>
    </header>
    </footer>
        <p></p>
    </footer>
</div>
```

(2)缩写↓

```
(div>dl>(dt+dd)*3)+footer>p
```

```html
<div>
    <dl>
        <dt></dt>
        <dd></dd>
        <dt></dt>
        <dd></dd>
        <dt></dt>
        <dd></dd>
    </dl>
</div>
<footer>
    <p></p>
</footer>
```

#### 2-5. 乘法：*

缩写↓

```
ul>li*5
```

```
<ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
<ul>
```

#### 2-6.自增符号：$

1)缩写↓

```
ul>li.item$*5
```

```html
<ul>
    <li class="item1"></li>
    <li class="item2"></li>
    <li class="item3"></li>
    <li class="item4"></li>
    <li class="item5"></li>
<ul>
```

(2)缩写↓

```
h$[title=item$]{Header $}*3
```

```html
<h1 title="item1">Header 1</h1>
<h2 title="item2">Header 2</h2>
<h3 title="item3">Header 3</h3>
```

(3)缩写↓

```
ul>li.item$$$*5
```

```html
<ul>
    <li class="item001"></li>
    <li class="item002"></li>
    <li class="item003"></li>
    <li class="item004"></li>
    <li class="item005"></li>
</ul>
```

(4)缩写↓

```
ul>li.item$@-*5
```

```html
<ul>
    <li class="item5"></li>
    <li class="item4"></li>
    <li class="item3"></li>
    <li class="item2"></li>
    <li class="item1"></li>
</ul>
```

(5)缩写↓

```
ul>li.item$@3*5
```

```html
<ul>
    <li class="item3"></li>
    <li class="item4"></li>
    <li class="item5"></li>
    <li class="item6"></li>
    <li class="item7"></li>
</ul>
```

#### 2-7.ID和类属性

(1)缩写↓

```
#header
```

```html
<div id="header"></div>
```

(2)缩写↓

```
.title
```

```html
<div class="title"></div>
```

(3)缩写↓

```
form#search.wide
```

```html
<form id="search" class="wide"></form>		
```

(4)缩写↓

```
p.class1.class2.class3
```

```html
<p class="class1 class2 class3"></p>
```

#### 2-8.自定义属性

(1)缩写↓

```
p[title="Hello world"]
```

```html
<p title="Hello world"></p>
```

(2)缩写↓

```
td[rowspan=2 colspan=3 title]
```

```html
<td rowspan="2" colspan="3" title=""></td>
```

(3)缩写↓

```
[a='value1' b="value2"]
```

```html
<div a="value1" b="value2"></div>
```

#### 2-9.文本：{}

(1)缩写↓

```
a{Click me}
```

```html
<a href="">Click me</a>
```

(2)缩写↓

```
p>{Click }+a{here}+{ to continue}
```

```html
<p>Click <a href="">here</a> to continue</p>
```

#### 2-10.隐式标签

(1)缩写↓

```
.class
```

```html
<div class="class"></div>
```

(2)缩写↓

```
em>.class
```

```html
<em><span class="class"></span></em>
```

(3)缩写↓

```
ul>.class
```

```html
<ul>
    <li class="class"></li>
</ul>
```

(4)缩写↓

```
table>.row>.col
```

```html
<table>
    <tr class="row">
        <td class="col"></td>
    </tr>
</table>
```



## CSS

### 优先级

> !important>行内样式>ID选择器>类、伪类、属性>元素、伪元素>继承>通配符

### 选择器

#### 标签选择器

```css
p{
    color:red;
}
```

#### ID选择器

```css
#warning{
    color:red;
}
```

#### 属性选择器

```html
<ul>
    <li foo>1</li>
    <li foo="abc">2</li>
    <li foo="abc efj">3</li>
    <li foo="abcefj">4</li>
    <li foo="efjabc">5</li>
    <li foo="ab">6</li>
</ul>
```

```css
//选择 attribute=value 的所有元素。
[foo=abc]{
    background-color:red;
}

//选择 attribute 属性包含单词 value 的所有元素。
[foo~=abc]{
    background-color:red;
}

//选择其 attribute 属性值以 value 开头的所有元素。类似正则的 ^,以什么开始
[foo^=abc]{
    background-color:red;
}

//选择其 attribute 属性值以 value 结束的所有元素。类似正则的 $,以什么结束
[foo$=abc]{
    background-color:red;
}

//选择其 attribute 属性中包含 value 子串的每个元素。
[foo*=abc]{
    background-color:red;
}

//选择 attribute 属性值以 value 开头的所有元素。
[foo|=abc]{
    background-color:red;
}

```

#### 后代选择器 element element

```CSS
ul li{
    border: 1px solid red;
}
```

#### 子选择器 element>element

```css
 ul>li>p{
   border: 1px solid red;
}
```

#### 相邻兄弟选择器 element+element

```css
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

//选择紧接在 element元素之后的 element 元素。
h1+p{
    color:red;
}

```

#### 一般兄弟选择器 element1~element2

```css
//选择前面有 element1 元素的每个 elem 元素。
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

 h1~p{
   border: 1px solid red;
}
```

#### 伪类选择器

```css
//:root 文档根元素伪类

:root{
    background-color:red;
}

//:nth-child(n) 孩子选择器
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

div :nth-child(1){
    color:red;
}

//:nth-of-type(n) 同类型的第n个元素
div p:nth-of-type(2){
    color: red;
}

//选择属于父元素element的第一个子元素。 等同 :nth-child(1)
element:first-child

//选择属于父元素element的最后一个子元素。
element:last-child

//同类型的第一个子元素
element:first-of-type

//同类型的最后一个子元素
element:last-of-type

<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>
<div>
    <h1>h2</h1>  
</div>

 div :only-child{
    color: red;
 }

//没有访问过的状态
a:link

//链接正在被点击
a:active

//选择鼠标指针位于其上的链接。
a:hover

//选择所有已被访问的链接。
a:visited

//:focus 选择器用于选取获得焦点的元素。
:focus

//选择每个启用的 input 元素 / 选择每个禁用的 input 元素
:enabled / :disabled

//选择每个被选中的 input 元素。自定义开关可以用这个实现
:checked

//选择非 selector 元素的每个元素。（反向选择）
:not(selector)
```



#### 伪元素选择器

```css
element::first-line

//p 元素的第一行发生改变
p:first-line{
	background-color:yellow;
}


element::first-letter
//直接第一个字符变黄，如果JavaScript做的话，需要获取字符串，再获取第一个字符，再改变其颜色
h1:first-letter{
	color:yellow;
}

//在每个 element 元素的内容之前插入内容。我们更多的可能是当作一个div来用
element::before

//在每个element元素的内容之后插入内容。我们可能更多的是用来清除浮动或验证表单提示等其它
element::after

//选择被用户选取的元素部分。
::selection
```



###  background

```css
    /* 背景图片 */
background: no-repeat center/100% url("../img/index.png");
	/* 背景颜色 */
  background-color: #ffffff;
  /*背景透明*/
  background-color: hsla(0,0%,100%,.7);
```

####  背景图

```css
//让背景图适配视口很容易，需要使用下面 CSS 即可：

body {
  background-image: url('https://images.unsplash.com/photo-1573480813647-552e9b7b5394?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2253&q=80');
  background-repeat: no-repeat;
  background-position: center;
  background-attachment: fixed;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
  -o-background-size: cover;
}

```

#### **使用多个背景图片**

```css
body {
  background-image: url(https://image.flaticon.com/icons/svg/748/748122.svg), url(https://images.unsplash.com/photo-1478719059408-592965723cbc?ixlib=rb-1.2.1&auto=format&fit=crop&w=2212&q=80);
  background-position: center, top;
  background-repeat: repeat, no-repeat;
  background-size: contain, cover;
}
```

#### **三角形的背景图像**

```html
<body>
  <div class="day"></div>
  <div class="night"></div>
</body>
```

```css
body {
  margin: 0;
  padding: 0;
}

div {
  position: absolute;
  height: 100vh;
  width: 100vw;
}

.day {
  background-image: url("https://images.unsplash.com/photo-1477959858617-67f85cf4f1df?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2613&q=80");
  background-size: cover;
  background-repeat: no-repeat;
}

.night {
  background-image: url("https://images.unsplash.com/photo-1493540447904-49763eecf55f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80");
  background-size: cover;
  background-repeat: no-repeat;
  clip-path: polygon(100vw 0, 0% 0vh, 100vw 100vh);
}
```

#### **添加叠加渐变**

```css
body {
  background-image: 
    linear-gradient(4deg, rgba(38,8,31,0.75) 30%, rgba(213,49,127,0.3) 45%, rgba(232,120,12,0.3) 100%),
    url("https://images.unsplash.com/photo-1503803548695-c2a7b4a5b875?ixlib=rb-1.2.1&auto=format&fit=crop&w=2250&q=80");
  background-size: cover;
  background-repeat: no-repeat;
  background-attachment: fixed;
  background-position: center
}
```

#### **网格背景图像**

```html
<body>
<div class="container">
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
</div>
</body>
```

```css
body {
 margin: 0;
  padding: 0;
}

.container {
  position: absolute;
  width: 100%;
  height: 100%;
  background: black;
  display: grid;
  grid-template-columns: 25fr 30fr 40fr 15fr;
  grid-template-rows: 20fr 45fr 5fr 30fr;
  grid-gap: 20px;
  .item_img {
    background-image: url('https://images.unsplash.com/photo-1499856871958-5b9627545d1a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2207&q=80');
  background-repeat: no-repeat;
  background-position: center;
  background-attachment: fixed;
  background-size: cover;
}
}

```

#### vue全局背景颜色

```js
mounted() {
  document.querySelector('body').setAttribute('style', 'background-color:#f7f7f7')
},
beforeDestroy() {
  document.querySelector('body').removeAttribute('style')
}
```





### 浮动 float

```css
float: left;
```

### 字体 font

```css
/* 字体颜色 */
  color: #888888;
/* 字体粗细 */
  font-weight: 400;
/* 字体大小 */
  font-size: 14px;
/* 文字居中 */
  text-align: center;
/* 字体行内居中 */
  line-height: 45px;

 /*字体加深*/
 text-shadow: 0 0 1px rgba(0,0,0,.3);

 /*起始段落空2格*/
 text-indent: 2em;
```

#### 字体发光

```css
 color: white;
                    text-shadow:
                            0px 0px 5px white,
                            0px 0px 5px white,
                            0px 0px 5px white,
                            0px 0px 20px rgba(171, 126, 177, 0.7),
                            0px 0px 20px rgba(171, 126, 177, 0.7),
                            0px 0px 20px rgba(171, 126, 177, 0.7),
                            0px 0px 20px rgba(171, 126, 177, 0.7);
```







###  margin | padding

```css
/* 外边距 */
  margin: 60px 0 0 -40px;
/* 居中显示 */
  margin: 0 auto;
/* 向下10px */
  margin-bottom: 10px;
/* 外边距 */
  padding: 15px 0 10px 12px;

```

### 透明

```css
 opacity: 0.9;
```

### 边框 border

```css
/* 边框宽度1px 样式 颜色 */
  border: 1px solid #868686;
/* 边框边角弧度 */
  border-radius: 5px;
/* 边框下划线 */
  border-bottom: 1px solid #edeef0;
/* 样式 1px */
  border-style: ridge;
  border-width: 1px;
```

#### border-radius 的斜线语法

```css
.border-radius {
  border-radius: 50px 25px / 25px 50px;
}
```



#### 背景3d边框

```css
 -webkit-box-sizing: border-box!important;
        box-sizing: border-box!important;
        overflow: hidden!important;
        border-radius: 2px!important;
        -webkit-box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12)!important;
        box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12)!important;

```

#### 实线边框

```css
    -webkit-box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);
    box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);
```



### 2D动画

#### 动画效果

```css
 /* 动画效果 */
  transition: all 5s;
```

#### 动画触发

```css
:hover {
  /* 放大2倍 */
  /* transform: scale(2, 2); */
  /* 旋转 */
  transform: rotate(720deg);
  /* 上移 */
  transform: translateY(-3px);
}

box-shadow: 0px 0px 2px 2px rgba(0, 0, 0, 0.3);
```

#### transition

颜色渐变

```js
    父标签
   -webkit-transition:background-color .5s ease-in;
	-moz-transition:background-color .5s ease-in;
	transition:background-color .5s ease-in;

    
    :hover{background-color:#bbb;}

```



### 3D动画

#### 3D转换 translate3d

```css
transform: translate3d(0,100px,100px);
```

#### 透视 perspective

```css
/* 透视写在被观察元素的父盒子上面 */
perspective: 500px;
```

#### 旋转 rotate3d

```css
  transform: rotateX(45deg);
  transform: rotateY();
  transform: rotateZ();
  /* 自定义 */
  transform: rotate3d(x,y,z,deg);
```

#### 3d呈现 transform-style

```css
  /* 让子元素保持3d立体空间环境 */
transform-style: preserve-3d;
```

### img

#### 设置图像的最大宽度

```css
img {
    max-width: 100%;
}
```

#### 悬停放大图片特效

```css
.img-wrapper img {
  -webkit-transition: 0.3s linear;
  transition: 0.3s linear;
}

.img-wrapper img:hover {
  transform: scale(1.1);
}

```

#### 颜色过滤

```css
/* ============== 
* 灰度过滤 
* ==============*/
.grayscale-img {
  -webkit-filter: grayscale(100%);
  filter: grayscale(100%);
}

.grayscale-img:hover {
  -webkit-filter: grayscale(0);
  filter: grayscale(0);
}

/* ============== 
* 深褐色过滤
* ==============*/
.sepia-img {
  -webkit-filter: sepia(100%);
  filter: sepia(100%);
}

.sepia-img:hover {
  -webkit-filter: sepia(0);
  filter: sepia(0);
}
```



### 定位

#### 元素固定

```css
@media (min-height: 500px) {
    .site-header {
        position: sticky;
        top: 0;
        /*other styles*/
    }
}
```

#### 居中定位

```c#
   position: absolute;
    width: 50%;
    height: 80%;
    overflow: auto;
    margin: auto;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
```



### css 技巧

#### 图片模糊

```css
        filter: blur(1px);
        -webkit-filter: blur(1px); /* chrome, opera */
        -ms-filter: blur(1px);
        -moz-filter: blur(1px);
```



#### 元素隐藏

```css
visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；
opacity: 0;``CSS3属性，设置0可以使一个元素完全透明；
position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外；
display: none; 元素会变得不可见，并且不会再占用文档的空间；
transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；
<div hidden="hidden"> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态；
height: 0; 将元素高度设为 0 ，并消除边框；
filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中；

```

#### 三角形

```css
/** 正三角 */
.triangle {
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 0 25px 40px 25px;
  border-color: transparent transparent rgb(245, 129, 127) transparent;
}
```

#### 倒三角

```css
/** 倒三角 */
.triangle {
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 40px 25px 0 25px;
  border-color:  rgb(245, 129, 127) transparent transparent transparent;
}
```

#### 虚线效果

```css
.dotted-line{
    border: 1px dashed transparent;
    background: linear-gradient(white,white) padding-box, repeating-linear-gradient(-45deg,#ccc 0, #ccc .25em,white 0,white .75em);
}
```

#### 文本超出省略号

单行文本

```css
.single-ellipsis{
  width: 500px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

多行文本

```css
.multiline-ellipsis {
  display: -webkit-box;
  word-break: break-all;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4; //需要显示的行数
  overflow: hidden;
  text-overflow: ellipsis;
}
```

#### 排版竖文

```vue
<div class="bruce flex-ct-x">
	<div class="vertical-text">
		<h3>情</h3>
		<p>我见犹怜，<br>爱不释手。<br>雅俗共赏，<br>君子好逑。</p>
	</div>
</div>

```

```css
.vertical-text {
	writing-mode: vertical-rl;
	h3 {
		padding-left: 20px;
		font-weight: bold;
		font-size: 18px;
		color: #f66;
	}
	p {
		line-height: 30px;
		color: #66f;
	}
}
```

#### 灰度模式

```css
filter: grayscale(100%);
```

#### 描绘波浪线

```vue
<div class="bruce flex-ct-x">
	<p class="waveline-text">波浪线文字</p>
</div>
```

```css
@mixin waveline($h, $color: #f66) {
	position: relative;
	&::after {
		position: absolute;
		left: 0;
		top: 100%;
		width: 100%;
		height: $h;
		background: linear-gradient(135deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%), linear-gradient(45deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%);
		background-size: $h * 2 $h * 2;
		content: "";
	}
}
.waveline-text {
	height: 20px;
	line-height: 20px;
	letter-spacing: 10px;
	@include waveline(10px);
}
```

#### 格子背景

```css
  background-image: linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%),
            linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%);
            background-position: 0 0, 20px 20px;
            background-size: 40px 40px;
```

#### 下划线跟随导航栏

```vue
<div class="bruce flex-ct-x">
	<ul class="underline-navbar">
		<li>Alibaba阿里巴巴</li>
		<li>Tencent腾讯</li>
		<li>Baidu百度</li>
		<li>Jingdong京东</li>
		<li>Ant蚂蚁金服</li>
		<li>Netease网易</li>
	</ul>
</div>
```

```css
.underline-navbar {
	display: flex;
	li {
		position: relative;
		padding: 10px;
		cursor: pointer;
		font-size: 20px;
		color: #09f;
		transition: all 300ms;
		&::before {
			position: absolute;
			left: 100%;
			top: 0;
			border-bottom: 2px solid transparent;
			width: 0;
			height: 100%;
			content: "";
			transition: all 300ms;
		}
		&:active {
			background-color: #09f;
			color: #fff;
		}
		&:hover {
			&::before {
				left: 0;
				top: 0;
				z-index: -1;
				border-bottom-color: #09f;
				width: 100%;
				transition-delay: 100ms;
			}
			& + li::before {
				left: 0;
			}
		}
	}
}
```

#### 动态边框

```vue
<div class="bruce flex-ct-x">
	<div class="dynamic-border">iCSS</div>
</div>
```

```css
.dynamic-border {
	width: 200px;
	height: 80px;
	background: linear-gradient(0, #f66 2px, #f66 2px) no-repeat left top/0 2px,
		linear-gradient(-90deg, #f66 2px, #f66 2px) no-repeat right top/2px 0,
		linear-gradient(-180deg, #f66 2px, #f66 2px) no-repeat right bottom/0 2px,
		linear-gradient(-270deg, #f66 2px, #f66 2px) no-repeat left bottom/2px 0;
	cursor: pointer;
	line-height: 80px;
	text-align: center;
	font-weight: bold;
	font-size: 50px;
	color: #f66;
	transition: all 300ms;
	&:hover {
		background-size: 100% 2px, 2px 100%, 100% 2px, 2px 100%;
	}
}
```

#### 自动打字

```html
<div class="bruce flex-ct-x">
	<div class="auto-typing">Do You Want To Know More About CSS Development Skill</div>
</div>
```

```css
@mixin typing($count: 0, $duration: 0, $delay: 0) {
	overflow: hidden;
	border-right: 1px solid transparent;
	width: #{$count + 1}ch;
	font-family: Consolas, Monaco, Monospace;
	white-space: nowrap;
	animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards, caret 500ms steps(1) #{$delay}s $duration * 2 forwards;
}
.auto-typing {
	font-weight: bold;
	font-size: 30px;
	color: #09f;
	@include typing(52, 5);
}
@keyframes typing {
	from {
		width: 0;
	}
}
@keyframes caret {
	50% {
		border-right-color: currentColor;
	}
}
```

#### 渐变色文字

```css
  <h2 class="gradient-text">Gradient text</h2>

<style>
.gradient-text {
  background-image: linear-gradient(90deg, red, blue);
  background-clip: text;
  color: transparent;
}
</style>

```

#### 顺滑滚动

```css
html {
  scroll-behavior: smooth;
}
```

#### text-shadow多阴影

```css
<h2 class="so-many-shadows">This is fun</h2>

<style>
.so-many-shadows {
  text-shadow: 
    3px 3px 0 yellow, 
    6px 6px 0 blue, 
    9px 9px red,
    12px 12px 0 black;
 }
</style>

```

#### text-shadow多边框叠加

```css
.content {
  box-shadow:
    0 0 0 10px #EE6352,
    0 0 0 20px #D45379,
    0 0 0 30px #A4558F,
    0 0 0 40px #6D588E,
    0 0 0 50px #405378;
}
```



#### 响应式多列布局

```css
.content {
  columns: 200px;
}

```



#### 动画链接下划线

```css
 h5 > a {
                position: relative;
                text-decoration: none;
            }
            h5 > a:hover {
                cursor: pointer;
            }
            h5 > a::before {
                content: "";
                position: absolute;
                width: 100%;
                height: 2px;
                bottom: 0;
                left: 0;
                background-color: #7f828f;
                visibility: hidden;
                transform: scaleX(0);
                transition: all 0.3s ease-in-out 0s;
            }
            h5 > a:hover::before {
                visibility: visible;
                transform: scaleX(1);
            }
```

#### 使用linear-gradient控制背景渐变

```css
.gradient-bg {
        background: linear-gradient(135deg, #f66, #f90, #3c9, #09f, #66f) left center/400% 400%;
        animation: move 10s infinite;
    }
    @keyframes move {
        0%,
        100% {
            background-position-x: left;
        }
        50% {
            background-position-x: right;
        }
    }
```

#### 清除 overflow: auto;的滚动条

```css

.div{
  overflow: auto
}
 
.div::-webkit-scrollbar{
    display: none;
}
```



### 控制文本渐变

```css
                        background-image: linear-gradient(90deg, #f66, #f90);
                        background-clip: text;
                        animation: hue 5s linear infinite;
                        -webkit-text-fill-color: transparent;
                        @keyframes hue {
                            from {
                                filter: hue-rotate(0);
                            }
                            to {
                                filter: hue-rotate(-1turn);
                            }
                        }
                    }
```

### 气泡背景墙

```html
<div class="bruce" data-title="气泡背景墙">
	<ul class="bubble-bgwall">
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
	</ul>
</div>
```

```css
.bruce {
	background-image: linear-gradient(270deg, #8146b4, #6990f6);
}
.bubble-bgwall {
	overflow: hidden;
	position: relative;
	margin: 0 auto;
	width: 100%;
	max-width: 1200px;
	height: 100%;
	li {
		display: flex;
		position: absolute;
		bottom: -200px;
		justify-content: center;
		align-items: center;
		border-radius: 10px;
		width: 50px;
		height: 50px;
		background-color: rgba(#fff, .15);
		color: #ccc;
		animation: bubble 15s infinite;
		&:nth-child(1) {
			left: 10%;
		}
		&:nth-child(2) {
			left: 20%;
			width: 90px;
			height: 90px;
			animation-duration: 7s;
			animation-delay: 2s;
		}
		&:nth-child(3) {
			left: 25%;
			animation-delay: 4s;
		}
		&:nth-child(4) {
			left: 40%;
			width: 60px;
			height: 60px;
			background-color: rgba(#fff, .3);
			animation-duration: 8s;
		}
		&:nth-child(5) {
			left: 70%;
		}
		&:nth-child(6) {
			left: 80%;
			width: 120px;
			height: 120px;
			background-color: rgba(#fff, .2);
			animation-delay: 3s;
		}
		&:nth-child(7) {
			left: 32%;
			width: 160px;
			height: 160px;
			animation-delay: 2s;
		}
		&:nth-child(8) {
			left: 55%;
			width: 40px;
			height: 40px;
			font-size: 12px;
			animation-duration: 15s;
			animation-delay: 4s;
		}
		&:nth-child(9) {
			left: 25%;
			width: 40px;
			height: 40px;
			background-color: rgba(#fff, .3);
			font-size: 12px;
			animation-duration: 12s;
			animation-delay: 2s;
		}
		&:nth-child(10) {
			left: 85%;
			width: 160px;
			height: 160px;
			animation-delay: 5s;
		}
	}
}
@keyframes bubble {
	0% {
		opacity: .5;
		transform: translateY(0) rotate(45deg);
	}
	25% {
		opacity: .75;
		transform: translateY(-400px) rotate(90deg);
	}
	50% {
		opacity: 1;
		transform: translateY(-600px) rotate(135deg);
	}
	100% {
		opacity: 0;
		transform: translateY(-1000px) rotate(180deg);
	}
}
```

### 自动打字器

```html
<div class="bruce flex-ct-x" data-title="自动打字">
	<div class="auto-typing">Do You Want To Know More About CSS Development Skill</div>
</div>
```

```css
@mixin typing($count: 0, $duration: 0, $delay: 0) {
	overflow: hidden;
	border-right: 1px solid transparent;
	width: #{$count + 1}ch;
	font-family: Consolas, Monaco, monospace;
	white-space: nowrap;
	animation: typing #{$duration}s steps($count + 1) #{$delay}s infinite backwards,
		caret 500ms steps(1) #{$delay}s infinite forwards;
	// animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards,
	// 	caret 500ms steps(1) #{$delay}s $duration * 2 forwards;
}
.auto-typing {
	font-weight: bold;
	font-size: 30px;
	color: #09f;
	@include typing(52, 5);
}
@keyframes caret {
	50% {
		border-right-color: currentColor;
	}
}
@keyframes typing {
	from {
		width: 0;
	}
}
```



### 鼠标样式cursor

**default**小白 默认

**pointer**小手

**move**移动

**text**文本

**not-allowed**禁止





### div盒子形状

#### 正方形

```css

    #square {
      width: 100px;
      height: 100px;
      background: red;
    }
  
```

#### 长方形

```

    #rectangle {
      width: 200px;
      height: 100px;
      background: red;
    }
  
```

#### 圆形

```
   #circle {
      width: 100px;
      height: 100px;
      background: red;
      border-radius: 50%
    }
```

#### 椭圆形

```

    #oval {
      width: 200px;
      height: 100px;
      background: red;
      border-radius: 100px / 50px;
    }
  
```

#### 三角形

```

    #triangle-up {
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-bottom: 100px solid red;
    }
  
```

```

    #triangle-down {
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-top: 100px solid red;
    }
  
```

 Left 三角形

```

    #triangle-left {
      width: 0;
      height: 0;
      border-top: 50px solid transparent;
      border-right: 100px solid red;
      border-bottom: 50px solid transparent;
    }
  
```

  Right

```

    #triangle-right {
      width: 0;
      height: 0;
      border-top: 50px solid transparent;
      border-left: 100px solid red;
      border-bottom: 50px solid transparent;
    }
  
```

 Top Left

```

    #triangle-topleft {
      width: 0;
      height: 0;
      border-top: 100px solid red;
      border-right: 100px solid transparent;
    }
  
```

 Top Right

```

    #triangle-topright {
      width: 0;
      height: 0;
      border-top: 100px solid red;
      border-left: 100px solid transparent;
    }
  
```

 Bottom Left

```

    #triangle-bottomleft {
      width: 0;
      height: 0;
      border-bottom: 100px solid red;
      border-right: 100px solid transparent;
    }
  
```

Bottom Right

```

    #triangle-bottomright {
      width: 0;
      height: 0;
      border-bottom: 100px solid red;
      border-left: 100px solid transparent;
    }
  
```

#### 5角星



```

    #star-five {
      margin: 50px 0;
      position: relative;
      display: block;
      color: red;
      width: 0px;
      height: 0px;
      border-right: 100px solid transparent;
      border-bottom: 70px solid red;
      border-left: 100px solid transparent;
      transform: rotate(35deg);
    }
    #star-five:before {
      border-bottom: 80px solid red;
      border-left: 30px solid transparent;
      border-right: 30px solid transparent;
      position: absolute;
      height: 0;
      width: 0;
      top: -45px;
      left: -65px;
      display: block;
      content: '';
      transform: rotate(-35deg);
    }
    #star-five:after {
      position: absolute;
      display: block;
      color: red;
      top: 3px;
      left: -105px;
      width: 0px;
      height: 0px;
      border-right: 100px solid transparent;
      border-bottom: 70px solid red;
      border-left: 100px solid transparent;
      transform: rotate(-70deg);
      content: '';
    }
  
```

#### 六角形

```

    #hexagon {
      width: 100px;
      height: 55px;
      background: red;
      position: relative;
    }
    #hexagon:before {
      content: "";
      position: absolute;
      top: -25px;
      left: 0;
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-bottom: 25px solid red;
    }
    #hexagon:after {
      content: "";
      position: absolute;
      bottom: -25px;
      left: 0;
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-top: 25px solid red;
    }
  
```

#### 八角形

```

    #octagon {
      width: 100px;
      height: 100px;
      background: red;
      position: relative;
    }
    #octagon:before {
      content: "";
      width: 100px;
      height: 0;
      position: absolute;
      top: 0;
      left: 0;
      border-bottom: 29px solid red;
      border-left: 29px solid #eee;
      border-right: 29px solid #eee;
    }
    #octagon:after {
      content: "";
      width: 100px;
      height: 0;
      position: absolute;
      bottom: 0;
      left: 0;
      border-top: 29px solid red;
      border-left: 29px solid #eee;
      border-right: 29px solid #eee;
    }
  
```

心型

```

    #heart {
      position: relative;
      width: 100px;
      height: 90px;
    }
    #heart:before,
    #heart:after {
      position: absolute;
      content: "";
      left: 50px;
      top: 0;
      width: 50px;
      height: 80px;
      background: red;
      border-radius: 50px 50px 0 0;
      transform: rotate(-45deg);
      transform-origin: 0 100%;
    }
    #heart:after {
      left: 0;
      transform: rotate(45deg);
      transform-origin: 100% 100%;
    }
  
```













### 响应式布局

#### 开发实现

媒体查询

百分比布局

rem布局

视口单位布局(vw/vh)

#### 设计步骤

设置meta标签

媒体查询设置样式

设置多种视图宽度

## JavaScript

#### 输入输出语句

alert(msg) 浏览器弹出警示框

console.log(msg) 浏览器打印输出信息

prompt(info) 浏览器弹出输入框

#### 网页跳转

```js
  //当前窗口跳转
   self.location.href=url
  //新窗口跳转
   window.open(url)
  //跳转链接 返回上一页
   window.history.back(-1);
```

 self 指代当前窗口对象，属于window 最上层的对象。

  location.href 指的是某window对象的url的地址

  self.location.href 指当前窗口的url地址，去掉self默认为当前窗口的url地址，一般用于防止外部的引用

　top.location.href:为引用test.html页面url的**父窗口对象的url**

#### 滚动到页面顶部

```js
const goToTop = () => window.scrollTo(0, 0);
goToTop();
```



## TypeScript



### TypeScript 基础类型

#### Boolean 类型

```javascript
let isDone: boolean = false; // tsc => var isDone = false;
```

#### Number 类型

```javascript
let count: number = 10;  // tsc => var count = 10
```

#### String 类型

```javascript
let name: string = 'Semliker'; // tsc => var name = 'Semlinker'
```

#### Array 类型

```javascript
let list: number[] = [1,2,3]; // tsc => var list = [1,2,3];   

let list: Array<number> = [1,2,3]; 
// tsc => var list = [1,2,3];
```

#### Enum 类型

```javascript
enum Direction {
	NORTH,
    SOUTH,
    EAST,
    WEST
};

let dir: Direction = Direction.NORTH;
```

默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。

当然我们也可以设置 NORTH 的初始值，比如：

```javascript
enum Direction {
	NORTH = 3,
  SOUTH,
  EAST,
  WEST
};
```

在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。

```javascript
enum Direction {
  NORTH = 'NORTH',
  SOUTH = 'SOUTH',
  EAST = 'EAST',
  WEST = 'WEST',
}
```

#### Any (动态类型)

```javascript
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; 

=> tsc =>  

var notSure = 4;
notSure = "maybe a string instead";
notSure = false;
```

#### Tuple

元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。

```javascript
let x: [string, number];

x = ['semlinker', 10]; // 正常赋值

x = [10, 'semlinker']; // 类型不匹配
```

当访问一个已知索引的元素，会得到正确的类型：

```javascript
console.log(x[0].substr(1)); // OK

// Error, 'number' does not have 'substr' method
console.log(x[1].substr(1));
```

当访问一个越界的元素，会使用联合类型替代：

```javascript
x[3] = 'world'; // OK, 字符串可以赋值给(string | number) 类型

console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString 方法

x[6] = true; // Error, 布尔不是(string | number) 类型
```

#### Void

某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：

```javascript
// 声明函数返回值为void
function warnUser(): void { 
    console.log("This is my warning message");
}

=> tsc =>  

function warnUser() {
	console.log("This is my warning message");
}
```

需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 `undefined` 或 `null`：

```javascript
let unusable: void = undefined;
```



#### Never

`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。

```javascript
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {}
}
```

### 类型断言

通过这种方式可以告诉编译器，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。

类型断言有两种形式：

- “尖括号”语法

```javascript
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```

- as 语法

```javascript
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```





### TypeScript Function

#### 

#### 箭头函数

- 常见语法

```javascript
myBooks.forEach(() => console.log('Done reading'));

myBooks.forEach(title => console.log(title));

myBooks.forEach((title, idx, arr) => 
  console.log(idx + '-' + title);
);

myBooks.forEach((title, idx, arr) => {
  console.log(idx + '-' + title);
});
```

- 使用示例

```javascript
// 未使用箭头函数
function Book() {
  let self = this;
  self.publishDate = 2016;
  setInterval(function() {
    console.log(self.publishDate);
  }, 1000);
}

// 使用箭头函数
function Book() {
  this.publishDate = 2016;
  setInterval(() => {
    console.log(this.publishDate);
  }, 1000);
}
```

#### 参数类型和返回类型

```javascript
function createUserId(name: string, id: number): string {
  return name + id;
}
```

#### 函数类型

```javascript
let IdGenerator: (chars: string, nums: number) => string;

function createUserId(name: string, id: number): string {
  return name + id;
}

IdGenerator = createUserId;
```

#### 可选参数及默认参数

```javascript
// 可选参数
function createUserId(name: string, age?: number, 
  id: number): string {
    return name + id;
}

// 默认参数
function createUserId(name: string = 'Semlinker', age?: number, 
  id: number): string {
    return name + id;
}
```

#### 剩余参数

```javascript
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
  });
}

let a = [];
push(a, 1, 2, 3);
```

### TypeScript Array

#### 数组解构

```javascript
let x: number, let y: number ,let z: number;
let five_array = [0,1,2,3,4];
[x,y,z] = five_array;
```

#### 数组展开运算符

```javascript
let two_array = [0,1];
let five_array = [...two_array,2,3,4];
```

#### 数组循环

```javascript
let colors: string[] = ["red", "green", "blue"];
for(let i in colors) {
  console.log(i);
}
```

### TypeScript Object

#### 对象解构

```javascript
let person = {
  name: 'Semlinker',
  gender: 'male'
};

let {name, gender} = person;
```

#### 对象展开运算符

```javascript
let person = {
  name: 'Semlinker',
  gender: 'male',
  address: 'Xiamen'
};

// 组装对象
let personWithAge = {...person, age: 31};

// 获取除了某些项外的其它项
let {name, ...rest} = person;
```

### TypeScript Interface

在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。

TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象](https://ts.xcatliu.com/advanced/class-and-interfaces.html#类实现接口)以外，也常用于对「对象的形状（Shape）」进行描述。

#### 对象的形状

```javascript
interface Person {
  name: string;
  age: number;
}

let semlinker: Person = {
  name: 'Semlinker',
  age: 31
};
```

#### 可选 | 只读属性

```javascript
interface Person {
  readonly name: string;
  age?: number;
}
```

只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。

```javascript
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

### TypeScript Class

在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。

在 TypeScript 中，我们可以通过 `Class` 关键字来定义一个类：

```javascript
class Greeter {
   static cname: string = 'Greeter'; // 静态属性
   greeting: string; // 成员属行

   constructor(message: string) { // 构造函数 - 执行初始化操作
     this.greeting = message;
   }

    static getClassName() { // 静态方法
      return 'Class name is Greeter';
    }
    
    greet() { // 成员方法
      return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
```

### TypeScript Accessors

在 TypeScript 中，我们可以通过 `getter` 和 `setter` 方法来实现数据的封装和有效性校验，防止出现异常数据。

```javascript
let passcode = "hello angular 5";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "hello angular 5") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}
```

### TypeScript Inheritance

继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类 (称为子类、子接口) 继承另外的一个类 (称为父类、父接口) 的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种 [is-a](https://zh.wikipedia.org/wiki/Is-a) 关系。

![img](https://ask.qcloudimg.com/http-save/6430184/zpsfvhpn85.jpeg?imageView2/2/w/1620)

在 TypeScripe 中，我们可以通过 `extends` 关键字来实现继承：

```javascript
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
sam.move();
```

### TypeScript Generics

泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。

#### 泛型接口

```javascript
interface GenericIdentityFn<T> {
    (arg: T): T;
}
```

#### 泛型类

```javascript
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

#### 使用示例

```javascript
interface Hero { // Hero 接口
    id: number;
    name: string;
}

getHeroes(): Observable<Hero[]> {
  return Observable.of([
     { id: 1, name: 'Windstorm' },
     { id: 13, name: 'Bombasto' },
     { id: 15, name: 'Magneta' },
     { id: 20, name: 'Tornado' }
  ]);
}
```

上面 `getHeroes(): Observable<Hero[]>` 表示调用 `getHeroes()` 方法后返回的是一个 Observable 对象，`<Hero[]>` 用于表示该 Observable 对象的观察者，将会收到的数据类型。示例中表示将会返回 `<Hero[]>` 英雄列表。

### tsconfig.json 简介

#### tsconfig.json 的作用

- 用于标识 TypeScript 项目的根路径；
- 用于配置 TypeScript 编译器；
- 用于指定编译的文件。

#### tsconfig.json 重要字段

- files - 设置要编译的文件的名称；
- include - 设置需要进行编译的文件，支持路径模式匹配；
- exclude - 设置无需进行编译的文件，支持路径模式匹配；
- compilerOptions - 设置与编译流程相关的选项。

compilerOptions 支持很多选项，常见的有 `baseUrl`、 `target`、`baseUrl`、 `moduleResolution` 和 `lib` 等。

#### tsconfig.json 示例

```javascript
{
  "compileOnSave": false,
  "compilerOptions": {
    "baseUrl": "./",
    "outDir": "./dist/out-tsc",
    "sourceMap": true,
    "declaration": false,
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "es5",
    "typeRoots": [
      "node_modules/@types"
    ],
    "lib": [
      "es2017",
      "dom"
    ],
    "paths": {
      "ngx-example-library": [
        "dist/ngx-example-library"
      ]
    }
  },
  "angularCompilerOptions": {
    "preserveWhitespaces": false
  }
}
```

### 编码规范

#### 变量和函数

使用驼峰（camelCase）命名变量和函数名

```javascript
var FooVar;
function BarFunc() { }
```

**Good**

```javascript
var fooVar;
function barFunc() { }
```

#### 类

使用帕斯卡（PascalCase）命名类名

**Bad**

```javascript
class foo { }
```

**Good**

```javascript
class Foo { }
```

使用帕斯卡（PascalCase）命名类成员与方法

**Bad**

```javascript
class Foo {
    Bar: number;
    Baz() { }
}
```

**Good**

```javascript
class Foo {
    bar: number;
    baz() { }
}
```

#### 接口

- 使用帕斯卡（PascalCase）命名接口
- 使用驼峰（camelCase）命令成员
- 误使用 `I` 前缀

**Bad**

```javascript
interface IFoo { }
```

**Good**

```javascript
interface Foo { }
```

#### 类型

- 使用帕斯卡（PascalCase）命名
- 使用驼峰（camelCase）命令成员

#### 命名空间

使用帕斯卡（PascalCase）命名

**Bad**

```javascript
namespace foo { }
```

**Good**

```javascript
namespace Foo { }
```

#### 枚举

使用帕斯卡（PascalCase）命名枚举

**Bad**

```javascript
enum color { }
```

**Good**

```javascript
enum Color { }
```

使用帕斯卡（PascalCase）命名枚举成员

**Bad**

```javascript
enum Color {
    red
}
```

**Good**

```javascript
enum Color {
    Red
}
```

#### Null vs Undefined

最好不好显式使用不可用的值

**Bad**

```javascript
let foo = { x:123, y:undefined };
```

**Good**

```javascript
let foo: { x:number, y?:number } = { x:123 };
```

通常使用 undefined（ 而不是返回一个类似于 { valid:boolean, value?:Foo } 的对象 ）

**Bad**

```javascript
return null;
```

**Good**

```javascript
return undefined;
```

参考 Node.js 回调函数 Error First 风格（若未发生异常，error 参数值设置为 null）

**Bad**

```javascript
cb(undefined)
```

**Good**

```javascript
cb(null)
```

避免使用值比较判断对象是否为 null 或 undefined

**Bad**

```javascript
if (error === null)
```

**Good**

```javascript
if (error)
```

#### 数组

声明数组时使用 `foos:Foo[]` 而不是 `foos:Array<Foo>`，便于阅读

#### 类型 vs 接口

当你需要复合类型时，使用 type

```javascript
type Foo = number | { someProperty: number }
```

当你需要继承或实现时，使用 interface

```javascript
interface Foo {
  foo: string;
}

interface FooBar extends Foo {
  bar: string;
}

class X implements FooBar {
  foo: string;
  bar: string;
}
```

### 风格指南

1. 使用箭头函数代替匿名函数表达式。

2. 只要需要的时候才把箭头函数的参数括起来。比如，

   ```
   (x) => x + x
   ```

    是错误的，下面是正确的做法：

   - `x => x + x`
   - `(x,y) => x + y`
   - `<T>(x: T, y: T) => x === y`

3. 总是使用 `{}` 把循环体和条件语句括起来。

4. 小括号里开始不要有空白。逗号，冒号，分号后要有一个空格。比如：

   - `for (let i = 0, n = str.length; i < 10; i++) { }`
   - `if (x < 10) { }`
   - `function f(x: number, y: string): void { }`

5. 每个变量声明语句只声明一个变量 。比如：使用 `let x = 1; var y = 2;` 而不是 `let x = 1, y = 2;`）。

6. 如果函数没有返回值，最好使用 `void`

### 调用css

```js
let menu = document.querySelector(".sn-text");
menu.style.color = "#fff";
menu.style.backgroundColor = "#000";
menu.style.opacity = "1";
```

### 接口(interface)

#### 定义使用

```tsx
interface User {
  brief: string;
}

const state: User = reactive({
  brief: "",
});
```

#### 非必填(?)



字段为**非必填**, 用"?"标记:

```ts
interface User {
  brief: string;
  test?: string;
}
const state: User = reactive({
  brief: "",
});
```

#### 用接口定义函数
接口不仅可以定义对象, 还可以定义函数:

```tsx
// 声明接口
interface Core {
    (n:number, s:string):[number,string]
}

// 声明函数遵循接口定义
const core:Core = (a,b)=>{
    return [a,b];
}
```

#### 用接口定义类
先简单看下如何给类定义接口, 后面的课程具体讲类:

```tsx
// 定义
interface Animate {
    head:number;
    body:number;
    foot:number;
    eat(food:string):void;
    say(word:string):string;
}
```

```tsx
// implements
class Dog implements Animate{
    head=1;
    body=1;
    foot=1;
    eat(food){
        console.log(food);
    }
    say(word){
        return word;
    }
}
```

#### 交叉类型(&)
交叉类型是将多个类型合并为一个类型, 表示"并且"的关系,用&连接多个类型, 常用于对象合并:

```tsx
interface A {a:number};
interface B {b:string};

const a:A = {a:1};
const b:B = {b:'1'};
const ab:A&B = {...a,...b};
```

#### 联合类型(|)
交叉类型也是将多个类型合并为一个类型, 表示"或"的关系,用|连接多个类型:

```tsx
function setWidth(el: HTMLElement, width: string | number) {
    el.style.width = 'number' === typeof width ? `${width}px` : width;
}
```



## vue

###  VSCode代码片段

第一步，复制自己需要生成代码片段的代码； 第二步，[snippet-generator.app/](https://link.juejin.cn?target=https%3A%2F%2Fsnippet-generator.app%2F) 在该网站中生成代码片段； 第三步，在VSCode中配置代码片段；

#### vscode代码片段过程

设置 - 用户代码片段 - - 粘贴生成的代码片段

1. 可以直接打开现有代码片段
2. 可以选择创建全局代码片段
3. 可以选择创建当前文件夹的代码片段

#### 个人片段预设

#### v3

vue3+ts+scss 基础模板

```vue
{
  "vue3+ts+scss": {
    "prefix": "v3",
    "body": [
      "",
      "<template>",
      "  <div class=\"on\">",
      "  </div>",
      "</template>",
      "",
      "<script lang=\"ts\">",
      "import { defineComponent } from \"vue\";",
      "",
      "export default defineComponent({",
      "  name: \"\",",
      "  setup() {",
      "    return {",
      "    };",
      "  },",
      "});",
      "</script>",
      "",
      "<style lang=\"scss\" scoped>",
      "//@import \"./index.scss\";",
      "</style>"
    ],
    "description": "vue3+ts+scss"
  }
}
```

#### om

onMounted

```
{
  "onMounted-async": {
    "prefix": "om",
    "body": [
      "    onMounted(async () => {",
      "      ",
      "    });"
    ],
    "description": "onMounted-async"
  }
}
```



###  生命周期

```js
  //vue3--------------------------------------------------------------------

      // setup相当于vue2中的beforeCreate和created，并且在两者之前执行
      setup(){
        let test = ref('测试')

        // 挂载开始之前被调用
        onBeforeMount(()=>{
          console.log('onBeforeMount',test)
        })

        // 实例被挂载后调用，不会保证所有的子组件也被挂载完
        onMounted(()=>{
          console.log('onMounted',test)
        })

        // DOM更新前
        onBeforeUpdate(()=>{
          console.log('onBeforeUpdate',test)
        })

        // DOM更新后，不会保证所有的子组件也都一起被重绘
        onUpdated(()=>{
          console.log('onUpdated', test)
        })

        // 卸载组件实例之前，此时实例仍然是完全正常的
        onBeforeUnmount(()=>{
          console.log('onBeforeUnmount', test)
        })

        // 卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。
        onUnmounted(()=>{
          console.log('onUnmounted', test)
        })

        // 当捕获一个来自子孙组件的错误时被调用
        onErrorCaptured(()=>{
          console.log('onErrorCaptured',test)
        })

        // 跟踪虚拟 DOM 重新渲染时调用
        onRenderTracked(()=>{
          console.log('onRenderTracked',test)
        })

        // 当虚拟 DOM 重新渲染为 triggered.Similarly 为renderTracked，接收 debugger event 作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键。
        onRenderTriggered(()=>{
          console.log('onRenderTriggered',test)
        })

```



### 基础指令

#### 文本插值

```
{{ }}
```

#### v-once

- v-once 用于指定元素或者组件只渲染一次
- 当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过；
- 该指令可以用于性能优化；
- 如果是子节点，也是只会渲染一次

```html
<span v-once>这个将不会改变: {{ msg }}</span>
```

#### v-html

该指令后面往往会跟上一个string类型会将string的html解析出来并且进行渲染

```html
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```



#### v-if

```vue
<h1 v-if="awesome">Vue is awesome!</h1>
<h1 v-else>Oh no 😢</h1>
```

#### v-show

cbbaa tfftt只是简单地切换元素的 CSS property `display`。

```vue
<h1 v-show="ok">Hello!</h1>
```

#### v-for

- v-for的基本格式是 "item in 数组
- v-for也支持遍历对象，并且支持有一二三个参数

1. 一个参数： "value in object";
2. 二个参数： "(value, key) in object";
3. 三个参数： "(value, key, index) in object";

- v-for同时也支持数字的遍历

##### 基于一个数组来渲染一个列表

```vue
<ul id="example-1">
  <li v-for="item in items" :key="item.message">
    {{ item.message }}
  </li>
</ul>

```

```js
var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

可选的第二个参数，即当前项的索引。

```vue
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
```

###### 以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法：

```vue
<div v-for="item of items"></div>
```

#####   遍历对象

```vue
<ul id="v-for-object" class="demo">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>
```

```js
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
```

提供第二个的参数为 property 名称 (也就是键名)：

```vue
<div v-for="(value, name) in object">
  {{ name }}: {{ value }}
</div>
```

还可以用第三个参数作为索引：

```vue
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```

唯一key

```vue
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
```



#####  使用值范围

`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。

```vue
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
```

##### 在template使用

```vue
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
```

##### 自定义组件上使用

```vue
<my-component v-for="item in items" :key="item.id"></my-component>
```



##### for if同时使用

```vue
          <template v-for="(item, index) in ResultList" :key="index">
            <a @click="onk(item.path)" v-if="item.identity">
              {{item.title}}
            </a>
          </template>
```



#### v-bind

```vue
<a v-bind:href="url">...</a>
```



缩写

```vue
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a :[key]="url"> ... </a>
```

##### img绑定属性

```vue
<img v-bind:src="imgUrl"/>
```

##### 动态绑定

```vue
<a v-bind:[attributeName]="url"> ... </a>
```

> **v-bind 动态绑定class（对象语法）**
>
> - 可以通过{ }绑定一个类
> - 也可以通过判断，传入多个值
> - 和普通类同时存在，并不冲突
> - 如果过于复杂，可以放在一个methods或者computed中

##### 对象语法

```js

<template>
  <div id="snHeader">
      <el-menu
        :class="{active: isActive , line: isLine}"
      >
        <button @click="but()">a</button>
      </el-menu>
  </div>
</template>

<script>

  export default {
    name: "SnHeader",
    components: {},
    data() {
      return {
        active: 'el-menu',
        isActive: true,  //设置boolean值决定是否启用
        isLine: true
      };
    },

    methods: {
      but() {
        this.isActive = !this.isActive
        // return { active: this.isActive, line: this.isLine }
      },
    }
  };
</script>

<style lang="scss" scoped>
    
    .active {
      color: blue;
      @apply bg-red-400;
    }
  }

</style>

```

##### **数组语法**

```vue
<div id="app">
  <!-- 如果在[]数组里的元素加了引号，代表他是一个字符串，而不是引用一个变量 -->
  <h2 :class="[active,line]">{{massage}}</h2>
  <h2 :class="['active','line']">{{massage}}</h2>
</div>
```

#####  绑定style

```vue
<div id="app">
<!-- <h2 :style="{key(属性名):value(属性值)}">{{massage}}</h2> -->
  <!-- 这里要加' '要不然vue会去解析50px这个变量然后报错 -->
  <h2 :style="{fontSize: '50px'}">{{massage}}</h2>
  
  <!-- finalSize当成一个变量在使用 -->
  <h2 :style="{fontSize: finalSize}">{{massage}}</h2>

  <!-- 也可以拼接 -->
  <h2 :style="{fontSize: finalSize + 'px',color:finalColor}">{{massage}}</h2>

  <!-- 数组语法 -->
  <h2 :style="[baseStyle,baseStyle1]">{{massage}}</h2>
</div>

<body>
	<script src="../js/vue.js"></script>
	<script>
		const app = new Vue({
			el: "#app",
			data: {
				massage: "你好",
        finalSize: 100,
        finalColor: 'red',
        baseStyle:{color:'red'},
        baseStyle1:{fontSize:'75px'}
			}
		})
	</script>
</body>
```

#### v-on:click

##### 基础语法

```vue
<a v-on:click="doSomething">...</a>
```

动态的事件名绑定处理函数

```vue
<a v-on:[eventName]="doSomething"> ... </a>
```

缩写

```vue
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a @[event]="doSomething"> ... </a>
```

##### 事件修饰符

```vue
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a
    
    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

##### 按键修饰符

```vue
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```

##### .exact 修饰符

修饰符允许你控制由精确的系统修饰符组合触发的事件

```vue
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button v-on:click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button v-on:click.exact="onClick">A</button>
```

##### 鼠标按钮修饰符

```
.left
.right
.middle
```

#### v-model

`v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。

##### 文本

```vue
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```

##### 多行文本

```vue
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
```

##### 复选框

单个复选框，绑定到布尔值：

```vue
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
```

多个复选框，绑定到同一个数组：

```vue
<div id='example-3'>
  <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
  <label for="jack">Jack</label>
  <input type="checkbox" id="john" value="John" v-model="checkedNames">
  <label for="john">John</label>
  <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
  <label for="mike">Mike</label>
  <br>
  <span>Checked names: {{ checkedNames }}</span>
</div>
```

```js
new Vue({
  el: '#example-3',
  data: {
    checkedNames: []
  }
})
```

单选按钮

```vue
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br>
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>
```

```js
new Vue({
  el: '#example-4',
  data: {
    picked: ''
  }
})
```

##### 选择框

单选时：

```vue
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>
```

```js
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
```

多选时 (绑定到一个数组)：

```vue
<div id="example-6">
  <select v-model="selected" multiple style="width: 50px;">
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <br>
  <span>Selected: {{ selected }}</span>
</div>
```

```js
new Vue({
  el: '#example-6',
  data: {
    selected: []
  }
})
```

用 `v-for` 渲染的动态选项：

```vue
<select v-model="selected">
  <option v-for="option in options" v-bind:value="option.value">
    {{ option.text }}
  </option>
</select>
<span>Selected: {{ selected }}</span>
```

```js
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})
```

##### 值绑定

```vue
<!-- 当选中时，`picked` 为字符串 "a" -->
<input type="radio" v-model="picked" value="a">

<!-- `toggle` 为 true 或 false -->
<input type="checkbox" v-model="toggle">

<!-- 当选中第一个选项时，`selected` 为字符串 "abc" -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>
```

#### v-text

都是用于将数据显示在界面中，但是通常只接受一个string类型

用于更新元素的 textContent

```vue
<div v-text="message"></div>
<div v-text="msg"></div> 等价于 <div>{{msg}}</div>
```

#### v-pre

- v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签
- 跳过不需要编译的节点，加快编译的速度

```html
<h2 v-pre>{{massage}}</h2> <!-- {{massage}} -->
```

#### v-cloak

保持在元素上直到关联组件实例结束编译； 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实 例准备完毕。

#### watch

侦听的是data中的数据 默认情况下侦听data数据本身的改变（内部侦听的改变是不能侦听的） 如：侦听data中的 msg 的变化，由`msg: { name: "wx", age: 20 }`改变成`msg: { name: "wxwx", age: 20 }`是侦听不到`msg.name`的变化的。

需要侦听到内部的变化需要做如下处理: 对msg做深度侦听，不在是写成函数形式，而写成对象形式

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("侦听msg内部数据是不是变化了", msg.name);
      },
      deep: true, // 深度侦听
    }
}
methods: {
    changeMsgName() {
      this.msg.name = "wxwx"
    }
}
复制代码
```

可执行了以上代码的console，所以msg内部数据的改变有被侦听到。

watch还可以在页面渲染的时候对需要立即执行的data数据进行侦听，需要在对象中加上一个 immediate 就行

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("newInfo", newInfo, "oldInfo", oldInfo)
      },
      deep: true, // 深度侦听
      immediate: true // 立即执行
    }
}
```

页面渲染时会有以上console的打印，但是 oldInfo 是 undefined。

注意：当去改变data数据中对象的内部值时，newInfo 和 oldInfo 的值都是改变后的值

通过一下方式可以拿到oldInfo（旧值）

```js
watch: {
    "msg.name": function(newName, oldName) {
      console.log(newName, oldName);
    },
},
```

以上console打印 wx wxx

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("newValue:", newInfo.name, "oldValue:", oldInfo.name);
      },
      deep: true, // 深度侦听
    }
},
methods: {
    changeMsgName() {
      this.msg.name = "wxwx";
    },
}
```

以上console输出的 newInfo 和 oldInfo 都是 "wxwx"

#### watch 实现侦听的其他方式

1. 只侦听某个对象中的值

```js
watch: {
    "msg.name": function(newName, oldName) {
      console.log(newName, oldName);
    },
},
```

1. 使用this.$watch来侦听

```js
created() {
    this.$watch("msg", function(newInfo, oldInfo) {
      console.log(newInfo, oldInfo);
    }, {
      deep: true,
      immediate: true
    })
}
```




### 组件基础

##### 基本示例：

```js
// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})
```

创建的 Vue 根实例中，把这个组件作为自定义元素来使用：

```vue
<div id="components-demo">
  <button-counter></button-counter>
</div>

new Vue({ el: '#components-demo' })
```

##### 组件名

```js
Vue.component('my-component-name', { /* ... */ })
```

这些组件是**全局注册的**。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (`new Vue`) 的模板中

##### 局部注册

通过一个普通的 JavaScript 对象来定义组件：

```js
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
```

然后在 `components` 选项中定义你想要使用的组件：

```js
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```

##### 在模块中局部注册

```js
import ComponentA from './ComponentA'
import ComponentC from './ComponentC'

export default {
  components: {
    ComponentA,
    ComponentC
  },
  // ...
}
```

##### 自动化全局注册

可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为[基础组件](https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐)，它们会在各个组件中被频繁的用到。

```js
import Vue from 'vue'
import upperFirst from 'lodash/upperFirst'
import camelCase from 'lodash/camelCase'

const requireComponent = require.context(
  // 其组件目录的相对路径
  './components',
  // 是否查询其子目录
  false,
  // 匹配基础组件文件名的正则表达式
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName => {
  // 获取组件配置
  const componentConfig = requireComponent(fileName)

  // 获取组件的 PascalCase 命名
  const componentName = upperFirst(
    camelCase(
      // 获取和目录深度无关的文件名
      fileName
        .split('/')
        .pop()
        .replace(/\.\w+$/, '')
    )
  )

  // 全局注册组件
  Vue.component(
    componentName,
    // 如果这个组件选项是通过 `export default` 导出的，
    // 那么就会优先使用 `.default`，
    // 否则回退到使用模块的根。
    componentConfig.default || componentConfig
  )
})
```

**全局注册的行为必须在根 Vue 实例 (通过 `new Vue`) 创建之前发生**

##### 通过 Prop 向子组件传递数据

Prop 是你可以在组件上注册的一些自定义 attribute。为了给博文组件传递内容

创建子组件

BlogInformation.vue

```vue
<!--
 * @Author: 站点信息模块
 * @Date: 2021-08-17 11:54:18
 * @LastEditTime: 2021-08-17 12:19:36
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \blogs-s\src\views\common\SidebarModule\BlogInformation.vue
-->
<template>
  <div class="index-si-count">
        <div class="index-si-count-frame-title">文章数量:</div>
        <div class="index-si-count-frame-text">{{ ArticleCount }} 篇</div>
        <div class="index-si-count-frame-title">总字段数:</div>
        <div class="index-si-count-frame-text">{{ TextCount }} 字</div>
        <div class="index-si-count-frame-title">总访问量:</div>
        <div class="index-si-count-frame-text">{{ ReadCount }} ℃</div>
        <div class="index-si-count-frame-title">最后更新:</div>
        <div class="index-si-count-frame-text">{{ Articledata }}</div>
  </div>
</template>

<script>
  export default {
    props: ['ArticleCount', 'TextCount', 'ReadCount', 'Articledata'],
  }
</script>

```

```vue
      <!-- 站点统计框 -->
      <blog-information
        :ArticleCount="ArticleCount"
        :TextCount="textCount"
        :ReadCount="readCount"
        :Articledata="articledata"
      ></blog-information>
```

数组：

```js
<!--
 * @Author: your name
 * @Date: 2021-08-30 15:38:59
 * @LastEditTime: 2021-08-30 16:13:16
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \blogs-s\src\views\common\SidebarModule\BlogTag.vue
-->
<template>
  <div class="index-si-tag-div">
    <div
      class="transition duration-500 ease-in-out transform index-si-tag-text hover: hover:scale-110 hover:text-red-600"
    >
      <a>{{ title }}</a>
    </div>
  </div>
</template>

<script>
  export default {
    props: ['title'],
  }
</script>

<style lang="scss" scoped>
  .index-si-tag-div {
    @apply inline-flex;

    .index-si-tag-text {
      @apply flex-1 p-1;
      @apply text-gray-700 text-sm text-center m-1 bg-gray-100 rounded-sm;
    }
  }
</style>

```

并想要为每篇博文渲染一个组件：

```html
      <!-- 标签框内容 -->
      <div class="index-si-tag">
        <div class="index-si-tag-title">标签</div>
        <blog-tag
          v-for="Labeslss in Labels"
          :key="Labeslss.labelId"
          :title=" Labeslss.labelName"
          @click="TagSkip(Labeslss.labelId)"
        ></blog-tag>
      </div>
```



### 数组方法

```vue
  <script>
    const app = new Vue({
      el: "#app",
      data: {
        letters: ['A', 'C', 'B', 'D', 'E']
      },
      methods: {
        btnClick() {
          // 1.push()   在数组最后添加元素
          this.letters.push('aaa','bbb')

          // 2.pop()      在数组最后删除一个元素
          this.letters.pop();

          // 3.shift()   删除在数组第一个元素
          this.letters.shift();

          // 4.unshift() 在数组最前面添加元素
          this.letters.unshift('ddd','ddd');

          // 5.splice()   删除/插入/替换元素
          // 删除元素: 第一参数传入你从第几个元素开始删除，第二参数传入你要删除的几个元素(如果没有传,就删除后面所有元素)
          // 插入元素: 第二个传入0，后面跟上要添加的值
          // 替换元素: 第二参数传入你要删除元素，后面追加你要写入的元素完成替换
          this.letters.splice(1,3,'m','n','l')

          // 6.sort()     排序
          this.letters.sort()

          // 7.reverse()  反转
          this.letters.reverse()

          // 注意：通过索引值直接来修改数组中的元素 不是响应式
          // this.letters[0]='bbbbbbbbbbbb'
          // set(要修改的对象，索引值，修改后的值)
          Vue.set(this.letters,0,'bbbbbb')
        }
      }
    })

    // 扩展知识：可变参数
    // function sum(...sum){
    //   console.log(sum);
    // }
    // sum(11,223,44,56,77,889,9,1)
  </script>

```



### scss

#### 封装调用

```js
 //vue
<style lang="scss" >
  @import "./scss/indexTitle.scss";
</style>

 //indexTitle.scss
@import "../../assets/sass/com";
@import "../../assets/sass/uitl";
.IndexTitle {
  @include initialize($w, null, $Text_height, null, $ml, null, null);
}
```



### vue.config.js

```js
const path = require('path')

function resolve(dir) {
  return path.join(__dirname, dir)
}
const webpack = require("webpack");
module.exports = {
  // 基本路径
  publicPath: "./",
  // 输出文件目录
  outputDir: 'dist',
  // webpack-dev-server 相关配置
  devServer: {
    // port: 8888,
    // ...
  },

  lintOnSave: true,
  runtimeCompiler: true, //加入内容
  chainWebpack: config => {
    config.resolve.alias
      .set('@', resolve('src'))
      .set('assets', resolve('src/assets'))
      .set('components', resolve('src/components'))
      .set('lib', resolve('src/lib'))
  }

}
```

### transitiond过度动画

```vue
<transition :name="transitionName" mode="out-in">
      <router-view class="home-router"></router-view>
    </transition>
```

```js
<script>
export default {
  name: 'App',
  data () {
    return {
      transitionName: 'slide-right'
    }
  },
  methods: {
  },
}
</script>
```

```css
<style>
  .home-router {
    transition: all 0.5s ease;
  }
   /*过度前*/
   .slide-left-enter,
  .slide-right-leave-active {
    opacity: 0;
    -webkit-transform: translate(0, 0);
    transform: translate(0, 0);
  }
  /*后*/
  .slide-left-leave-active,
  .slide-right-enter {
    opacity: 0;
    -webkit-transform: translate(-100%, 0);
    transform: translate(-100% 0);
  }
</style>
```

### 给封装好的组件加click事件

```vue
<MenuItem name="/" to="/" @click.native="handclick(1)">我的项目</MenuItem>
```

### 回到顶部功能

```vue
 <div id="backtop">
            <p @click="backtop">
                <svg class="icon" aria-hidden="true">
                    <use xlink:href="#icon-globaltop"></use>
                </svg>
            </p>
        </div>
```

```js
<script>
  export default {
    mounted() {
       window.addEventListener("scroll",this.showbtn,true);
    },
    methods: {
        // 显示回到顶部按钮
       showbtn(){
          let that = this;
          let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
          that.scrollTop = scrollTop
       },
      /**
        * 回到顶部功能实现过程：
        * 1. 获取页面当前距离顶部的滚动距离（虽然IE不常用了，但还是需要考虑一下兼容性的）
        * 2. 计算出每次向上移动的距离，用负的滚动距离除以5，因为滚动的距离是一个正数，想向上移动就是做一个减法
        * 3. 用当前距离加上计算出的距离，然后赋值给当前距离，就可以达到向上移动的效果
        * 4. 最后记得在移动到顶部时，清除定时器
      */
      backtop(){
          var timer = setInterval(function(){
            let osTop = document.documentElement.scrollTop || document.body.scrollTop;
            let ispeed = Math.floor(-osTop / 5); 
            document.documentElement.scrollTop = document.body.scrollTop = osTop + ispeed;
            this.isTop = true;
            if(osTop === 0){
              clearInterval(timer);
            }
          },30)
      }
    }
  }
</script>
```



## vue-router

### 安装路由

```
npm install vue-router
```

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)
```

#### 路由封装

#### 1.main.js

```js
import router from '@/router'
import request from '@/network/request'

new Vue({
  router,//注册路由
  render: h => h(App),
}).$mount('#app')
```

#### 2.建文件夹router

**index.js**

```js
import Vue from 'vue'
import Router from 'vue-router'

const Index = () => import('@/components/Index') // 路由懒
Vue.use(Router)
const routes = [{ // 映射路由
    path: '/',
    redirect: '/Index' // 重定向默认值
  },
  {
    path: '/Index',
    component: Index,
    meta: {
      title: 'Index'
    }
  }
]
const router = new Router({ // 创建路由对象实例
  mode: 'history',
  routes

})
// 解决重复点击链接出现错误
const originalPush = Router.prototype.push
Router.prototype.push = function push(location) {
  return originalPush.call(this, location).catch(err => err)
}
export default router // 将对象 传递到vue实例
```



### 跳转

### 导入使用

```tsx
import { useRouter } from "vue-router";

const router = useRouter();

           router.push({
              path: num,
              query: {
                t: +new Date()
              }
            })
```



#### 1.无参跳转

```js
this.$router.push('/Index')
```

#### 2.带参数跳转

```js
this.$router.push({ path: '/Index-text', query: { id: cid } })

 await router.push({
          path: "/IndexText",
          query: {
            id: id,
          },
        });
```

#### 2.1页面获取参数调用

```js
data () {
    return {
      id: this.$route.query.id,
    }
    
url: '/api/Contents/AsyGetTestID?id=' + this.id
```

####  点击刷新当前路由

```js
   this.$router.push({
     path: "./SnNavigation",
     query: {
       t: +new Date() //保证每次点击路由的query项都是不一样的，确保会重新刷新view
      }
    })
```

#### 跳转新窗口

```ts
       const { href } = await router.resolve({
          path: "/IndexText",
          query: { id: id }
        });
        window.open(href, '_blank');
```



### vuex

#### vue3 中调用

```ts
 import { useStore } from "vuex";
 
 setup() {
      const stores = useStore();
      stores.state.SetPage
      }
```



## axios

### 安装

```vue
npm install --save axios vue-axios
```

main.js 导入

```js
import request from '@/network/request' //封装的js

new Vue({
  router,
  request, //注册axios
  render: h => h(App),
}).$mount('#app')
```

### 封装公共实例

建network 文件夹 下新建 request.js

```js
 import axios from 'axios'
 export function request(config) {
   // 1创建axios实例
   const intstance = axios.create({
     baseURL: 'https://localhost:44398/',
     timeout: 5000
     // contentType: 'application/json;charset=UTF-8',
     // dataType: 'json'
   })
   // 1.axios拦截器
   intstance.interceptors.request.use(config => {
     return config
   }, er => {
   })

   // 1.axios响应拦截拦截
   intstance.interceptors.response.use(res => {
     return res
   }, er => {
   })
   return intstance(config)
 }
 export default request
```

### 调用

在vue的页面导入

```js
import Headers from './Headers'
```

```js
methods: {
    AsyGetTest () {
      request({
        url: '/api/Contents/AsyGetTest'
      }).then(res => {
        // 只获取0到4之间的数据
        this.newinfo = res.data.slice(0, 4);
        console.log(this.newinfo)
      }).catch((e) => {
        console.log('获取数据失败');
      });
    }
  }
```

展示接口内容

```js
v-for="info in newinfo" :key="info.cid"

{{ info.title }}
```

## mavon-editor



### 安装引用

```
$ npm install mavon-editor --save
```

```js
// 全局注册
    // import with ES6
    import Vue from 'vue'
    import mavonEditor from 'mavon-editor'
    import 'mavon-editor/dist/css/index.css'
    // use
    Vue.use(mavonEditor)
    new Vue({
        'el': '#main',
        data() {
            return { value: '' }
        }
    })
```

### 调用

```vue
<div id="main">
    <mavon-editor v-model="value"/>
</div>
```

### 获取数据预览

```vue
<template>
  <div class="editor-text">
    <mavon-editor
      v-model="newinfo.text"
      :subfield="false"
      :boxShadow="false"
      defaultOpen="preview"
      :toolbarsFlag="false"
    />
  </div>
</template>
```

### highlight 高亮

1.安装

```js
npm i highlight.js
```

2.组件页面 引入

```js
import 'highlight.js/styles/googlecode.css'
import hljs from 'highlight.js' //导入代码高亮文件
```

3.methods 建方法

```js
async highlighthandle(){
                await hljs;
                let highlight = document.querySelectorAll('code,pre');
                highlight.forEach((block)=>{
                    hljs.highlightBlock(block);
                })
            },
```

4.钩子

```js
 updated() {
            this.highlighthandle()
        },
```

5.编译器调用

```vue
<mavon-editor
                    :toolbars="markdownOption"
                    :subfield="false"
                    :boxShadow="false"
                    :ishljs="true"
                    defaultOpen="preview"
                    :toolbarsFlag="false"
                    :navigation="true"
                    v-model="newinfo.text"
            />
```





## 字体图标

一.首先下载好的iconfont.js放到assets/icon

二.引入css 文件
        在同级目录下创建一个icon.css文件

```css
.icon {
    width: 1em;
    height: 1em;
    vertical-align: -0.15em;
    fill: currentColor;
    overflow: hidden;
}
```

main.js导入

```js
import './assets/icon/fonts/iconfont.js'

import './assets/icon/icon.css'
```

引用

```vue
 <svg class="icon" aria-hidden="true">
   <use xlink:href="#icon-bingqilinqiu"></use>
  </svg>
```



## 时间线组件

安装

```
yarn add vue-light-timeline
npm i vue-light-timeline
```

导入

```js
import Vue from 'vue';
import LightTimeline from 'vue-light-timeline';

Vue.use(LightTimeline);
```

调用

```vue
<template>
  <light-timeline :items='items'></light-timeline>
</template>
<script>
const theme = 'red';
export default {
  data () {
    return {
      items: [
        {
          tag: '2018-01-12',
          content: 'hallo'
        },
        {
          tag: '2018-01-13',
          color: '#dcdcdc',
          type: 'circle',
          content: 'world'
        },
        {
          type: 'star',
          tag: '2018-01-14',
          htmlMode: true,
          content: `<div style="color: ${theme};"> =v = </div>`
        }
      ]
    }
  }
}
</script>
```

## 背景粒子组件

### 如何使用

```
npm install vue-particles --save-dev
```

### Main.js文件

```
import Vue from 'vue'
import VueParticles from 'vue-particles'
Vue.use(VueParticles)
```

### 简单示例

```html
<template>
    <div id="app">
      <vue-particles color="#dedede"></vue-particles>
    </div>
 </template>
```

### 完整示例

```html
<template>
    <div id="app">
         <vue-particles class="bgys"
                       color="#dedede" 颗粒颜色
                       :particleOpacity="0.7" 粒子不透明度
                       :particlesNumber="60" 颗粒数量
                       shapeType="circle" 可用的形状类
                       :particleSize="4" 单颗粒大小
                       linesColor="#dedede" 线条颜色
                       :linesWidth="1" 线宽
                       :lineLinked="true"  启用线
                       :lineOpacity="0.4" 线不透明度
                       :linesDistance="150 行距
                       :moveSpeed="3"   粒子速度
                       :hoverEffect="true"  启用悬停效果
                       hoverMode="grab"  可用的悬停模式：“抓取”，“排斥”，“气泡”
                       :clickEffect="true"  启用点击效果
                       clickMode="push"  可用的点击模式：“推”，“删除”，“排斥”，“气泡”
        >
        </vue-particles>
    </div>
 </template>

bgys{
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
        }
```















## sass

### `Ruby`

window下安装SASS首先需要安装`Ruby`，先从官网[下载Ruby](http://rubyinstaller.org/downloads)并安装。

检测是否安装成功

```css
ruby -v
```

### sass安装

```css
//安装如下(如mac安装遇到权限问题需加 sudo gem install sass)
gem install sass
gem install compass
```

安装完成之后，你应该通过运行下面的命令来确认应用已经正确地安装到了电脑中：

```scss
sass -v
compass -v

//更新sass
gem update sass

//查看sass版本
sass -v

//查看sass帮助
sass -h
```



### vue安装sass依赖

```scss
npm install --save-dev sass-loader 

/ /sass-loader依赖于node-sass

npm install --save-dev node-sass 
```

### Scss语法

#### 声明变量

变量用来存储需要在CSS中复用的信息，如颜色和字体,通过$符号去声明一个变量。

```scss
$name
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 `!global` 声明：

```scss
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```



#### 插值语句 `#{}`

通过 `#{}` 插值语句可以在选择器或属性名中使用变量：

```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```

编译为

```css
p.foo {
  border-color: blue; }
```

#### 嵌套

```css
.container{
  .left-area{
    ...
  }
}
```

#### 父选择器(&)

`&` 在 scss中表示自身的意思。

```css
.container{
  &.right-area{
   background-color : #0000
 }
}
```

####  Mixin(混合)

用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。

```css
@mixin button {  
    font-size: 1em;  
    padding: 0.5em 1.0em;  
    text-decoration: none;  
    color: #fff;  
}
.button-green {  
    @include button;  
    background-color: green;  
}

@mixin border-radius($radius) {
          border-radius: $radius;
      -ms-border-radius: $radius;
     -moz-border-radius: $radius;
  -webkit-border-radius: $radius;
}

.box {
  @include border-radius(10px);
}
```

#### 继承

继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码

```scss
// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。
%message-common {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

.message {
  @extend %message-common;
}

.success {
  @extend %message-common;
  border-color: green;
}

```

#### 函数指令

Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用：

```scss
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar { width: grid-width(5); }
```

编译为

```css
#sidebar {
  width: 240px; }
```

与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 `@return` 输出结果。

自定义的函数也可以使用关键词参数，上面的例子还可以这样写：

```scss
#sidebar { width: grid-width($n: 5); }
```

建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。

### 技巧

#### 居中

使用 Flexbox 实现子元素的居中效果，只需三行代码：

```scss
@mixin center-children {
    display: flex;
    justify-content: center;
    align-items: center;
}
```

由于 Flexbox 还是比较新的属性，那么添加上相关的浏览器前缀的话，会让它拥有更广泛的兼容性。

```scss
.parent {
    @include center-children;
}
```





##  Tailwind CSS



### 安装 Tailwind

1.安装

```css
# Using npm
npm install tailwindcss

# Using Yarn
yarn add tailwindcss
```

2.新建 `tailwind.css`,在 `src/assets` 新建 `css` 文件夹

`tailwind.css` 文件中，添加如下内容:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

3.main.js` 引入 `import "./assets/css/tailwind.css"

```css
import "./assets/css/tailwind.css"
```

4.创建 `Tailwind` 配置文件

```css
npx tailwind init
or
npx tailwind init --full
```

5.新建 `postcss.config.js` 文件

```js
const purgecss = require('@fullhuman/postcss-purgecss')({
    content: [
      './src/**/*.html',
      './src/**/*.vue',
      './src/**/*.jsx',
    ],
    // Include any special characters you're using in this regular expression
    defaultExtractor: content => content.match(/[\w-/:]+(?<!:)/g) || []
  })
 
module.exports = {
    plugins: [
      require('tailwindcss'),
      require('autoprefixer'),
      ...process.env.NODE_ENV === 'production'
      ? [purgecss]
      : []
    ]
  }
```

### PostCSS 常用插件

#### Autoprefixer

其作用是为 CSS 中的属性添加浏览器特定的前缀。由于 CSS 规范的制定和完善一般需要花费比较长的时间，浏览器厂商在实现某个 CSS 新功能时，会使用特定的浏览器前缀来作为正式规范版本之前的实验性实现。比如 Webkit 核心的浏览器使用-webkit-，微软的 IE 使用-ms-。为了兼容不同浏览器的不同版本，在编写 CSS 样式规则声明时通常需要添加额外的带前缀的属性。这是一项繁琐而无趣的工作。Autoprefixer 可以自动的完成这项工作。Autoprefixer 可以根据需要指定支持的浏览器类型和版本，自动添加所需的带前缀的属性声明。开发人员在编写 CSS 时只需要使用 CSS 规范中的标准属性名即可。

```
npm install autoprefixer
```



#### PstCSS 整合多个 CSS 插件

```
# npm
npm install postcss-import

# yarn
yarn add postcss-import
```

2. postcss.config.js

```
  require('postcss-import'),
```

导入

```js
/*postcss-import足够聪明，可以node_modules自动在文件夹中查找文件
，因此您无需提供完整路径- "tailwindcss/base"例如，就足够了。*/
@import "base";
@import "common";
@import "tailwindcss/components";
@import "tailwindcss/utilities";
```



### 字体排版

####  Font Family

```css
.font-sans
font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";

.font-serif
font-family: Georgia, Cambria, "Times New Roman", Times, serif;

.font-mono	
font-family: Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
```

**1.调用**

```vue
<p class="font-sans text-lg text-gray-800 text-center">
  I'm a sans-serif paragraph.
</p>
```

2.响应式切换

```vue
<p class="font-sans sm:font-serif md:font-mono lg:font-sans xl:font-serif">
  <!-- ... -->
</p>
```

#### 字体Size

|            |                      |
| ---------- | -------------------- |
| .text-xs   | font-size: .75rem;   |
| .text-sm   | font-size: .875rem;  |
| .text-base | font-size: 1rem;     |
| .text-lg   | font-size: 1.125rem; |
| .text-xl   | font-size: 1.25rem;  |
| .text-2xl  | font-size: 1.5rem;   |
| .text-3xl  | font-size: 1.875rem; |
| .text-4xl  | font-size: 2.25rem;  |
| .text-5xl  | font-size: 3rem;     |
| .text-6xl  | font-size: 4rem;     |

##### 响应式切换

```vue
<p class="text-base sm:text-lg md:text-xl lg:text-2xl xl:text-3xl ...">The quick brown fox jumped over the lazy dog.</p>
```

#### 字体平滑

```css
.antialiased	
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;

.subpixel-antialiased	
-webkit-font-smoothing: auto;
-moz-osx-font-smoothing: auto;
```



1.调用

```vue
<p class="subpixel-antialiased ...">The quick brown fox ...</p>
```

2.响应式切换

```vue
<p class="antialiased sm:subpixel-antialiased md:antialiased lg:subpixel-antialiased xl:antialiased ...">
  The quick brown fox jumped over the lazy dog.
</p>
```

#### Font Style



```css
.italic	font-style: italic;
.not-italic	font-style: normal;
```

1.调用

```html
<p class="not-italic ...">The quick brown fox ...</p>
```

```html
<p class="italic ...">The quick brown fox ...</p>
```

2.响应式切换

```vue
<p class="italic sm:not-italic md:italic lg:not-italic xl:italic ...">
  The quick brown fox jumped over the lazy dog.
</p>
```

#### 粗细 Weight

|                 |                   |
| :-------------- | ----------------- |
| .font-hairline  | font-weight: 100; |
| .font-thin      | font-weight: 200; |
| .font-light     | font-weight: 300; |
| .font-normal    | font-weight: 400; |
| .font-medium    | font-weight: 500; |
| .font-semibold  | font-weight: 600; |
| .font-bold      | font-weight: 700; |
| .font-extrabold | font-weight: 800; |
| .font-black     | font-weight: 900; |

1.调用

```html
<p class="font-hairline ...">The quick brown fox ...</p>
```

2.响应式切换

```vue
<p class="font-normal sm:font-bold md:font-thin lg:font-semibold xl:font-black ...">The quick brown fox jumped over the lazy dog.</p>
```



#### 字间距

|                   |                           |
| ----------------- | ------------------------- |
| .tracking-tighter | letter-spacing: -0.05em;  |
| .tracking-tight   | letter-spacing: -0.025em; |
| .tracking-normal  | letter-spacing: 0;        |
| .tracking-wide    | letter-spacing: 0.025em;  |
| .tracking-wider   | letter-spacing: 0.05em;   |
| .tracking-widest  | letter-spacing: 0.1em;    |

1.调用

```html
<p class="tracking-tighter ...">The quick brown fox ...</p>
```

2.响应式切换

```vue
<p class="tracking-tight sm:tracking-normal md:tracking-wide lg:tracking-normal xl:tracking-tight ...">The quick brown fox jumped over the lazy dog.</p>
```



#### 行高

| Class            | Properties            |
| ---------------- | --------------------- |
| .leading-none    | line-height: 1;       |
| .leading-tight   | line-height: 1.25;    |
| .leading-snug    | line-height: 1.375;   |
| .leading-normal  | line-height: 1.5;     |
| .leading-relaxed | line-height: 1.625;   |
| .leading-loose   | line-height: 2;       |
| .leading-3       | line-height: .75rem;  |
| .leading-4       | line-height: 1rem;    |
| .leading-5       | line-height: 1.25rem; |
| .leading-6       | line-height: 1.5rem;  |
| .leading-7       | line-height: 1.75rem; |
| .leading-8       | line-height: 2rem;    |
| .leading-9       | line-height: 2.25rem; |
| .leading-10      | line-height: 2.5rem;  |

1.调用

```html
<p class="leading-none ...">Lorem ipsum dolor sit amet ...</p>
```

2.响应式切换

```vue
<p class="leading-none sm:leading-tight md:leading-normal lg:leading-relaxed xl:leading-loose ...">Lorem ipsum dolor sit amet ...</p>
```



#### 列表样式

| Class         | Properties                |
| ------------- | ------------------------- |
| .list-none    | list-style-type: none;    |
| .list-disc    | list-style-type: disc;    |
| .list-decimal | list-style-type: decimal; |



1.调用

```html
<ul class="list-disc">
  <li>Lorem ipsum dolor sit amet, consectetur adipisicing elit</li>
  ...
</ul>

<ol class="list-decimal">
  <li>Lorem ipsum dolor sit amet, consectetur adipisicing elit</li>
  ...
</ol>

<ul>
  <li>Lorem ipsum dolor sit amet, consectetur adipisicing elit</li>
  ...
</ul>
```

2.响应式切换

```vue
<ul class="list-none sm:list-disc md:list-decimal lg:list-disc xl:list-none">
  <li>Lorem ipsum dolor sit amet, consectetur adipisicing elit</li>
  <li>Assumenda, quia temporibus eveniet a libero incidunt suscipit</li>
  <li>Quidem, ipsam illum quis sed voluptatum quae eum fugit earum</li>
</ul>
```

####  列表样式位置

| Class         | Properties                    |
| ------------- | ----------------------------- |
| .list-inside  | list-style-position: inside;  |
| .list-outside | list-style-position: outside; |

1.调用

```html
<ul class="list-inside bg-gray-200 ...">
  <li>Lorem ipsum dolor sit amet, consectetur adipisicing elit</li>
  ...
</ul>

<ul class="list-outside bg-gray-200 ...">
  <li>Lorem ipsum dolor sit amet, consectetur adipisicing elit</li>
  ...
</ul>
```

2.响应式切换

```html
<ul class="list-inside sm:list-outside md:list-inside lg:list-outside xl:list-inside">
  <li>Lorem ipsum dolor sit amet, consectetur adipisicing elit</li>
  <li>Assumenda, quia temporibus eveniet a libero incidunt suscipit</li>
  <li>Quidem, ipsam illum quis sed voluptatum quae eum fugit earum</li>
</ul>
```



#### 文本对齐

| Class         | Properties           |
| ------------- | -------------------- |
| .text-left    | text-align: left;    |
| .text-center  | text-align: center;  |
| .text-right   | text-align: right;   |
| .text-justify | text-align: justify; |

1.调用

```html
<p class="text-left ...">Lorem ipsum dolor sit amet ...</p>
<p class="text-center ...">Lorem ipsum dolor sit amet ...</p>
<p class="text-right ...">Lorem ipsum dolor sit amet ...</p>
<p class="text-justify ...">Lorem ipsum dolor sit amet ...</p>
```

2.响应式切换

```html
<p class="text-left sm:text-center md:text-right lg:text-justify xl:text-center ...">Lorem ipsum dolor sit amet ...</p>
```



#### 文字透明

| Class             | Properties            |
| ----------------- | --------------------- |
| .text-opacity-0   | --text-opacity: 0;    |
| .text-opacity-25  | --text-opacity: 0.25; |
| .text-opacity-50  | --text-opacity: 0.5;  |
| .text-opacity-75  | --text-opacity: 0.75; |
| .text-opacity-100 | --text-opacity: 1;    |

1.调用

```html
<p class="text-purple-700 text-opacity-100">The quick brown fox ...</p>
<p class="text-purple-700 text-opacity-75">The quick brown fox ...</p>
<p class="text-purple-700 text-opacity-50">The quick brown fox ...</p>
<p class="text-purple-700 text-opacity-25">The quick brown fox ...</p>
<p class="text-purple-700 text-opacity-0">The quick brown fox ...</p>
```

2.响应式切换

```html
<div class="text-blue-500 text-opacity-75 md:text-opacity-50">   <!-- ... --> </div>
```



#### 文字装饰

| Class         | Properties                     |
| ------------- | ------------------------------ |
| .underline    | text-decoration: underline;    |
| .line-through | text-decoration: line-through; |
| .no-underline | text-decoration: none;         |



1.调用

```html
<!--下划线-->
<p class="underline ...">The quick brown fox ...</p>
<!--中划线-->
<p class="line-through ...">The quick brown fox ...</p>
<!--无下划线-->
<a href="#" class="no-underline ...">Link with no underline</a>
```

2.响应式切换

```html
<p class="underline sm:no-underline md:line-through lg:underline xl:no-underline ...">
  The quick brown fox jumped over the lazy dog.
</p>

<a href="#" class="... md:no-underline md:hover:underline ...">Link</a>
```

3.Hover

```html
<a href="#hover" class="no-underline hover:underline text-blue-500 text-lg">Link</a>
```

4.焦点 Focus

```html
<input class="focus:underline ..." value="Focus me">
```

```html
<input class="md:focus:underline ..." value="Focus me">
```



#### 大小写

| Class        | Properties                  |
| ------------ | --------------------------- |
| .uppercase   | text-transform: uppercase;  |
| .lowercase   | text-transform: lowercase;  |
| .capitalize  | text-transform: capitalize; |
| .normal-case | text-transform: none;       |

1.调用

```html
<!--正常情况-->
<p class="normal-case ...">The quick brown fox ...</p>
<!--大写-->
<p class="uppercase ...">The quick brown fox ...</p>
<!--小写-->
<p class="lowercase ...">The quick brown fox ...</p>
<!--大小写-->
<p class="capitalize ...">The quick brown fox ...</p>
```

2.响应式切换

```html
<p class="uppercase sm:lowercase md:capitalize lg:normal-case xl:uppercase ...">
  The quick brown fox jumped over the lazy dog.
</p>
```



#### 垂直对齐

| Class              | Properties                   |
| ------------------ | ---------------------------- |
| .align-baseline    | vertical-align: baseline;    |
| .align-top         | vertical-align: top;         |
| .align-middle      | vertical-align: middle;      |
| .align-bottom      | vertical-align: bottom;      |
| .align-text-top    | vertical-align: text-top;    |
| .align-text-bottom | vertical-align: text-bottom; |

1.调用



```html
基准线
<span class="inline-block align-baseline ...">...</span>
最佳
<span class="inline-block align-top ...">...</span>
中间
<span class="inline-block align-middle ...">...</span>
底部
<span class="inline-block align-bottom ...">...</span>
文字顶部
<span class="inline-block align-text-top ...">...</span>
文字底部
<span class="inline-block align-text-bottom ...">...</span>
```

2.响应式切换

```html
<div class="leading-none relative">
  <span class="align-top sm:align-middle md:align-bottom lg:align-text-top xl:align-text-bottom ...">...</span>
  <span>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</span>
</div>
```

#### 空格

| Class                | Properties             |
| -------------------- | ---------------------- |
| .whitespace-normal   | white-space: normal;   |
| .whitespace-no-wrap  | white-space: nowrap;   |
| .whitespace-pre      | white-space: pre;      |
| .whitespace-pre-line | white-space: pre-line; |
| .whitespace-pre-wrap | white-space: pre-wrap; |

1.调用

```html
正常
<div class="whitespace-normal">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Omnis quidem itaque beatae, rem tenetur quia iure,
    eum natus enim maxime
    laudantium quibusdam illo nihil,

reprehenderit saepe quam aliquid odio accusamus.</div>

无包装
<div class="whitespace-no-wrap overflow-x-auto">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Omnis quidem itaque beatae, rem tenetur quia iure,
    eum natus enim maxime
    laudantium quibusdam illo nihil,

reprehenderit saepe quam aliquid odio accusamus.</div>

使用.whitespace-pre一个元素中保留新行和空格。文字将不会被换行。
<div class="whitespace-pre overflow-x-auto">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Omnis quidem itaque beatae, rem tenetur quia iure,
    eum natus enim maxime
    laudantium quibusdam illo nihil,

reprehenderit saepe quam aliquid odio accusamus.</div>

使用.whitespace-pre-line一个元素中保留新行而不是空格。文本将正常换行。
<div class="whitespace-pre-line">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Omnis quidem itaque beatae, rem tenetur quia iure,
    eum natus enim maxime
    laudantium quibusdam illo nihil,

reprehenderit saepe quam aliquid odio accusamus.</div>

使用.whitespace-pre-wrap一个元素中保留新行和空格。文本将正常换行。

<div class="whitespace-pre-wrap">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Omnis quidem itaque beatae, rem tenetur quia iure,
    eum natus enim maxime
    laudantium quibusdam illo nihil,

reprehenderit saepe quam aliquid odio accusamus.</div>
```

2.响应式切换

```html
<div class="whitespace-normal sm:whitespace-no-wrap md:whitespace-pre lg:whitespace-pre-line xl:whitespace-pre-wrap ...">...</div>
```



#### 断字

| Class         | Properties                                                   |
| ------------- | ------------------------------------------------------------ |
| .break-normal | word-break: normal; overflow-wrap: normal                    |
| .break-words  | overflow-wrap: break-word;                                   |
| .break-all    | word-break: break-all;                                       |
| .truncate     | overflow: hidden; text-overflow: ellipsis; white-space: nowrap |

1.调用

```html
正常
使用.break-normal仅在正常字破发点中添加换行符。
<p class="break-normal ...">...</p>

断言
使用.break-words，如果需要添加换行符中旬字。
<p class="break-words ...">...</p>

打破一切
用于.break-all在必要时添加换行符，而无需尝试保留整个单词。
<p class="break-all ...">...</p>

截短
使用.truncate截断溢出的文本以省略号（…如果需要）。
<p class="truncate ...">...</p>
```

2.响应式切换

```html
<p class="break-normal sm:break-words md:break-all lg:truncate xl:break-normal ...">
    ...
</p>
```

### 布局

#### 容器 Container

| Class         | Breakpoint         | Properties   |
| ------------- | ------------------ | ------------ |
| .container    | *None*             | width: 100%; |
| sm *(640px)*  | max-width: 640px;  |              |
| md *(768px)*  | max-width: 768px;  |              |
| lg *(1024px)* | max-width: 1024px; |              |
| xl *(1280px)* | max-width: 1280px; |              |

##### 1.容器居中

```vue
要使容器居中，请使用.mx-auto实用程序：
<div class="container mx-auto">
  <!-- ... -->
</div>

要添加水平填充，请使用以下.px-{size}实用程序：
<div class="container mx-auto px-4">
  <!-- ... -->
</div>

```



#### 边框尺寸

| Class        | Properties               |
| ------------ | ------------------------ |
| .box-border  | box-sizing: border-box;  |
| .box-content | box-sizing: content-box; |



1.使用`box-border`设置元素的`box-sizing`到`border-box`，告诉浏览器，包括元素的边框和填充，当你给它一个高度或宽度。

这意味着一个100px×100px的元素（具有2px的边框和在所有侧面上都有4px的填充）将被渲染为100px×100px，内部内容区域为88px×88px。

```html
<div class="box-border h-20 w-32 p-4 border-4 border-gray-400 bg-gray-200">
  <div class="h-full w-full bg-gray-400"></div>
</div>
```

2.排除边框和填充

使用`box-content`设置元素的`box-sizing`到`content-box`，告诉浏览器上添加元素的指定宽度或高度的顶部边框和填充。

这意味着一个100px×100px的元素具有2px的边框和在所有边上都有4px的填充实际上将被渲染为112px×112px，内部内容区域为100px×100px。

```html
<div class="box-content h-20 w-32 p-4 border-4 border-gray-400 bg-gray-200">
  <div class="h-full w-full bg-gray-400"></div>
</div>
```

#### Display

##### 用于控制元素的显示框类型的实用程序。

| Class               | Properties                   |
| ------------------- | ---------------------------- |
| .hidden             | display: none;               |
| .block              | display: block;              |
| .flow-root          | display: flow-root;          |
| .inline-block       | display: inline-block;       |
| .inline             | display: inline;             |
| .flex               | display: flex;               |
| .inline-flex        | display: inline-flex;        |
| .grid               | display: grid;               |
| .inline-grid        | display: inline-grid;        |
| .table              | display: table;              |
| .table-caption      | display: table-caption;      |
| .table-cell         | display: table-cell;         |
| .table-column       | display: table-column;       |
| .table-column-group | display: table-column-group; |
| .table-footer-group | display: table-footer-group; |
| .table-header-group | display: table-header-group; |
| .table-row-group    | display: table-row-group;    |
| .table-row          | display: table-row;          |

##### 1.使用`.block`创建一个块级元素。

```html
<div class="bg-gray-200 p-4">
  <span class="block text-gray-700 text-center bg-gray-400 px-4 py-2">1</span>
  <span class="block text-gray-700 text-center bg-gray-400 px-4 py-2 mt-2">2</span>
</div>
```

##### 2.使用`.flow-root`来创建自己的块级元素。

```html
<div class="flow-root bg-gray-400">
  <div class="my-4 block text-gray-700 text-center bg-gray-500 px-4 py-2">1</div>
</div>
<div class="flow-root bg-gray-200">
  <div class="my-4 block text-gray-700 text-center bg-gray-400 px-4 py-2">2</div>
</div>
```

##### 3.使用`.inline-block`创建一个内联块级元素。

```html
<div class="bg-gray-200">
  <div class="inline-block text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">1</div>
  <div class="inline-block text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">2</div>
</div>
```

##### 4.使用`.inline`创建一个内联元素。

```html
<div class="bg-gray-200">
  <div class="inline text-gray-700 text-center bg-gray-400 px-4 py-2">1</div>
  <div class="inline text-gray-700 text-center bg-gray-400 px-4 py-2">2</div>
  <div class="inline text-gray-700 text-center bg-gray-400 px-4 py-2">3</div>
</div>
```

##### 5.使用`.flex`创建一个块级柔性容器。

```html
<div class="flex bg-gray-200">
  <div class="flex-1 text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">1</div>
  <div class="flex-1 text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">2</div>
</div>
```

##### 6.使用`.inline-flex`创建一个内联柔性容器。

```html
<div class="inline-flex bg-gray-200">
  <div class="flex-1 text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">1</div>
  <div class="flex-1 text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">2</div>
</div>
```

##### 7.使用`.grid`创建网格容器。

```html
<div class="grid gap-4 grid-cols-3">
  <!-- ... -->
</div>
```

##### 8.使用`.inline-grid`创建一个内嵌网格容器。

```html
<span class="inline-grid grid-cols-3 col-gap-4">
  <span>1</span>
  <span>1</span>
</span>
<span class="inline-grid grid-cols-3 col-gap-4">
  <span>2</span>
  <span>2</span>
</span>
```

##### 9.使用`.hidden`设置为一个元素`display: none`，并从页面布局

```html
<div class="flex bg-gray-200">
  <div class="hidden text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">1</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">2</div>
</div>
```

###### 10.响应式切换

```html
<div class="flex sm:inline-flex md:block lg:hidden xl:flex ...">
  <!-- ... -->
</div>
```

#### 浮动 Float

| Class        | Properties                                                |
| ------------ | --------------------------------------------------------- |
| .float-right | float: right;                                             |
| .float-left  | float: left;                                              |
| .float-none  | float: none;                                              |
| .clearfix    | &::after {  content: "";  display: table;  clear: both; } |



#### Clear清除浮动 

| Class        | Properties    |
| ------------ | ------------- |
| .clear-left  | clear: left;  |
| .clear-right | clear: right; |
| .clear-both  | clear: both;  |
| .clear-none  | clear: none   |



#### Object Fit

| Class              | Properties              |
| ------------------ | ----------------------- |
| .object-contain    | object-fit: contain;    |
| .object-cover      | object-fit: cover;      |
| .object-fill       | object-fit: fill;       |
| .object-none       | object-fit: none;       |
| .object-scale-down | object-fit: scale-down; |

1.使用调整元素内容的大小以使其包含在其容器中`.object-contain`。

```html
<div class="bg-gray-400">
  <img class="object-contain h-48 w-full ...">
</div>
```

2.使用调整元素内容的大小以覆盖其容器`.object-cover`。

```html
<div class="bg-gray-400">
  <img class="object-cover h-48 w-full ...">
</div>
```

3.使用拉伸元素的内容以适合其容器`.object-fill`。

```html
<div class="bg-gray-400">
  <img class="object-fill h-48 w-full ...">
</div>
```

4.使用忽略容器大小，以其原始大小显示元素的内容`.object-none`。

```html
<div class="bg-gray-400">
  <img class="object-none h-48 w-full ...">
</div>
```

5.以其原始大小显示元素的内容，但如果需要，可使用将其缩小以适合其容器`.object-scale-down`。

```html
<div class="bg-gray-400">
  <img class="object-scale-down h-48 w-full ...">
</div>
```

6.响应式切换

```html
<div class="bg-gray-400">
  <img class="object-contain sm:object-cover md:object-fill lg:object-none xl:object-scale-down ..." src="...">
</div>
```

#### 对象位置

用于控制替换元素的内容应如何放置在其容器中的实用程序。

| Class                | Properties                     |
| -------------------- | ------------------------------ |
| .object-bottom       | object-position: bottom;       |
| .object-center       | object-position: center;       |
| .object-left         | object-position: left;         |
| .object-left-bottom  | object-position: left bottom;  |
| .object-left-top     | object-position: left top;     |
| .object-right        | object-position: right;        |
| .object-right-bottom | object-position: right bottom; |
| .object-right-top    | object-position: right top;    |
| .object-top          | object-position: top;          |



1.使用`.object-{side}`实用程序来指定替换元素的内容应如何放置在其容器中。

```html
<img class="object-none object-left-top bg-gray-400 w-24 h-24" src="...">
<img class="object-none object-top bg-gray-400 w-24 h-24" src="...">
<img class="object-none object-right-top bg-gray-400 w-24 h-24" src="...">
<img class="object-none object-left bg-gray-400 w-24 h-24" src="...">
<img class="object-none object-center bg-gray-400 w-24 h-24" src="...">
<img class="object-none object-right bg-gray-400 w-24 h-24" src="...">
<img class="object-none object-left-bottom bg-gray-400 w-24 h-24" src="...">
<img class="object-none object-bottom bg-gray-400 w-24 h-24" src="...">
<img class="object-none object-right-bottom bg-gray-400 w-24 h-24" src="...">
```

2.响应式切换

```html
<img class="object-center sm:object-top md:object-right lg:object-bottom xl:object-left ..." src="...">
```

#### 溢出Overflow

用于控制元素如何处理对于容器而言太大的内容

| Class               | Properties                         |
| ------------------- | ---------------------------------- |
| .overflow-auto      | overflow: auto;                    |
| .overflow-hidden    | overflow: hidden;                  |
| .overflow-visible   | overflow: visible;                 |
| .overflow-scroll    | overflow: scroll;                  |
| .overflow-x-auto    | overflow-x: auto;                  |
| .overflow-y-auto    | overflow-y: auto;                  |
| .overflow-x-hidden  | overflow-x: hidden;                |
| .overflow-y-hidden  | overflow-y: hidden;                |
| .overflow-x-visible | overflow-x: visible;               |
| .overflow-y-visible | overflow-y: visible;               |
| .overflow-x-scroll  | overflow-x: scroll;                |
| .overflow-y-scroll  | overflow-y: scroll;                |
| .scrolling-touch    | -webkit-overflow-scrolling: touch; |
| .scrolling-auto     | -webkit-overflow-scrolling: auto;  |

1.使用`.overflow-visible`以防止元素中的内容被剪切。请注意，任何超出元素范围的内容都将可见。

```html
<div class="overflow-visible h-16 ...">Lorem ipsum dolor sit amet...</div>
```

2.用于`.overflow-auto`在元素的内容溢出该元素的范围时向该元素添加滚动条。与`.overflow-scroll`始终显示滚动条不同，此实用程序仅在需要滚动时才显示它们。

```html
<div class="overflow-auto h-32 ...">Lorem ipsum dolor sit amet...</div>
```

3.使用`.overflow-hidden`到剪辑溢出，元素的界限的元素中的任何内容。

```html
<div class="overflow-hidden h-32 ...">Lorem ipsum dolor sit amet...</div>
```

4.使用`.overflow-x-auto`允许水平滚动如果需要的话。

```html
<div class="overflow-x-auto ...">QrLmmW69vMQD...</div>
```

5.使用`.overflow-y-auto`允许垂直滚动，如果需要的话。

```html
<div class="overflow-y-auto h-32 ...">Lorem ipsum dolor sit amet...</div>
```

6.使用`.overflow-x-scroll`允许水平滚动和始终显示滚动条，除非总是可见的滚动条由操作系统禁用。

```html
<div class="overflow-x-scroll ...">QrLmmW69vMQD...</div>
```

7.使用`.overflow-y-scroll`允许垂直滚动，始终显示滚动条，除非总是可见的滚动条由操作系统禁用。

```html
<div class="overflow-y-scroll h-32 ...">Lorem ipsum dolor sit amet...</div>
```

8.使用`.overflow-scroll`到滚动条添加的元素。与`.overflow-auto`，仅在必要时才显示滚动条，该实用程序始终显示它们。请注意，无论此设置如何，某些操作系统（如macOS）都会隐藏不必要的滚动条。

```html
<div class="overflow-scroll ...">QrLmmW69vMQD...</div>
<div class="overflow-scroll h-32 ...">Lorem ipsum dolor sit amet...</div>
<div class="overflow-scroll h-32 ...">Loremipsumdolorsitamet...</div>
```

9.用于`.scrolling-touch`在触摸设备上使用基于动量的滚动（如果支持）。

```html
<div class="scrolling-touch overflow-auto h-32 ...">Lorem ipsum dolor sit amet...</div>
```

10.响应式切换

```html
<div class="overflow-auto sm:overflow-visible md:overflow-hidden lg:overflow-x-scroll xl:overflow-y-scroll ...">
  Lorem ipsum dolor sit amet...
</div>
```



#### Position

用于控制元素在DOM中的位置

| Class     | Properties          |
| --------- | ------------------- |
| .static   | position: static;   |
| .fixed    | position: fixed;    |
| .absolute | position: absolute; |
| .relative | position: relative; |
| .sticky   | position: sticky;   |

1.用于`.static`根据文档的正常流程放置元素。

任何偏移量都将被忽略，并且该元素将不会充当绝对定位的子代的位置参考。

```html
<div class="static bg-gray-600">
  Static parent
  <div class="absolute bottom-0 left-0 bg-gray-800">
    Absolute child
  </div>
</div>
```

2.用于`.relative`根据文档的正常流程放置元素。

相对于元素的正常位置计算偏移，并且元素*将*充当绝对定位的子代的位置参考。

```html
<div class="relative bg-gray-600">
  Relative parent
  <div class="absolute bottom-0 left-0 bg-gray-800">
    Absolute child
  </div>
</div>
```

3.用于`.absolute`将元素*放置*在文档的常规流程*之外*，从而导致相邻元素的行为就像该元素不存在一样。

相对于位置除以外的最近亲代计算偏移`static`，该元素*将*充当其他绝对定位的子代的位置参考。

```html
<div class="relative bg-gray-400">
  Relative parent
  <div class="static bg-gray-600">
    Static parent
    <div class="absolute top-0 right-0 bg-gray-800">
      Absolute child
    </div>
    <div class="bg-gray-400 inline-block">
      Static sibling
    </div>
  </div>
</div>
```

4.用于`.fixed`相对于浏览器窗口定位元素。

偏移是相对于视口计算的，该元素*将*充当绝对定位的子代的位置参考。

```html
<div class="bg-gray-400 pt-16">
  <div class="fixed bg-gray-600">
    Fixed child
    <div class="absolute top-0 right-0 bg-gray-800">
      Absolute child
    </div>
  </div>

  Scroll me!

  Lorem ipsum...
</div>
```

5.用于`.sticky`将元素定位为`relative`直到其超过指定的阈值，然后将其视为固定元素，直到其父级离开屏幕为止。

相对于元素的正常位置计算偏移，并且元素*将*充当绝对定位的子代的位置参考。

```html
<div>
    <div class="sticky top-0 ...">Sticky Heading 1</div>
    <p class="py-4">Quisque cursus...</p>
</div>
<div>
    <div class="sticky top-0 ...">Sticky Heading 2</div>
    <p class="py-4">Integer lacinia...</p>
</div>
<div>
    <div class="sticky top-0 ...">Sticky Heading 3</div>
    <p class="py-4">Nullam mauris...</p>
</div>
<!-- etc. -->
```



6.响应式

```html
<div class="relative h-32 bg-gray-400 p-4">
  <div class="inset-x-0 bottom-0 relative sm:absolute md:fixed lg:absolute xl:relative"></div>
</div>
```



#### 上下左右

用于控制定位元素放置

| Class         | Properties                                        |
| ------------- | ------------------------------------------------- |
| .inset-0      | top: 0; right: 0; bottom: 0; left: 0;             |
| .inset-y-0    | top: 0; bottom: 0;                                |
| .inset-x-0    | right: 0; left: 0;                                |
| .top-0        | top: 0;                                           |
| .right-0      | right: 0;                                         |
| .bottom-0     | bottom: 0;                                        |
| .left-0       | left: 0;                                          |
| .inset-auto   | top: auto; right: auto; bottom: auto; left: auto; |
| .inset-y-auto | top: auto; bottom: auto;                          |
| .inset-x-auto | left: auto; right: auto;                          |
| .top-auto     | top: auto;                                        |
| .bottom-auto  | bottom: auto;                                     |
| .left-auto    | left: auto;                                       |
| .right-auto   | right: auto;                                      |



#### Visibility

用于控制元素可见性

| Class      | Properties           |
| ---------- | -------------------- |
| .visible   | visibility: visible; |
| .invisible | visibility: hidden;  |

1.使用`.visible`使元素可见。

```html
<div class="flex justify-center">
  <div class="bg-gray-400"></div>
  <div class="bg-gray-600 visible"></div>
  <div class="bg-gray-400"></div>
</div>
```

2.使用`.invisible`隐藏的元素，但仍保持它的位置在DOM，影响其他元素的布局

```html
<div class="flex justify-center">
  <div class="bg-gray-400"></div>
  <div class="bg-gray-600 invisible"></div>
  <div class="bg-gray-400"></div>
</div>
```

3.响应式

```html
<div class="flex justify-center">
  <div class="bg-gray-400"></div>
  <div class="bg-gray-600 visible sm:invisible md:visible lg:invisible xl:visible"></div>
  <div class="bg-gray-400"></div>
</div>
```



#### Z-Index

用于控制元素的显示顺序

| Class   | Properties     |
| ------- | -------------- |
| .z-0    | z-index: 0;    |
| .z-10   | z-index: 10;   |
| .z-20   | z-index: 20;   |
| .z-30   | z-index: 30;   |
| .z-40   | z-index: 40;   |
| .z-50   | z-index: 50;   |
| .z-auto | z-index: auto; |



### FLEXBOX



#### Flex Direction

用于控制项目内容的方向

| Class             | Properties                      |
| ----------------- | ------------------------------- |
| .flex-row         | flex-direction: row;            |
| .flex-row-reverse | flex-direction: row-reverse;    |
| .flex-col         | flex-direction: column;         |
| .flex-col-reverse | flex-direction: column-reverse; |



1.用于`.flex-row`沿与文本相同的方向水平放置弹性项目：

```html
<div class="flex flex-row bg-gray-200">
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">1</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">2</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">3</div>
</div>
```

2.用于`.flex-row-reverse`在相反方向上水平放置弹性项目：

```html
<div class="flex flex-row-reverse bg-gray-200">
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">1</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">2</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">3</div>
</div>
```

3.用于`.flex-col`垂直放置弹性项目：

```html
<div class="flex flex-col bg-gray-200">
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">1</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">2</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">3</div>
</div>
```

4.用于`.flex-col-reverse`以相反的方向垂直放置弹性项目：

```html
<div class="flex flex-col-reverse bg-gray-200">
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">1</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">2</div>
  <div class="text-gray-700 text-center bg-gray-400 px-4 py-2 m-2">3</div>
</div>
```

5.响应式

```html
<div class="flex-row sm:flex-col md:flex-row-reverse lg:flex-col-reverse xl:flex-row ...">
  <!-- ... -->
</div>
```



#### Flex Wrap

用于控制弹性项目包装方式

| Class              | Properties               |
| ------------------ | ------------------------ |
| .flex-no-wrap      | flex-wrap: nowrap;       |
| .flex-wrap         | flex-wrap: wrap;         |
| .flex-wrap-reverse | flex-wrap: wrap-reverse; |

1.使用`.flex-no-wrap`以防止包装物品弯曲，造成不灵活的项目，如果有必要溢出容器：

```html
<div class="flex flex-no-wrap bg-gray-200">
  <div class="w-2/5 flex-none p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">1</div>
  </div>
  <div class="w-2/5 flex-none p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">2</div>
  </div>
  <div class="w-2/5 flex-none p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">3</div>
  </div>
</div>
```

2.使用`.flex-wrap`允许柔性物品包裹：

```html
<div class="flex flex-wrap bg-gray-200">
  <div class="w-2/5 p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">1</div>
  </div>
  <div class="w-2/5 p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">2</div>
  </div>
  <div class="w-2/5 p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">3</div>
  </div>
</div>
```

3.用于`.flex-wrap-reverse`以相反的方向包装弹性物品：

```html
<div class="flex flex-wrap-reverse bg-gray-200">
  <div class="w-2/5 p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">1</div>
  </div>
  <div class="w-2/5 p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">2</div>
  </div>
  <div class="w-2/5 p-2">
    <div class="text-gray-700 text-center bg-gray-400 p-2">3</div>
  </div>
</div>
```

4.响应式

```html
<div class="flex-no-wrap sm:flex-wrap md:flex-wrap-reverse lg:flex-no-wrap xl:flex-wrap ...">
  <!-- ... -->
</div>
```





## vue-aplayeryer



### 安装

```
yarn add @moefe/vue-aplayer
```



### 使用

```vue
     <aplayer :audio="audio" :lrcType="3" fixed />
```



### main

```js
import APlayer from '@moefe/vue-aplayer';
Vue.use(APlayer, {
  defaultCover: 'https://github.com/u3u.png',
  productionTip: true,
});
```

### js

```js
  export default {
        name: "Vueaplayer",
        components: {

        },
        data() {
            return {
                audio: [{
                    name: '东西（Cover：林俊呈）',
                    artist: '纳豆',
                    url: 'http://localhost:8081/mp3/0003.mp3',
                    cover: 'https://p1.music.126.net/5zs7IvmLv7KahY3BFzUmrg==/109951163635241613.jpg?param=300y300', // prettier-ignore
                    lrc: 'https://cdn.moefe.org/music/lrc/thing.lrc',
                },
                    {
                        name: "0001",
                        artist: "0001",
                        url: 'http://localhost:8081/mp3/0001.mp3',
                        cover: "",
                        lrc: "[00:00.00]lrc here\n[00:01.00]aplayer"
                    }
                ]

            }

        },
        
    }
```



## .eslintrc.js

```js
/*
 * @Author: your name
 * @Date: 2020-12-14 17:18:11
 * @LastEditTime: 2021-08-03 08:55:21
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \blogs-s\src\.eslintrc.js
 */
module.exports = {
  extends: [
    'plugin:vue/vue3-essential',
    'eslint:recommended',
    '@vue/typescript/recommended'
  ],
  plugins: [
    'vue',
    '@typescript-eslint'
  ],
  rules: {
    '@typescript-eslint/no-var-requires': 0,
    '@typescript-eslint/no-unused-vars': 'error',
    // 允许非空断言
    '@typescript-eslint/no-non-null-assertion': 'off',
    // 允许自定义模块和命名空间
    '@typescript-eslint/no-namespace': 'off',
    "@typescript-eslint/no-inferrable-types": "off", // 关闭类型推断
    // 允许对this设置alias
    '@typescript-eslint/no-this-alias': 'off',
    // 允许使用any类型
    '@typescript-eslint/no-explicit-any': ['off'],
    //Missing return type on function
    "@typescript-eslint/explicit-module-boundary-types": "off",
  }
}
```



## 移动端适配

### 1.index.html

```html
 <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0,
    user-scalable=no">
```

### 2.main.js

```js
// rem 适配
var falses = true;
//----------------------------------
const setHtmlFontSize = () => {
  const htmlDom = document.getElementsByTagName('html')[0];
  let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;
  if (htmlWidth > 413 && htmlWidth<735) {
    htmlWidth = 414;
    console.log( htmlWidth);
    htmlDom.style.fontSize = `${htmlWidth / 16}px`;
  }
  //小米8适配
  if (htmlWidth == 393 ) {
    htmlWidth = 393;
    console.log( htmlWidth);
    htmlDom.style.fontSize = `${htmlWidth / 16}px`;
  }

  if (htmlWidth <= 375) {
    htmlWidth = 375;
    htmlDom.style.fontSize = `${htmlWidth / 16}px`;
  }
  if (htmlWidth > 1000) {
    falses =false

  }

};
if (falses){
window.onresize = setHtmlFontSize;
setHtmlFontSize();

}
```

### 3. 查看当期机型屏幕尺寸

```js
            const screenWidth = document.body.clientWidth
            const screenHeight = document.body.clientHeight
            alert(`当前设备的屏幕尺寸（宽 x 高）：${screenWidth} x ${screenHeight}`)
```



### 4.手机查看vue项目

vue.config.js

```js
 devServer: {
        host: '111.11.11.11', // ip
        port: 8081, // 设置端口号
        https: false, // https:{type:Boolean}
        open: false, //配置自动启动浏览器
        proxy: null  //设置代理
    },
```



# uni App



## 下拉刷新

### 1.pages.json开启刷新

enablePullDownRefresh

```js
    "pages": [{
        "path": "pages/index/index",
        "style": {
            "navigationBarTitleText": "首页",
			"enablePullDownRefresh":true
        }
    }],
```

### 2使用下拉刷新

```js
//下拉刷新
		onPullDownRefresh() {
			setTimeout(()=>{
					// 刷新关闭
				uni.stopPullDownRefresh()
				alert("刷新成功")
			},2000)
```



## 页面触底事件

```js
	// 页面触底事件
		onReachBottom() {
			setTimeout(()=>{
				alert("刷新成功")
			},2000)
		},
```



## 请求封装

### 创建一个http.js

```js
const baseUrl = 'http://11111/';
const httpRequest = (opts, data) => {
	let httpDefaultOpts = {
		url: baseUrl + opts.url,
		data: data,
		method: opts.method,
		header: opts.method == 'get' ? {
			'X-Requested-With': 'XMLHttpRequest',
			"Accept": "application/json",
			"Content-Type": "application/json; charset=UTF-8"
		} : {
			'X-Requested-With': 'XMLHttpRequest',
			'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
		},
		dataType: 'json',
	}
	let promise = new Promise(function(resolve, reject) {
		uni.request(httpDefaultOpts).then(
			(res) => {
				resolve(res[1])
			}
		).catch(
			(response) => {
				reject(response)
			}
		)
	})
	return promise
};
//带Token请求
const httpTokenRequest = (opts, data) => {
	let token = "";
	uni.getStorage({
		key: 'token',
		success: function(ress) {
			token = ress.data
		}
	});
	//此token是登录成功后后台返回保存在storage中的
	let httpDefaultOpts = {
		url: baseUrl + opts.url,
		data: data,
		method: opts.method,
		header: opts.method == 'get' ? {
			'Token': token,
			'X-Requested-With': 'XMLHttpRequest',
			"Accept": "application/json",
			"Content-Type": "application/json; charset=UTF-8"
		} : {
			'Token': token,
			'X-Requested-With': 'XMLHttpRequest',
			'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
		},
		dataType: 'json',
	}
	let promise = new Promise(function(resolve, reject) {
		uni.request(httpDefaultOpts).then(
			(res) => {
				resolve(res[1])
			}
		).catch(
			(response) => {
				reject(response)
			}
		)
	})
	return promise
};

export default {
	baseUrl,
	httpRequest,
	httpTokenRequest
}

```

### 2.将http.js引入

​	

```js
import http from '@/commons/http.js';
```

```js
let opts = {
					url: 'api/SnArticle/GetTest',
					method: 'get'
				};
				let param = {
					deviceId: this.deviceCode,
					deviceName: this.deviceName
				};
				http.httpTokenRequest(opts, param).then(res => {
					
					this.newinfo= res.data;
         // console.log(newinfo);
				}, error => {
					console.log(error);
				})
```



# Element

##  Loading加载

1.页面

```vue
<template>
  <el-button
    type="primary"
    @click="openFullScreen1"
    v-loading.fullscreen.lock="fullscreenLoading">
    指令方式
  </el-button>
  <el-button
    type="primary"
    @click="openFullScreen2">
    服务方式
  </el-button>
</template>
```

2定义bool属性

```js
data() {
      return {
        fullscreenLoading: false
      }
    },
```

3.在需要的地方调用

```js
this.fullscreenLoading = true;
    setTimeout(() => {
      this.fullscreenLoading = false;
    }, 1000);
```



## 分页

```vue
<!-- 分页 -->
    <el-pagination
      @current-change="current_change"
      :page="page"
      :page-size="pagesize"
      layout="prev, pager, next"
      :total="total"
    ></el-pagination>
```

**定义属性**

```js
  total: 0, //默认数据总数
      page: 1, //当前页码
      pagesize: 8, //每页的数据条数
```

**点击事件**

```js
 current_change(val) {
      this.page = val;
      this.SnArticle(this.page);
    },
```

**方法**

```js
 SnArticle(pages) {
      request({
        // url: "/api/SnArticle/GetTest"
        url:
          "/api/SnArticle/GetfyTest?pageIndex=" +
          pages +
          "&pageSize=" +
          this.pagesize +
          "&isDesc=false"
      })
        .then(res => {
          this.tableData = res.data;
          console.log(this.pagesize);
        })
        .catch(e => {
          console.log(e + "获取数据失败");
        });
    },
```

## 重复点击vue路由报错

在引入vue-router的js文件里加上如下代码：

```js
//push
const VueRouterPush = VueRouter.prototype.push;
VueRouter.prototype.push = function push(to) {
  return VueRouterPush.call(this, to).catch(err => err);
};

//replace
const VueRouterReplace = VueRouter.prototype.replace;
VueRouter.prototype.replace = function replace(to) {
  return VueRouterReplace.call(this, to).catch(err => err);
};

```







# vue-cli4中使用jquery

### 1. 安装jquery

```javascript
npm install jquery --save

```

### 2. 添加vue.config.js文件

```js
config.plugin('provide').use(webpack.ProvidePlugin, [{
            $: 'jquery',
            jquery: 'jquery',
            jQuery: 'jquery',
            'window.jQuery': 'jquery'
        }])
```

### 3. 引入jquery

```
 import $ from 'jquery'
```



# 后端应用



## c#

### 语法糖

####  集合类的声明

之前我们声明一个List并给list赋初始值，必须得这么写：

```c#
List<string> list = new List<string>();
list.Add("a一");
list.Add("b二");
list.Add("c三");
```

现在不需要了，直接写就可以了

```c#
List<string> list = new List<string> {
            "def","OK"
};
```

#### **集合类各个项的操作**

我们为了逐个处理集合中的项，需要这么写：

```c#
foreach (string item in list)
{
Console.WriteLine(item);
}
```

现在不需要了，这样就可以了

```c#
list.ForEach(a => Console.WriteLine(a));
```

#### **using == try finally**

为了在使用完毕时释放资源，我们经常要用using，using实质上就是try fiannaly的一个语法糖而已。例如

```c#
StreamWriter sw = null;
try
{
    sw = new StreamWriter("d:\abc.txt");
    sw.WriteLine("test");
}
finally {
    if(sw!= null) sw.Dispose();
}
```

简化为：

```c#
using (var sw = new StreamWriter("d:\abc.txt")) {
    sw.WriteLine("test");
}
```

#### **问号的演变**

表示左边的变量如果为null则值为右边的变量，否则就是左边的变量值

```c#
string a = null;
var b = a??””;
```

#### **类型实例化的语法糖**

```c#
public class Abc
{
    public int ID { get; set; }
    public string Name { get; set; }
    public string Url { get; set; }
}

public static void Main(string[] args) {
        var abc = new Abc{
            ID=1,
            Name="yukaizhao",
            Url="http://yukaizhao.cnblogs.com/"
        };
    }
```

#### 匿名类

匿名类在linq to sql或者entity framework中返回查询数据时很好用。

```c#
var a = new {
    ID = 1,
    Name=”yukaizhao”,
    BlogUrl=”http://www.cnblogs.com/yukaizhao/”
};
```

#### **NULL条件运算符**

```c#
使用代码
Customer customer = new Customer();
string name = customer?.Name;
编译代码
Customer customer = new Customer();
if (customer != null)
{
    string name = customer.Name;
}
和??组合起来使用
if (customer?.Face()??false)
还可以两个一起组合来使用
int? contactNameLen = contact?.Name?.Length; 
```

这个语法糖的目的是在对象使用前检查是否为null。如果对象为空，则赋值给变量为空值，所以例子中需要一个可以为空的int类型、即int?。如果对象不为空，则调用对象的成员取值，并赋值给变量。

#### **字符串格式化**

String.Format有些不方便的地方是：必须输入String.Format，使用{0}占位符、必须顺序来格式化、这点容易出错。

```c#
    var contactInfo = string.Format("Id:{0} Name:{1} EmailAddr:{2} PhoneNum:{3}", 
    contact.Id, contact.Name, contact.EmailAddress, contact.PhoneNum);
    
    新的语法
    var contactInfo2 = $"Id:{contact.Id} Name:{contact.Name} EmailAddr:
    {contact.EmailAddress} PhoneNum:{contact.PhoneNum}";
        
    新格式化方式还支持任何表达式的直接赋值：
    var contactInfo = $"Id:{contact.Id} Name:{(contact.Name.Length == 0 ? "Frank" : 
    contact.Name)} EmailAddr:{contact.EmailAddress} PhoneNum:{contact.PhoneNum}";
    
```



## efcore











### 连接Mysql DBFirst模式

一：**创建EF的类库，同时将此项目设置为启动项(为Scaffold-DbContext -tables指令使用)，同时安装2个包**  

​      ①Microsoft.EntityFrameworkCore.Tools

​      ②Pomelo.EntityFrameworkCore.MySql (这个是第三方的ef mysql 中间件)

 **Scaffold-DBcontext命令**

```c#
Scaffold-DbContext "server=localhost;userid=root;pwd=woshishui;port=3306;database=snblog;sslmode=none;" Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Force
```

​     server：数据库地址，User Id：账号，Password：登录密码

​      如果是针对单表的更新,加一个-Tables 后面是要更新的表名

```c#
Scaffold-DbContext "server=localhost;userid=root;pwd=woshishui;port=3306;database=snblog;sslmode=none;" Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Tables "sn_interface" -Force
```

 执行完成之后会生成指定的是Model ，注意：表必须有主键，才会生成，如果没有主机会报 Unable to generate entity type for table “xxxx” 警告，当然实体也不会生成

**Scaffold-DbContext命令参数说明:**

-OutputDir (-o) ：实体文件所存放的文件目录

-ContextDir ： DbContext文件存放的目录

-Context ： DbContext文件名

-Schemas ： 需要生成实体数据的数据表所在的模式

-Tables(-t) ： 需要生成实体数据的数据表的集合

-Force (-f)强制执行，重写已经存在的实体文件



### 查询数据

**IQueryable**

就是C#中Linq To SQL语句的返回类型，简单来说IQueryable就是可以叠加处理SQL语句，最后统一访问数据库，这个处理过程就叫`延迟执行`，这一步只是生成了SQL语句，并没有真正执行数据库查询

执行数据库查询

```c#
` ToList()`、`First()`、`FirstOrDefault()`
`Single()`、`SingleOrDefault()`、`Last()`、`LastOrDefault()`//Single只能是一个数据
`Count()`、`LongCount()`、`Min()`、`Max()`、`Average()`、`Sum()`
`Find()`、 `foreach()
```

First返回符合添加的第一条数据；First与FirstOrDefault的区别，First必须有数据，否则会报错，FirstOrDefault可有可无

First()与FirstOrDefault()可以在方法参数里直接写Where查询条件

```C#
_dbContext.Leagues.FirstOrDefault(w => w.Country == "中国");
```





#### **无用追踪**

- 无须追踪的数据没有加AsNoTracking

#### 跟踪与非跟踪查询

跟踪行为决定了 Entity Framework Core 是否将有关实体实例的信息保留在其更改跟踪器中。 如果已跟踪某个实体，则该实体中检测到的任何更改都会在 SaveChanges() 期间永久保存到数据库。 EF Core 还将修复跟踪查询结果中的实体与更改跟踪器中的实体之间的导航属性。

从不跟踪无键实体类型。 无论在何处提到实体类型，它都是指定义了键的实体类型。

#### 跟踪查询

返回实体类型的查询是默认会被跟踪的。 这表示可以更改这些实体实例，然后通过 SaveChanges() 持久化这些更改。 在以下示例中，将检测到对博客评分所做的更改，并在 SaveChanges() 期间将这些更改持久化到数据库中。

```c#
var blog = context.Blogs.SingleOrDefault(b => b.BlogId == 1);
blog.Rating = 5;
context.SaveChanges();
```



#### 非跟踪查询

AsNoTracking 称之为获取不带变动跟踪的实体查询

在一些情况下，我们只需要查询返回一个只读的数据记录，而不会对数据记录进行任何的修改。

在只读方案中使用结果时，非跟踪查询十分有用。 可以更快速地执行非跟踪查询，因为无需设置更改跟踪信息。 如果不需要更新从数据库中检索到的实体，则应使用非跟踪查询。 可以将单个查询替换为非跟踪查询。

AsNoTracking方法查询返回无变动跟踪的DbSet，由于是无变动跟踪，所以对返回的实体集中数据的任何修改，在SaveChanges()时，都不会提交到数据库中。

```c#
var blogs = context.Blogs
   .AsNoTracking()
   .ToList();
```

还可以在上下文实例级别更改默认跟踪行为：

```c#
context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
var blogs = context.Blogs.ToList();
```





#### 查询单个数据

```c#
//第一种
result = await _service.SnArticle.FindAsync(id);
//第一种
var leagues = _service.SnArticle.SingleOrDefault(l => l.Id == _id);
```



#### 模糊查询

```c#
 s => s.XianWID.StartsWith(str)
 匹配以str开头的
 s => s.XianWID.EndsWith(str)
 匹配以str结尾的
 s => s.XianWID.Contains(str)
 匹配包含str的
            //第一种
           result_List = await _service.SnArticle
           .Where(l => l.Title.Contains(name))//查询条件
           .ToListAsync();

           //第二种
           var league_ef = _dbContext.Leagues
            .Where(l => EF.Functions.Like(l.Country, "中%"))
            .ToList();
```

#### 预加载（Eager Loading）

```c#
[HttpGet("Eager")]
public IActionResult GetEager()
{
    var clubs = _dbContext.Clubs
        .Where(c => c.Name.Contains("足球队"))//过滤条件
        .Include(c => c.League)//关联数据
        .ToList();
    return Ok(clubs);
}
```



### 添加数据

```c#
        public async Task<bool> AddAsync(SnArticle entity)
        {
            _logger.LogInformation("添加数据_SnArticle" + entity);
            await _service.SnArticle.AddAsync(entity);
            return await _service.SaveChangesAsync() > 0;
        }
```



### 更新数据

更新指定列

1.第一种方式

```c#
  public async Task<bool> UpdatePortionAsync(SnArticle snArticle, string type)
        {
            _logger.LogInformation("更新部分参数");
            var date = _service.SnArticle.Update(snArticle);
            //默认不更新
            date.Property("UserId").IsModified = false;
            date.Property("Title").IsModified = false;
            date.Property("TitleText").IsModified = false;
            date.Property("Text").IsModified = false;
            date.Property("Time").IsModified = false;
            date.Property("LabelId").IsModified = false;
            date.Property("Read").IsModified = false;
            date.Property("Give").IsModified = false;
            date.Property("Comment").IsModified = false;
            date.Property("SortId").IsModified = false;
            date.Property("TypeTitle").IsModified = false;
            date.Property("UrlImg").IsModified = false;
            switch (type)
            {    //指定字段进行更新操作
                case "Read":
                    date.Property(type).IsModified = true;
                    break;
                case "Give":
                     date.Property(type).IsModified = true;
                    break;
                case "Comment":
                     date.Property(type).IsModified = true;
                    break;
            }
            return await _service.SaveChangesAsync() > 0;
        }
```

2.第二种方式

```c#
        public async Task<bool> UpdatePortionAsync(SnArticle snArticle, string type)
        {
            _logger.LogInformation("更新部分参数");
            var resulet = await _service.SnArticle.FindAsync(snArticle.ArticleId);
            if (resulet == null) return false;
            switch (type)
            {    //指定字段进行更新操作
                case "Read":
                    //修改属性，被追踪的Read状态属性就会变为Modify
                    resulet.Read = snArticle.Read;
                    break;
                case "Give":
                    resulet.Give = snArticle.Give;
                    break;
                case "Comment":
                    resulet.Comment = snArticle.Comment;
                    break;
            }
            //执行数据库操作
            return await _service.SaveChangesAsync() > 0;
        }
```

### 删除数据

第一种

```c#
        public async Task<bool> DeleteAsync(int id)
        {
            _logger.LogInformation("删除数据_SnArticle" + id);
            var todoItem = await _service.SnArticle.FindAsync(id);
            if (todoItem == null) return false;
            _service.SnArticle.Remove(todoItem);
            return await _service.SaveChangesAsync() > 0;
        }
```

第二种

```c#
        public async Task<bool> DeleteAsync(int id)
        {
            _logger.LogInformation("删除数据_SnArticle" + id);
            //先查询出来，因为只能删除被追踪的数据
            var todoItem = await  _service.SnArticle.FindAsync(id);
            if (todoItem == null) return false;
            //1、单独删除方法
            _service.SnArticle.Remove(todoItem);//删除单个todoItem
            _service.Remove(todoItem);//直接在context上Remove()方法传入model，它会判断类型
            return await _service.SaveChangesAsync() > 0;
        }

-----------------------------------------------------------------------------------------
    //批量删除方法
    var league2 = _dbContext.Leagues.SingleOrDefault(l => l.Country == "中国");
    _dbContext.Leagues.RemoveRange(league, league2);
    _dbContext.RemoveRange(league, league2);
```



##  netCoreApi



### 常用的 HTTP 状态码

| HTTP 状态码 | 涵义                  | 解释说明                                                     |
| ----------- | --------------------- | ------------------------------------------------------------ |
| 200         | OK                    | 用于一般性的成功返回，不可用于请求错误返回                   |
| 201         | Created               | 资源被创建                                                   |
| 202         | Accepted              | 用于资源异步处理的返回，仅表示请求已经收到。对于耗时比较久的处理，一般用异步处理来完成 |
| 204         | No Content            | 此状态可能会出现在 PUT、POST、DELETE 的请求中，一般表示资源存在，但消息体中不会返回任何资源相关的状态或信息 |
| 400         | Bad Request           | 用于客户端一般性错误信息返回, 在其它 4xx 错误以外的错误，也可以使用，错误信息一般置于 body 中 |
| 401         | Unauthorized          | 接口需要授权访问，为通过授权验证                             |
| 403         | Forbidden             | 当前的资源被禁止访问                                         |
| 404         | Not Found             | 找不到对应的信息                                             |
| 500         | Internal Server Error | 服务器内部错误                                               |

### ObjectResult 的方法来表明接口返回的状态码

web API会用到的状态码：

**200级别，表示成功：**

- **200 - OK**
- **201 - Created，表示资源创建成功了**
- **204 - No content，成功执行，但是不应该返回任何东西**

**400级别，表示客户端引起的错误：**

- **400 - Bad request，表示API的消费者发送到服务器的请求是错误的**
- **401 - Unauthorized，表示没有权限**
- **403 - Forbidden，表示用户验证成功，但是该用户仍然无法访问该资源**
- **404 - Not found，表示请求的资源不存在**
- **405 - Method not allowed，这就是当我们尝试发送请求给某个资源时，使用的HTTP方法却是不允许的，例如使用POST api/countries, 而该资源只实现了 GET，所以POST不被允许**
- **406 - Not acceptable，这里涉及到了media type，例如API消费者请求的是application/xml格式的media type，而API只支持application/json**
- **409 - Conflict，表示该请求无法完成，因为请求与当前资源的状态有冲突，例如你编辑某个资源数据以后，该资源又被其它人更新了，这时你再PUT你的数据就会出现409错误；有时也用在尝试创建资源时该资源已存在的情况。**
- **415 - Unsupported media type，这个和406正好返回来，比如说我向服务器提交数据的media type是xml的，而服务器只支持json，那么就会返回415**
- **422 - Unprocessable entity，表示请求的格式没问题，但是语义有错误，例如实体验证错误。**

**500级别，服务器错误：**

- **500 - Internal server error，这表示是服务器发生了错误**

### 接口命名规范

和 C# 命名规范一样，好的、统一的接口命名规范，不仅可以增强其可读性，而且还会减少很多不必要的口头/书面上的解释。可使用"驼峰命名法"按照实现接口的**业务类型、业务场景**等命名



#### 常见命名方式

- `接口名称动词前/后缀化`： 接口名称以接口数据操作的动词为前/后缀，常见动词有：`Add、Delete、Update、Query、Get、Send、Save、Detail、List`等，如：新建用户 `AddUser`、查询订单详情 `QueryOrderDetail`。

- 接口名称动词 + 请求方式

  接口路径中包含具体接口名称的名词，接口数据操作动作以 HTTP 请求方式来区分。常用的 HTTP 请求方式有：

  - `GET`：从服务器取出资源（一项或多项）
  - `POST`：在服务器新建一个资源
  - `PUT`：在服务器更新资源（客户端提供改变后的完整资源）
  - `PATCH`：在服务器更新资源（客户端提供改变的属性）
  - `DELETE`：从服务器删除资源

### 请求参数规范

- 请求方式

  ```
  GET、POST、PUT
  ```

  等含义定义，避免出现不一致现象，对人造成误解、歧义

  - `请求头`：请求头根据项目需求添加配置参数。如：请求数据格式，`accept=application/json` 等。如有需要，请求头可根据项目需求要求传入用户 token、唯一验签码等加密数据
  - `请求参数/请求体`： 请求参数字段，尽可能与数据库表字段、对象属性名等保持一致，因为保持一致是最省事，最舒服的一件事

###  返回数据规范

此处以 json 格式为例。返回数据应包含：**返回状态码、返回状态信息、具体数据**。**返回数据中的状态码、状态信息，常指具体的业务状态，不建议和 HTTP 状态码混在一起**。HTTP 状态，是用来体现 HTTP 链路状态情况，如：404-Not Found。HTTP 状态码和 json 结果中的状态码，并存尚可，用于体现不同维度的状态。



# mysql

## 数据表设计规则总结

数据库设计是有几大范式的，但是他们都比较高深莫测，实际开发中我们遵循下面的规则即可：

每张表只存储一类数据，比如用户表就存储用户信息；（做关联用的列不算，比如上面例子中人的表中还存储了房子的地址，但是地址是做关联用的）

设计表之前首先要划分清楚各模块是什么，比如用户模块、车、房子，然后理清楚各模块间的关系，两张表之间如果存在关联关系，则该关系可以分为三种：一对一，一对多，多对多。

分别先独立的设计各个表的结构，这样设计完后是一张张相互独立没有关联的表
然后按照两表之间的关系来进行完善即可。

那么两表之间的关系如何完善呢？

A和B之间是1对1关系，则将一张表的唯一字段（唯一能够确定一行数据的）放入另外一张表中：比如用户表和手机表是1对1的关系，那么我们可以将用户身份证号放入手机表中，作为手机表的列名（字段）之一。
A和B之间是1对多 关系，则将“一”这一端的唯一字段放入“多“的一端中：比如用户表和衣服表，一个用户有多件衣服，一件衣服只属于一个用户，那么就将身份证号放入衣服表中即可
A和B之间是 多对多 关系，则建立一张中间表，把AB两表中的唯一键放入中间表即可：比如手机表和APP表，一个手机可以安装多个APP，一个APP可以被多个手机安装。那么我们将APP的ID号和手机的手机号一同放入一张中间表（也叫关联表）中即可。



## MySQL 的最佳性能，需要遵循 3 个基本使用原则

首先是需要让 MySQL 回归存储的基本职能：MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离

其次是查询数据时，尽量单表查询，减少跨库查询和多表关联

还有就是要杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。

大 SQL，复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下

大批量，意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行

大字段，blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新



## 基本设置规则

必须指定默认存储引擎为 InnoDB，并且禁用 MyISAM 存储引擎，随着 MySQL 8.0 版本的发布，所有的数据字典表都已经转换成了 InnoDB，MyISAM 存储引擎已成为了历史。

默认字符集 UTF8mb4，以前版本的 UTF8 是 UTF8mb3，未包含个别特殊字符，新版本的 UTF8mb4 包含所有字符，官方强烈建议使用此字符集。

关闭区分大小写功能。设置 lower_case_tables_name=1，即可关闭区分大小写功能，即大写字母 T 和小写字母 t 一样


## 规范命名

命名规范如下，命名时的字符取值范围为：az，09 和 _（下画线）。

- 所有表名小写，不允许驼峰式命名；

- 不允许使用其他特殊字符作为名称，减少潜在风险。

  

- 命名使用具有意义的英文词汇，词汇中间以下划线分隔，一般为项目名称+代表库含义的简写，比如IM项目的工作流数据库，可以是 im_flow。

  ### 表命名规范

  1、常规表表名以t_开头，t代表table的意思，命名规则即 t + 模块（包含模块含义的简写）+ 表（包含表含义的简写），比如用户模块的教育信息表：t_user_eduinfo。

  2、临时表（RD、QA或DBA同学用于数据临时处理的表），命名规则：temp前缀+模块+表+日期后缀：temp_user_eduinfo_20210719

  3、备份表（用于保存和归档历史数据或者作为灾备恢复的数据）命名规则，bak前缀+模块+表+日期后缀：bak_user_eduinfo_20210719

  4、同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义

  5、多个单词以下划线 _ 分隔

  6、常规表表名尽量不超过30个字符，temp表和bak表视情况而定，也尽量简短为宜，命名应使用小写

  ### 字段命名规范

  1、字段命名需要表示其实际含义的英文单词或简写，单词之间用下划线 _ 进行连接，如 service_ip、service_port。

  2、各表之间相同意义的字段必须同名，比如a表和b表都有创建时间，应该统一为create_time，不一致会很混乱。

  3、多个单词以下划线 _ 分隔

  4、字段名尽量不超过30个字符，命名应该使用小写

### 常见业务表类型

- 临时表，tmp；
- 备份表，bak；
- 字典表，dic；
- 日志表，log。

字段名精确，遵循“见名知意”的原则，格式：名称_后缀。

避免普遍简单、有歧义的名称。

用户表中，用户名的字段为 UserName 比 Name 更好。

布尔型的字段，以助动词（has/is）开头。

用户是否有留言 hasmessage，用户是否通过检查 ischecked 等。

### 常见后缀

流水号/无意义主键，后缀为 id，比如 task_id；

时间，后缀为 time，insert_time。

程序账号与数据库名称保持一致。如果所有的程序账号都是 root@‘%’，密码也一样，很容易错连到其他的数据库，造成误操作。

索引命名格式，主要为了区分哪些对象是索引：

前缀_表名（或缩写）_字段名（或缩写）；

主键必须使用前缀“pk_”；

UNIQUE 约束必须使用前缀“uk_”；

普通索引必须使用前缀“idx_”。

数据库规范库表字段的命名，能够提高数据库的易读性，为数据库表设计打下基础。下面我们具体看看表设计的一些规则。

显式指定需要的属性；
创建表时显示指定字符集、存储引擎、注释信息等。

不同系统之间，统一规范；


### InnoDB 表的注意事项
主键列，UNSIGNED 整数，使用 auto_increment；禁止手动更新 auto_increment，可以删除。

必须添加 comment 注释。

必须显示指定的 engine。

表必备三字段：id、 xxx_create、 xxx_modified。

id 为主键，类型为 unsigned bigint 等数字类型；

xxx_create、xxx_modified 的类型均为 datetime 类型，分别记录该条数据的创建时间、修改时间。

## mysql的性能优化

### 尽量避免null列
not in ,!=等负向条件下null列返回的是空结果

对于null column，count(null column)是不计入统计结果的

null列会占用多一个字节的空间，来表明是否为空

大多数情况下，null列都是可以用默认值来替代的

### 尽量使用更简单的数据类型
简单意味着更低的磁盘存储，内存占用和cpu性能开销，特别是大数据量高并发的情况下，对性能影响比较大
对于索引列，越小的数据类型，意味着每个数据页能存更多的分支，减少索引的次数
###  整数
整数类型主要有： tinyint,smallint,mediumint,int,bigint,分别用8，16，24，32，64个位进行存储，存储范围是-2N-1-1 ~ 2N-1,N表示存储的位数。可以使用unsigned来表明正数，这样可以使存储的上限变成2N-1,将近扩大了一半。

另外特别要注意的是，mysql中整型可以指定宽度，但是这个宽度并不是用来限制这个列的长度的，只是用来对查询的结果进行补0显示。也就是说int(1)和int(7),int(100)都是只能存8个byte32位,范围都是-231-1 ~ 231，指定的宽度唯一的作用就是用来对客户端查询结果进行补0，而且得开启zero_fill才行，比如age int(3) ZEROFILL，如果插入值为10，那么查询的结果为010，插入1000，结果为1000。

如果确定没有负数，可以使用unsigned 类型，让可存储的上限能扩大一倍，间接的使用更小的数据类型

### 实数
 float和double来表示，属于浮点数，存在精度丢失问题，但是因为cpu原生支持浮点运算，所以性能更好,float最大支持存储4个字节，double最大支持8个字节

decimal 属于定点数，精确类型，但是由于是通过mysql实现的精度计算，相对于浮点型来讲性能要差点
**实数类型选择：**

1 如果精度要求不高，直接使用float或double

2 如果对精度要求高，性能要求不高，可以考虑使用decimal

3 如果对精度和性能都有要求，可以考虑将小数转为整型存储，

比如财务系统，需要精确为分，可以将金额乘以100进行保存到int或bigint里面

2.4 字符串
使用varchar要尽量设定小的字节数，因为mysql在创建临时表或排序的时候，会悲观的给varchar类型分配最大的长度

 总结：

1 字段设计时尽量选择小而简单的数据类型越好

2 除非必要，不使用可空列，用默认值代替

3 varchar类型虽然是变长，也应该按实际所需分配字节

4 整型不需要指定长度

5 只有正数考虑用unsigned,可以扩大上限

6 实数精度要求不高情况，优先使用浮点类型float，double,如果精度要求高可考虑用整型转化或直接使用decimal类型

## 数据表关系

### 关联映射

**一对多/多对一**

存在最普遍的映射关系，简单来讲就如球员与球队的关系；

一对多：从球队角度来说一个球队拥有多个球员 即为一对多

多对一：从球员角度来说多个球员属于一个球队 即为多对一

**一对一**

一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。

数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。

**多对多**

多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。

数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多

### 数据表之间的约束

约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。

**主键(PRIMARY KEY)**

是用于约束表中的一行，作为这一行的标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要。主键要求这一行的数据不能有重复且不能为空。

 还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识

===================================================

**默认值约束(DEFAULT)**

规定，当有DEFAULT约束的列，插入数据为空时该怎么办。

DEFAULT约束只会在使用INSERT语句（上一实验介绍过）时体现出来，INSERT语句中，如果被DEFAULT约束的位置没有值，那么这个位置将会被DEFAULT的值填充

===================================================

**唯一约束(UNIQUE)**

比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。

当INSERT语句新插入的数据和已有数据重复的时候，如果有UNIQUE约束，则INSERT失败.

===================================================

**外键(FOREIGN KEY)**

既能确保数据完整性，也能表现表之间的关系。

一个表可以有多个外键，每个外键必须REFERENCES(参考)另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。

在INSERT时，如果被外键约束的值没有在参考列中有对应，比如以下命令，参考列(department表的dpt_name)中没有dpt3，则INSERT失败



RESTRICT（约束）：如果出现在删除时，意思是约束外键主键did记录（主表中的记录）不能直接删除，必须先删除被约束的表（从表）字段中dept_id所有这个外键主键值对应的记录，才能删除外键约束（主表中的记录）

NO ACTION：

CASCADE：删除选择这个时，删除主表中的记录时，主表中的这个主键id关联的从表的这个id值所在的记录也会被删除。建议不选。

SET NULL ：删除选择这个时，如果从表（被约束的字段所在的表中）被约束的字段的值设置为可以为空时，那么当删除主表的记录时，主表中被删除的这个记录对应的主键值（约束从表字段的那个值）在从表中对应的字段中出现的那个记录的被约束字段的值就会变为NULL。

最常用的是选择RESTRICT不让删的这个约束、或者选择SET NULL删除后值表为空。

===================================================

**非空约束(NOT NULL)**

听名字就能理解，被非空约束的列，在插入值时必须非空。

在MySQL中违反非空约束，不会报错，只会有警告.





# vite

### vite 常用插件

#### [vite-plugin-restart](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantfu%2Fvite-plugin-restart)

通过监听文件修改，自动重启 vite 服务。

最常用的场景就是监听 `vite.config.js` 和 `.env.development` 文件，我们知道，修改 vite 配置文件和环境配置文件，是需要重启 vite 才会生效，通过这个插件，我们将从反复重启中解脱出来。




