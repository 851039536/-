

# 代码开发规范

## 前端页面结构

```html
<body>
    <header>这是一个页面</header>
    <aside>
        广告位或者导航
    </aside>
    <main>
        页面内容
    </main>
    <footer>这个页面是xxx写的</footer>
</body>

```



## 使用注释

###  CSS 注释

```css
/* css 注释 */
```

### JavaScript 注释

```js
// 单行注释

/**
 * 多行注释，注意第一行最好用两个 *
 * ...
 */

/*
 当然，除了两端的 * 必须加以外，其他的 * 不加也行
 ...
*/
```



###  多行注释

多行注释一般用于需要备注的信息过多的情况，常常出没于 `JavaScript` 函数的附近。首先提出一个问题：为什么要用到多行注释，用单行注释不香吗？下面就来看看下面的代码：

```js
// xxx函数
const myFunction = ({ id, name, avatar, list, type }) => {
  // 此处省略 30 行代码
};
```

小伙伴们可能看到了，一个传入五个参数，内部数行代码的函数竟然只有短短的一行注释，也许你开发的时候能记住这个函数的用途以及参数的类型以及是否必传等，但是如果你隔了一段时间再回头看之前的代码，那么简短的注释就可能变成你的困扰。 ~~更不用说没有注释，不写注释一时爽，回看代码火葬场。~~ 写注释的目的在于提高代码的可读性。相比之下，下面的注释就清晰的多：

```js
/**
 * 调整滚动距离
 * 用于显示给定 id 元素
 * @param    id        string  必传    元素 id
 * @param    distance  number  非必传  距离视口最顶部距离(避免被顶部固定定位元素遮挡)
 * @returns  null
 */
export const scrollToShowElement = (id = "", distance = 0) => {
  return () => {
    if (!id) {
      return;
    };

    const element = document.getElementById(id);
    if (!element) {
      return;
    };

    const top = element?.offsetTop || 0;
    window.scroll(0, top - distance);
  };
};
```

对于复杂的函数，函数声明上面要加上统一格式的多行注释，同时内部的复杂逻辑和重要变量也需要加上单行注释，两者相互配合，相辅相成。函数声明的多行注释格式一般为：

```js
/**
 * 函数名称
 * 函数简介
 * @param    参数1    参数1数据类型  是否必传  参数1描述
 * @param    参数2    参数2数据类型  是否必传  参数2描述
 * @param    ...
 * @returns  返回值
 */
```

多行注释的优点是清晰明了，缺点是较为繁琐(可以借助编辑器生成 JavaScript 函数注释模板)。建议逻辑简单的函数使用单行注释，逻辑复杂的函数和公共/工具函数使用多行注释。



### 进阶使用

无论是 `css` 还是 `JavaScript` 中，当代码越来越多的时候，也使得寻找要改动的代码时变得越来越麻烦。所以我们有必要对代码按模块进行整理，并在每个模块的顶部用注释，结束时使用空行进行分割。



```css
 /* ------------------------ 模块1 ------------------------ */
 /* 类名1 */
 .class-a {}

/* ======================== 模块1 ======================== */
// 变量1
const value1 = "";
// 函数1
const myFunction1 = () => {};

```

能直观的看出，加长版的注释分割效果更好，区分度更高。高质量的代码往往需要最朴实无华的注释进行分割。其中 `JavaScript` 的注释“分割线”建议使用多行注释。

------

“华丽的”分割线：

```js
 /* ------------------------ 华丽的分割线 ------------------------ */
 
/* ======================== 华丽的分割线 ======================== */
```



## VUE命名规范

### 组件命名

**命名组件时使用驼峰**

- NewComponent.vue ✅

**如果有子组件，可以这样命名**

- FooterSection.vue
- FooterSectionHeading.vue
- FooterSectionIcons.vue
- FooterSectionButton.vue

**如果没有子组件，可以尝试加前缀 `the` 来命名**

- TheNavbar.vue

### 文件命名

- 文件名统一采用小写

- 模板中使用组件**必须**使用**短横线式**

### 命名原则

祖先模块不能出现下划线，除了是全站公用模块，如 `mod_` 系列的命名：

**推荐：**

```css
<div class="modulename">
	<div class="modulename_info">
		<div class="modulename_son"></div>
		<div class="modulename_son"></div>
		...
	</div>
</div>
	
<!-- 这个是全站公用模块，祖先模块允许直接出现下划线 -->
<div class="mod_info">
	<div class="mod_info_son"></div>
	<div class="mod_info_son"></div>
	...		
</div>
```



### 模块命名

全站公共模块：以 `mod_` 开头

```
<div class="mod_yours"></div>
```

业务公共模块：以 `业务名_mod_` 开头

```
<div class="paipai_mod_yours"></div>
```

### 常用命名推荐

**注意**：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名

| ClassName              | 含义                                     |
| :--------------------- | :--------------------------------------- |
| about                  | 关于                                     |
| account                | 账户                                     |
| arrow                  | 箭头图标                                 |
| article                | 文章                                     |
| aside                  | 边栏                                     |
| audio                  | 音频                                     |
| avatar                 | 头像                                     |
| bg,background          | 背景                                     |
| bar                    | 栏（工具类）                             |
| branding               | 品牌化                                   |
| crumb,breadcrumbs      | 面包屑                                   |
| btn,button             | 按钮                                     |
| caption                | 标题，说明                               |
| category               | 分类                                     |
| chart                  | 图表                                     |
| clearfix               | 清除浮动                                 |
| close                  | 关闭                                     |
| col,column             | 列                                       |
| comment                | 评论                                     |
| community              | 社区                                     |
| container              | 容器                                     |
| content                | 内容                                     |
| copyright              | 版权                                     |
| current                | 当前态，选中态                           |
| default                | 默认                                     |
| description            | 描述                                     |
| details                | 细节                                     |
| disabled               | 不可用                                   |
| entry                  | 文章，博文                               |
| error                  | 错误                                     |
| even                   | 偶数，常用于多行列表或表格中             |
| fail                   | 失败（提示）                             |
| feature                | 专题                                     |
| fewer                  | 收起                                     |
| field                  | 用于表单的输入区域                       |
| figure                 | 图                                       |
| filter                 | 筛选                                     |
| first                  | 第一个，常用于列表中                     |
| footer                 | 页脚                                     |
| forum                  | 论坛                                     |
| gallery                | 画廊                                     |
| group                  | 模块，清除浮动                           |
| header                 | 页头                                     |
| help                   | 帮助                                     |
| hide                   | 隐藏                                     |
| hightlight             | 高亮                                     |
| home                   | 主页                                     |
| icon                   | 图标                                     |
| info,information       | 信息                                     |
| last                   | 最后一个，常用于列表中                   |
| links                  | 链接                                     |
| login                  | 登录                                     |
| logout                 | 退出                                     |
| logo                   | 标志                                     |
| main                   | 主体                                     |
| menu                   | 菜单                                     |
| meta                   | 作者、更新时间等信息栏，一般位于标题之下 |
| module                 | 模块                                     |
| more                   | 更多（展开）                             |
| msg,message            | 消息                                     |
| nav,navigation         | 导航                                     |
| next                   | 下一页                                   |
| nub                    | 小块                                     |
| odd                    | 奇数，常用于多行列表或表格中             |
| off                    | 鼠标离开                                 |
| on                     | 鼠标移过                                 |
| output                 | 输出                                     |
| pagination             | 分页                                     |
| pop,popup              | 弹窗                                     |
| preview                | 预览                                     |
| previous               | 上一页                                   |
| primary                | 主要                                     |
| progress               | 进度条                                   |
| promotion              | 促销                                     |
| rcommd,recommendations | 推荐                                     |
| reg,register           | 注册                                     |
| save                   | 保存                                     |
| search                 | 搜索                                     |
| secondary              | 次要                                     |
| section                | 区块                                     |
| selected               | 已选                                     |
| share                  | 分享                                     |
| show                   | 显示                                     |
| sidebar                | 边栏，侧栏                               |
| slide                  | 幻灯片，图片切换                         |
| sort                   | 排序                                     |
| sub                    | 次级的，子级的                           |
| submit                 | 提交                                     |
| subscribe              | 订阅                                     |
| subtitle               | 副标题                                   |
| success                | 成功（提示）                             |
| summary                | 摘要                                     |
| tab                    | 标签页                                   |
| table                  | 表格                                     |
| txt,text               | 文本                                     |
| thumbnail              | 缩略图                                   |
| time                   | 时间                                     |
| tips                   | 提示                                     |
| title                  | 标题                                     |
| video                  | 视频                                     |
| wrap                   | 容器，包，一般用于最外层                 |
| wrapper                | 容器，包，一般用于最外层                 |



## CSS规范

### 代码大小写

样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。

### 选择器

- 尽量少用通用选择器 `*`
- 不使用 ID 选择器
- 不使用无具体语义定义的标签选择器

```css
/* 推荐 */
.jdc {}
.jdc li {}
.jdc li p{}
```

### 属性值引号

css属性值需要用到引号时，统一使用单引号

```css
/* 推荐 */
.jdc { 
	font-family: 'Hiragino Sans GB';
}

```

### 属性书写顺序

建议遵循以下顺序：

1. 布局定位属性：display / position / float / clear / visibility / overflow
2. 自身属性：width / height / margin / padding / border / background
3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word
4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …



### 文件信息注释

在样式文件编码声明 `@charset` 语句下面注明页面名称、作者、创建日期等信息

```
@charset "UTF-8";
/**
 * @desc File Info
 * @author Author Name
 * @date 2015-10-10
 */
```

### 常用命名

 `css类名`

| **CSS类名**           | **说明**               |
| --------------------- | ---------------------- |
| **布局**              |                        |
| layout                | 布局容器               |
| wrapper/wrap          | 控制布局宽度的外围容器 |
| header/head/hd        | 头部/顶部              |
| main/bd               | 主体部分               |
| footer/foot/ft        | 底部                   |
| sidebar               | 侧边栏                 |
| **容器**              |                        |
| banner                | 广告栏                 |
| content               | 内容部分               |
| copyright             | 版权                   |
| list                  | 列表                   |
| menu/submenu          | 菜单/二级菜单          |
| nav/subnav            | 导航栏/二级导航        |
| **组件/细节**         |                        |
| arrow                 | 箭头                   |
| btn                   | 按钮                   |
| download              | 下载                   |
| logo                  | 徽标                   |
| message/msg           | 信息                   |
| news                  | 新闻                   |
| product               | 产品                   |
| search                | 搜索                   |
| status                | 状态                   |
| summary               | 摘要                   |
| tab                   | 标签页                 |
| tag                   | 标签                   |
| text/txt              | 文本                   |
| tip                   | 提示                   |
| title/subtitle        | 标题/二级标题          |
| **尺寸**              |                        |
| large                 | 大                     |
| middle                | 中等                   |
| small                 | 小                     |
| mini                  | 迷你                   |
| **位置**              |                        |
| top/right/bottom/left | 上/右/下/左            |
| **关系**              |                        |
| first                 | 第一个                 |
| last                  | 最后一个               |
| prev                  | 上一个                 |
| current               | 当前项                 |
| next                  | 下一个                 |
| forward               | 向前                   |
| back                  | 向后                   |
| **状态**              |                        |
| primary               | 主要                   |
| info                  | 提示信息               |
| success               | 成功                   |
| warning               | 一般警告               |
| danger/error          | 严重警告/错误警告      |
| link                  | 文字链接               |
| plain/ghost           | 按钮是否镂空           |
| light                 | 亮模式                 |
| dark                  | 暗模式                 |
| disabled              | 禁用                   |
| active                | 激活                   |
| checked               | 选中                   |
| loading               | 加载中                 |






## SASS规范

###

### 变量

可复用属性尽量抽离为页面变量，易于统一维护

```css
// CSS
.jdc {
    color: red;
    border-color: red;
}

// SCSS
$color: red;
.jdc {
    color: $color;
    border-color: $color;
}
```

### 混合(mixin)

根据功能定义模块，然后在需要使用的地方通过 `@include` 调用，避免编码时重复输入代码段

```css
// CSS
.jdc_1 {
    -webkit-border-radius: 5px;
    border-radius: 5px;
}
.jdc_2 {
    -webkit-border-radius: 10px;
    border-radius: 10px;
}

// SCSS
@mixin radius($radius:5px) {
    -webkit-border-radius: $radius;
    border-radius: $radius;
}
.jdc_1 {
    @include radius; //参数使用默认值
}
.jdc_2 {
    @include radius(10px);
}


// CSS
.jdc_1 {
    background: url(/img/icon.png) no-repeat -10px 0;
}
.jdc_2 {
    background: url(/img/icon.png) no-repeat -20px 0;
}

// SCSS
@mixin icon($x:0, $y:0) {
    background: url(/img/icon.png) no-repeat $x, $y;
}
.jdc_1 {
    @include icon(-10px, 0);
}
.jdc_2 {
    @include icon(-20px, 0);
}
```

### 占位选择器 %

如果不调用则不会有任何多余的 css 文件，占位选择器以 `%` 标识定义，通过 `@extend` 调用

```css
//scss
%borderbox {
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
.jdc {
    @extend %borderbox;
}
```

### extend 继承

```css
// CSS
.jdc_1 {
    font-size: 12px;
    color: red;
}
.jdc_2 {
    font-size: 12px;
    color: red;
    font-weight: bold;
}

// SCSS
.jdc_1 {
    font-size: 12px;
    color: red;
}
.jdc_2 {
    @extend .jdc_1;
    font-weight: bold;
}

// 或者
%font_red {
    font-size: 12px;
    color: red;
}
.jdc_1 {
    @extend %font_red;
}
.jdc_2 {
    @extend %font_red;
    font-weight: bold;
}
```

### for 循环

```css
// CSS
.jdc_1 {background-position: 0 -20px;}
.jdc_2 {background-position: 0 -40px;}
.jdc_3 {background-position: 0 -60px;}

// SCSS
@for $i from 1 through 3 {
    .jdc_#{$i} {
        background-position: 0 (-20px) * $i;
    }
}
```

注意：`#{}` 是连接符，变量连接使用时需要依赖

### each 循环

```css
// CSS
.jdc_list {
    background-image: url(/img/jdc_list.png);
}
.jdc_detail {
    background-image: url(/img/jdc_detail.png);
}

// SCSS
@each $name in list, detail {
    .jdc_#{$name} {
        background-image: url(/img/jdc_#{$name}.png);
    }
}


// CSS
.jdc_list {
    background-image: url(/img/jdc_list.png);
    background-color: red;
}
.jdc_detail {
    background-image: url(/img/jdc_detail.png);
    background-color: blue;
}

// SCSS
@each $name, $color in (list, red), (detail, blue) {
    .jdc_#{$name} {
        background-image: url(/img/jdc_#{$name}.png);
        background-color: $color;
    }
}
```

### function 函数

```css
@function pxToRem($px) {
    @return $px / 10px * 1rem;
}
.jdc {
    font-size: pxToRem(12px);
}
```

### 运算规范

运算符之间空出一个空格

```css
.jdc {
    width: 100px - 50px;
    height: 30px / 5;
}
```

注意运算单位，单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意

```css
// 正确的运算格式
.jdc {
    width: 100px - 50px;
    width: 100px + 50px;
    width: 100px * 2;
    width: 100px / 2;
}
```



### 移动端适配

目前移动端的适配方案一般就是两种，一个是 `rem` 方案，一个就是 `vw` 的方案。

#### 安装

- 要实现使用 `vw` 来实现移动端的适配，我们首先需要安装 [postcss (opens new window)](https://postcss.org/)这个工具。
- 因为我们使用 `webpack` 来作为打包工具，所以还需要安装官方提供的 [postcss-loader (opens new window)](https://github.com/webpack-contrib/postcss-loader)，但是由于我们的项目是用最新的 `vue-cli4.x` 来构建了，初始化项目内部默认就安装了它，所以这一步可以省略。

```bash
$ npm install postcss -D
```

- 安装 [postcss-px-to-viewport (opens new window)](https://github.com/evrone/postcss-px-to-viewport)这个插件，它可以将我们设置`px`值自动转化为相应的`vw`、`vh`之类的值。

```bash
$ npm install postcss-px-to-viewport --D
```



#### 配置

- 新建一个postcss.config.js 来配置转换规则。关于各参数的含义：[postcss-px-to-viewport (opens new window)](https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md)。

```javascript
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      unitToConvert: 'px',
      viewportWidth: 750,
      unitPrecision: 3,
      propList: ['*'],
      viewportUnit: 'vw',
      fontViewportUnit: 'vw',
      selectorBlackList: ['.ignore'],
      minPixelValue: 1,
      mediaQuery: false,
      replace: true,
      exclude: [],
      landscape: false,
      landscapeUnit: 'vw',
      landscapeWidth: 568,
    },
  },
};
```



- 然后因为是移动端的网页，所以我们应该在 `public/index.html` 中添加 `meta` 元信息标签禁止用户缩放页面。

```html
<meta
  name="viewport"
  content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"
/>
```



# CSS

## 选择器

CSS选择器的解析是从上到下，从右向左解析，为了避免对所有元素进行解析

- 可继承的样式：font-size, font-family, color，ul，li，dl，dt，dd；
- 不可继承的样式：border, padding, margin, width, height

**优先级**

| 选择器         | 权重值 |
| :------------- | :----- |
| !important标识 | 10000  |
| 行内样式       | 1000   |
| id选择器       | 100    |
| 类选择器       | 10     |
| 标签选择器     | 1      |
| 通配符 *       | 0      |

> !important>行内样式>ID选择器>类、伪类、属性>元素、伪元素>继承>通配符

### 标签选择器

```css
p{color:red;}
```

### ID选择器

```css
#warning{color:red;}
```

### 属性选择器

```html
<ul>
    <li foo>1</li>
    <li foo="abc">2</li>
    <li foo="abc efj">3</li>
    <li foo="abcefj">4</li>
    <li foo="efjabc">5</li>
    <li foo="ab">6</li>
</ul>
```

```css
//选择 attribute=value 的所有元素。
[foo=abc]{
    background-color:red;
}

//选择 attribute 属性包含单词 value 的所有元素。
[foo~=abc]{
    background-color:red;
}

//选择其 attribute 属性值以 value 开头的所有元素。类似正则的 ^,以什么开始
[foo^=abc]{
    background-color:red;
}

//选择其 attribute 属性值以 value 结束的所有元素。类似正则的 $,以什么结束
[foo$=abc]{
    background-color:red;
}

//选择其 attribute 属性中包含 value 子串的每个元素。
[foo*=abc]{
    background-color:red;
}

//选择 attribute 属性值以 value 开头的所有元素。
[foo|=abc]{
    background-color:red;
}

```

### 后代选择器

```CSS
ul li{
    border: 1px solid red;
}
```

### 子选择器

```css
 ul>li>p{
   border: 1px solid red;
}
```

### 相邻兄弟选择器

```css
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

//选择紧接在 element元素之后的 element 元素。
h1+p{
    color:red;
}

```

### 一般兄弟选择器 

```css
//选择前面有 element1 元素的每个 elem 元素。
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

 h1~p{
   border: 1px solid red;
}
```

### 伪类选择器

```css
//:root 文档根元素伪类
:root{
    background-color:red;
}

//:nth-child(n) 孩子选择器
<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>

div :nth-child(1){
    color:red;
}

//:nth-of-type(n) 同类型的第n个元素
div p:nth-of-type(2){
    color: red;
}

//选择属于父元素element的第一个子元素。 等同 :nth-child(1)
element:first-child

//选择属于父元素element的最后一个子元素。
element:last-child

//同类型的第一个子元素
element:first-of-type

//同类型的最后一个子元素
element:last-of-type

<div>
    <h1>h1</h1>
    <p>p1</p>
    <p>p2</p>
    <p>p3</p>
</div>
<div>
    <h1>h2</h1>  
</div>

 div :only-child{
    color: red;
 }

//没有访问过的状态
a:link

//链接正在被点击
a:active

//选择鼠标指针位于其上的链接。
a:hover

//选择所有已被访问的链接。
a:visited

//:focus 选择器用于选取获得焦点的元素。
:focus

//选择每个启用的 input 元素 / 选择每个禁用的 input 元素
:enabled / :disabled

//选择每个被选中的 input 元素。自定义开关可以用这个实现
:checked

//选择非 selector 元素的每个元素。（反向选择）
:not(selector)
```



### 伪元素选择器

```css
element::first-line

//p 元素的第一行发生改变
p:first-line{
	background-color:yellow;
}


element::first-letter
//直接第一个字符变黄，如果JavaScript做的话，需要获取字符串，再获取第一个字符，再改变其颜色
h1:first-letter{
	color:yellow;
}

//在每个 element 元素的内容之前插入内容。我们更多的可能是当作一个div来用
element::before

//在每个element元素的内容之后插入内容。我们可能更多的是用来清除浮动或验证表单提示等其它
element::after

//选择被用户选取的元素部分。
::selection
```



##  background

```css
    /* 背景图片 */
background: no-repeat center/100% url("../img/index.png");
	/* 背景颜色 */
  background-color: #ffffff;
  /*背景透明*/
  background-color: hsla(0,0%,100%,.7);
```

### **使用多个背景图片**

```css
body {
  background-image: url(https://image.flaticon.com/icons/svg/748/748122.svg), url(https://images.unsplash.com/photo-1478719059408-592965723cbc?ixlib=rb-1.2.1&auto=format&fit=crop&w=2212&q=80);
  background-position: center, top;
  background-repeat: repeat, no-repeat;
  background-size: contain, cover;
}
```



### **添加叠加渐变**

```css
body {
  background-image: 
    linear-gradient(4deg, rgba(38,8,31,0.75) 30%, rgba(213,49,127,0.3) 45%, rgba(232,120,12,0.3) 100%),
    url("https://images.unsplash.com/photo-1503803548695-c2a7b4a5b875?ixlib=rb-1.2.1&auto=format&fit=crop&w=2250&q=80");
  background-size: cover;
  background-repeat: no-repeat;
  background-attachment: fixed;
  background-position: center
}
```

### **网格背景图像**

```html
<body>
<div class="container">
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
  <div class="item_img"></div>
  <div class="item"></div>
</div>
</body>
```

```css
body {
 margin: 0;
  padding: 0;
}

.container {
  position: absolute;
  width: 100%;
  height: 100%;
  background: black;
  display: grid;
  grid-template-columns: 25fr 30fr 40fr 15fr;
  grid-template-rows: 20fr 45fr 5fr 30fr;
  grid-gap: 20px;
  .item_img {
    background-image: url('https://images.unsplash.com/photo-1499856871958-5b9627545d1a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2207&q=80');
  background-repeat: no-repeat;
  background-position: center;
  background-attachment: fixed;
  background-size: cover;
}
}

```

### vue全局背景颜色

```js
mounted() {
  document.querySelector('body').setAttribute('style', 'background-color:#f7f7f7')
},
beforeDestroy() {
  document.querySelector('body').removeAttribute('style')
}
```



## 字体 font

```css
/* 字体颜色 */
  color: #888888;
/* 字体粗细 */
  font-weight: 400;
/* 字体大小 */
  font-size: 14px;
/* 文字居中 */
  text-align: center;
/* 字体行内居中 */
  line-height: 45px;
 /*字体加深*/
 text-shadow: 0 0 1px rgba(0,0,0,.3);
 /*起始段落空2格*/
 text-indent: 2em;
```

### 字体发光

```css
 color: white;
  text-shadow:
  0px 0px 5px white,
  0px 0px 5px white,
  0px 0px 5px white,
  0px 0px 20px rgba(171, 126, 177, 0.7),
  0px 0px 20px rgba(171, 126, 177, 0.7),
  0px 0px 20px rgba(171, 126, 177, 0.7),
  0px 0px 20px rgba(171, 126, 177, 0.7);
```

##  margin | padding

```css
/* 外边距 */
  margin: 60px 0 0 -40px;
/* 居中显示 */
  margin: 0 auto;
/* 向下10px */
  margin-bottom: 10px;
/* 外边距 */
  padding: 15px 0 10px 12px;
```

## 透明

```css
 opacity: 0.9;
```

## 边框 border

```css
/* 边框宽度1px 样式 颜色 */
  border: 1px solid #868686;
/* 边框边角弧度 */
  border-radius: 5px;
/* 边框下划线 */
  border-bottom: 1px solid #edeef0;
/* 样式 1px */
  border-style: ridge;
  border-width: 1px;
```

### border-radius 的斜线语法

```css
.border-radius {
  border-radius: 50px 25px / 25px 50px;
}
```



### 实线边框

```css
    -webkit-box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);
    box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);
```



## 2D动画

### 动画效果

```css
 /* 动画效果 */
  transition: all 5s;
```

### 动画触发

```css
:hover {
  /* 放大2倍 */
  /* transform: scale(2, 2); */
  /* 旋转 */
  transform: rotate(720deg);
  /* 上移 */
  transform: translateY(-3px);
}

box-shadow: 0px 0px 2px 2px rgba(0, 0, 0, 0.3);
```



## 3D动画

### 3D转换 translate3d

```css
transform: translate3d(0,100px,100px);
```

### 透视 perspective

```css
/* 透视写在被观察元素的父盒子上面 */
perspective: 500px;
```

### 旋转 rotate3d

```css
  transform: rotateX(45deg);
  transform: rotateY();
  transform: rotateZ();
  /* 自定义 */
  transform: rotate3d(x,y,z,deg);
```

### 3d呈现 transform-style

```css
  /* 让子元素保持3d立体空间环境 */
transform-style: preserve-3d;
```

## img

### 设置图像的最大宽度

```css
img {
    max-width: 100%;
}
```

### 悬停放大图片特效

```css
.img-wrapper img {
  -webkit-transition: 0.3s linear;
  transition: 0.3s linear;
}

.img-wrapper img:hover {
  transform: scale(1.1);
}

```

### 颜色过滤

```css
/* ============== 
* 灰度过滤 
* ==============*/
.grayscale-img {
  -webkit-filter: grayscale(100%);
  filter: grayscale(100%);
}

.grayscale-img:hover {
  -webkit-filter: grayscale(0);
  filter: grayscale(0);
}

/* ============== 
* 深褐色过滤
* ==============*/
.sepia-img {
  -webkit-filter: sepia(100%);
  filter: sepia(100%);
}

.sepia-img:hover {
  -webkit-filter: sepia(0);
  filter: sepia(0);
}
```



## 定位

### 元素固定

```css
@media (min-height: 500px) {
    .site-header {
        position: sticky;
        top: 0;
        /*other styles*/
    }
}
```

### 居中定位

示例1

```c#
   position: absolute;
    width: 50%;
    height: 80%;
    overflow: auto;
    margin: auto;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
```

示例2

```css
.tag_search {
    
  @apply relative;
  height: 50px;

  div {
    @apply absolute top-1/2 left-1/2;
    width: 40%;
    transform: translate(-50%, -50%);
  }
}
```



## css 技巧

### 图片模糊

```css
        filter: blur(1px);
        -webkit-filter: blur(1px); /* chrome, opera */
        -ms-filter: blur(1px);
        -moz-filter: blur(1px);
```



### 元素隐藏

```css
visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；
opacity: 0;``CSS3属性，设置0可以使一个元素完全透明；
position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外；
display: none; 元素会变得不可见，并且不会再占用文档的空间；
transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；
<div hidden="hidden"> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态；
height: 0; 将元素高度设为 0 ，并消除边框；
filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中；

```

### 三角形

```css
/** 正三角 */
.triangle {
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 0 25px 40px 25px;
  border-color: transparent transparent rgb(245, 129, 127) transparent;
}
```



### 虚线效果

```css
.dotted-line{
    border: 1px dashed transparent;
    background: linear-gradient(white,white) padding-box, repeating-linear-gradient(-45deg,#ccc 0, #ccc .25em,white 0,white .75em);
}
```

### 文本超出省略号

单行文本

```css
.single-ellipsis{
  width: 500px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

多行文本

```css
.multiline-ellipsis {
  display: -webkit-box;
  word-break: break-all;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4; //需要显示的行数
  overflow: hidden;
  text-overflow: ellipsis;
}
```



### 灰度模式

```css
filter: grayscale(100%);
```

### 描绘波浪线

```vue
<div class="bruce flex-ct-x">
	<p class="waveline-text">波浪线文字</p>
</div>
```

```css
@mixin waveline($h, $color: #f66) {
	position: relative;
	&::after {
		position: absolute;
		left: 0;
		top: 100%;
		width: 100%;
		height: $h;
		background: linear-gradient(135deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%), linear-gradient(45deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%);
		background-size: $h * 2 $h * 2;
		content: "";
	}
}
.waveline-text {
	height: 20px;
	line-height: 20px;
	letter-spacing: 10px;
	@include waveline(10px);
}
```

### 格子背景

```css
  background-image: linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%),
            linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%);
            background-position: 0 0, 20px 20px;
            background-size: 40px 40px;
```

### 下划线跟随导航栏

```vue
<div class="bruce flex-ct-x">
	<ul class="underline-navbar">
		<li>Alibaba阿里巴巴</li>
		<li>Tencent腾讯</li>
		<li>Baidu百度</li>
		<li>Jingdong京东</li>
		<li>Ant蚂蚁金服</li>
		<li>Netease网易</li>
	</ul>
</div>
```

```css
.underline-navbar {
	display: flex;
	li {
		position: relative;
		padding: 10px;
		cursor: pointer;
		font-size: 20px;
		color: #09f;
		transition: all 300ms;
		&::before {
			position: absolute;
			left: 100%;
			top: 0;
			border-bottom: 2px solid transparent;
			width: 0;
			height: 100%;
			content: "";
			transition: all 300ms;
		}
		&:active {
			background-color: #09f;
			color: #fff;
		}
		&:hover {
			&::before {
				left: 0;
				top: 0;
				z-index: -1;
				border-bottom-color: #09f;
				width: 100%;
				transition-delay: 100ms;
			}
			& + li::before {
				left: 0;
			}
		}
	}
}
```

##



### 自动打字

```html
<div class="bruce flex-ct-x">
	<div class="auto-typing">Do You Want To Know More About CSS Development Skill</div>
</div>
```

```css
@mixin typing($count: 0, $duration: 0, $delay: 0) {
	overflow: hidden;
	border-right: 1px solid transparent;
	width: #{$count + 1}ch;
	font-family: Consolas, Monaco, Monospace;
	white-space: nowrap;
	animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards, caret 500ms steps(1) #{$delay}s $duration * 2 forwards;
}
.auto-typing {
	font-weight: bold;
	font-size: 30px;
	color: #09f;
	@include typing(52, 5);
}
@keyframes typing {
	from {
		width: 0;
	}
}
@keyframes caret {
	50% {
		border-right-color: currentColor;
	}
}
```

### 渐变色文字

```css
<h2 class="gradient-text">Gradient text</h2>
<style>
.gradient-text {
  background-image: linear-gradient(90deg, red, blue);
  background-clip: text;
  color: transparent;
}
</style>
```

### 顺滑滚动

```css
html {
  scroll-behavior: smooth;
}
```





### 清除 overflow: auto;的滚动条

```css
.div{
  overflow: auto
}
 
.div::-webkit-scrollbar{
    display: none;
}
```







### 气泡背景墙

```html
<div class="bruce" data-title="气泡背景墙">
	<ul class="bubble-bgwall">
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
		<li>Love</li>
	</ul>
</div>
```

```css
.bruce {
	background-image: linear-gradient(270deg, #8146b4, #6990f6);
}
.bubble-bgwall {
	overflow: hidden;
	position: relative;
	margin: 0 auto;
	width: 100%;
	max-width: 1200px;
	height: 100%;
	li {
		display: flex;
		position: absolute;
		bottom: -200px;
		justify-content: center;
		align-items: center;
		border-radius: 10px;
		width: 50px;
		height: 50px;
		background-color: rgba(#fff, .15);
		color: #ccc;
		animation: bubble 15s infinite;
		&:nth-child(1) {
			left: 10%;
		}
		&:nth-child(2) {
			left: 20%;
			width: 90px;
			height: 90px;
			animation-duration: 7s;
			animation-delay: 2s;
		}
		&:nth-child(3) {
			left: 25%;
			animation-delay: 4s;
		}
		&:nth-child(4) {
			left: 40%;
			width: 60px;
			height: 60px;
			background-color: rgba(#fff, .3);
			animation-duration: 8s;
		}
		&:nth-child(5) {
			left: 70%;
		}
		&:nth-child(6) {
			left: 80%;
			width: 120px;
			height: 120px;
			background-color: rgba(#fff, .2);
			animation-delay: 3s;
		}
		&:nth-child(7) {
			left: 32%;
			width: 160px;
			height: 160px;
			animation-delay: 2s;
		}
		&:nth-child(8) {
			left: 55%;
			width: 40px;
			height: 40px;
			font-size: 12px;
			animation-duration: 15s;
			animation-delay: 4s;
		}
		&:nth-child(9) {
			left: 25%;
			width: 40px;
			height: 40px;
			background-color: rgba(#fff, .3);
			font-size: 12px;
			animation-duration: 12s;
			animation-delay: 2s;
		}
		&:nth-child(10) {
			left: 85%;
			width: 160px;
			height: 160px;
			animation-delay: 5s;
		}
	}
}
@keyframes bubble {
	0% {
		opacity: .5;
		transform: translateY(0) rotate(45deg);
	}
	25% {
		opacity: .75;
		transform: translateY(-400px) rotate(90deg);
	}
	50% {
		opacity: 1;
		transform: translateY(-600px) rotate(135deg);
	}
	100% {
		opacity: 0;
		transform: translateY(-1000px) rotate(180deg);
	}
}
```

### 自动打字器

```html
<div class="bruce flex-ct-x" data-title="自动打字">
	<div class="auto-typing">Do You Want To Know More About CSS Development Skill</div>
</div>
```

```css
@mixin typing($count: 0, $duration: 0, $delay: 0) {
	overflow: hidden;
	border-right: 1px solid transparent;
	width: #{$count + 1}ch;
	font-family: Consolas, Monaco, monospace;
	white-space: nowrap;
	animation: typing #{$duration}s steps($count + 1) #{$delay}s infinite backwards,
		caret 500ms steps(1) #{$delay}s infinite forwards;
	// animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards,
	// 	caret 500ms steps(1) #{$delay}s $duration * 2 forwards;
}
.auto-typing {
	font-weight: bold;
	font-size: 30px;
	color: #09f;
	@include typing(52, 5);
}
@keyframes caret {
	50% {
		border-right-color: currentColor;
	}
}
@keyframes typing {
	from {
		width: 0;
	}
}
```

### 水平垂直居中

#### **HTML结构如下**

```html
<div class="parent">
    <div class="child"></div>
</div>
复制代码
```

#### 1. 使用Flex布局

```css
.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
复制代码
```

Flex布局是我日常使用过程中使用最频繁的一种方案，通过很简单的几行代码就可以实现我们想要的布局。具体学习的话可以阅读 [阮一峰的Flex布局教程](https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html)。

#### 2. 使用绝对定位

```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    /* top和left是以左上角为坐标原点 */
    top: 50%;
    left: 50%;
    /* transform：translate的属性值为百分数时，是以元素自身为参考 */
    transform: translate(-50%,-50%);
}

/* 或者 */
.child {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
复制代码
```

值得说明的是，`top`和`left`是以左上角为坐标原点的，这样就会导致虽然设置为50%，但实际上是实现了左上角这个点的居中，因此需要再移动一下这个元素。而当`transform`的`translate`的属性值为百分数的时候，是以元素自身作为参考的，因此向左和向上移动自身长宽的50%即可实现水平垂直居中。

#### 3. Flex的另一种方法

```css
.parent {
    display: flex;
}
.child {
    margin: auto;
}
复制代码
```

（虽然但是，这种我还没怎么用过哈哈哈...

#### 4.Grid布局

```css
.parent {
    display: grid;
}
.child {
    justify-self: center;
    align-self: center;
}
复制代码
```

Grid布局也是比较常用的一种方法，一般用在构建整体布局的时候用到的比较多。它有固定和灵活的尺寸，还可以通过名称或网格线把目标放置在指定的位置。具体使用也可以阅读 [阮一峰的Grid布局教程](https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2019%2F03%2Fgrid-layout-tutorial.html)。（阮一峰老师双鲨）

#### 5.Table布局

```css
.parent {
    display: table;
}
.child {
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}
```





# JavaScript

## ES6

### 解构语法

解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出，赋值给其他变量。

如果要将对象传递给函数，则可以轻松选择对象的属性，然后使用ES6分解语法将它们放在单独的变量中：

```js
function foo({ a, b }) {
    console.log(a, b); // 1, 2
}

foo({ a: 1, b: 2 });
```

赋值：

```js
function foo(obj) {
    const { a, b } = obj;
    console.log(a, b); // 1, 2
}

or
const { title, text } = res.data[0]
 state.dataOne = { title, text }
```

在解构数组时，可以使用 `...` 语法来获取数组中的所有其他项。

```js
function foo([a, b, ...c]) {
    console.log(c); // [3, 4, 5]
}
foo([1, 2, 3, 4, 5]);

赋值：
function foo(arr) {
    const [a, b, ...c] = arr;
    console.log(c); // [3, 4, 5]
}
foo([1, 2, 3, 4, 5]);

//rest操作符也可以单独使用，无需解构：
function foo(...nums) {
    console.log(nums); // [1, 2, 3, 4, 5]
}
foo(1, 2, 3, 4, 5);
```

rest语法 `...` 与另一个ES6特性操作符扩展完全相同。

例如，如果要将两个数组合并为一个

```js
const a = [1, 2];
const b = [3, 4];
const c = [...a, ...b];
console.log(c); // [1, 2, 3, 4]
```

`spread`也适用于对象：

```js
const obj = { a: 1, b: 2 };
const obj2 = { ...obj, c: 3 };
console.log(obj2); // { a: 1, b: 2, c: 3 }
```

### 箭头函数

箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作**构造函数**。

简洁的函数

```js
const addOne = (num) => {
    return num + 1;
};
```

箭头语法对于创建[单行函数](https://www.zhihu.com/search?q=单行函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A440172288})更加简洁友好。

```js
const addOne = (num) => num + 1;
```

### 扩展符的运用

#### 简单语法

```js
const a = 1;
const b = 2;
const obj = { a, b };
```

#### 方法放到对象字面量中

```js
const a = 1;
const b = 2;
const obj = {
    a,
    b,
    getA() {
        return this.a;
    },
    getB() {
        return this.b;
    },
};
```

#### 数组转化为用逗号分隔

```js
function  test(a,b){
    console.log(a); // 1
    console.log(b); // 2
}

var arr = [1, 2];
test(...arr);
```

#### 数组拼接

```js
var arr1 = [1, 2, 3,4];
var arr2 = [...arr1, 4, 5, 6];
console.log(arr2);  // [1, 2, 3, 4, 4, 5, 6]
```

### Symbol

基本数据类型Symbol，表示独一无二的值。它是一种类似于字符串的数据类型，它的特点如下：

- Symbol的值是唯一的，用来解决命名冲突的问题
- Symbol值不能与其他类型数据进行运算
- Symbol定义的对象属性不能使用`for...in`遍历循环，但是可以使用`Reflect.ownKeys` 来获取对象的所有键名

```js
let s1 = Symbol();
console.log(typeof s1); // "symbol"

let s2 = Symbol('hello');
let s3 = Symbol('hello');
console.log(s2 === s3); // false
```

### 字符串判断

#### .repeat()

> 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。

```js
const str = "DevPoint ".repeat(3);
console.log(str); // DevPoint DevPoint DevPoint
```

#### .startsWith()

> 用来判断当前字符串是否以另外一个给定的子字符串开头（区分大小写），并根据判断结果返回 `true` 或 `false`。

```js
const str = "DevPoint".startsWith("D");
const str2 = "DevPoint".startsWith("d");
console.log(str); // true
console.log(str2); // false
```

#### .endsWith()

> 用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 `true` 或 `false`。

```js
const str = "DevPoint".endsWith("t"); 
console.log(str); // true
```

#### .includes()

> 用于判断一个字符串是否包含在另一个字符串中，根据情况返回 `true` 或 `false`。

```js
const str = "DevPoint".includes("P");
console.log(str); // true
```

#### .find()

> 返回数组中满足提供的过滤函数的**第一个元素**的值，否则返回 `undefined`。

```js
const arrNumbers = [5, 12, 8, 130, 44];
const foundNumbers = arrNumbers.find((number) => number > 10);
console.log(foundNumbers);   // 12是数组第一个大于10的数
```

### 集合 Set

| size   | 返回集合的元素个数                   |
| ------ | ------------------------------------ |
| add    | 增加一个新的元素，返回当前的集合     |
| delete | 删除元素，返回布尔值                 |
| has    | 检查集合中是否包含某元素，返回布尔值 |
| clear  | 清空集合，返回undefined              |

```
//创建一个空集合
let s = new Set();
//创建一个非空集合
let s1 = new Set([1,2,3,1,2,3]);
//返回集合的元素个数
console.log(s1.size);       // 3
//添加新元素
console.log(s1.add(4));     // {1,2,3,4}
//删除元素
console.log(s1.delete(1));  //true
//检测是否存在某个值
console.log(s1.has(2));     // true
//清空集合
console.log(s1.clear());    //undefined
```

#### 数组与集合的相互转化

```js
// Set集合转化为数组
const arr = [...mySet]
const arr = Array.from(mySet)

// 数组转化为Set集合
const mySet = new Set(arr)
```

### Map

如果需要“ 键值对” 的数据结构， Map 比 Object 更合适。Map也实现了iterator接口，所以可以使用扩展运算符和 for…of 进行遍历。

| size  | 返回Map的元素个数                   |
| ----- | ----------------------------------- |
| set   | 增加一个新的元素，返回当前的Map     |
| get   | 返回键名对象的键值                  |
| has   | 检查Map中是否包含某元素，返回布尔值 |
| clear | 清空Map，返回undefined              |

```js
//创建一个空 map
let m = new Map();
//创建一个非空 map
let m2 = new Map([
 ['name', 'hello'],
]);
//获取映射元素的个数
console.log(m2.size);          // 1
//添加映射值
console.log(m2.set('age', 6)); // {"name" => "hello", "age" => 6}
//获取映射值
console.log(m2.get('age'));    // 6
//检测是否有该映射
console.log(m2.has('age'));    // true
//清除
console.log(m2.clear());       // undefined
```

### 模块化

ES6中首次引入模块化开发规范ES Module，让Javascript首次支持原生模块化开发。ES Module把一个文件当作一个模块，每个模块有自己的独立作用域，那如何把每个模块联系起来呢？核心点就是模块的导入与导出。

#### （1）export 导出模块

- **正常导出：**

```javascript
// 方式一
export var first = 'test';
export function func() {
    return true;
}

// 方式二
var first = 'test';
var second = 'test';
function func() {
    return true;
}
export {first, second, func};
```

- **as关键字:**

```javascript
var first = 'test';
export {first as second};
```

as关键字可以重命名暴露出的变量或方法，经过重命名后同一变量可以多次暴露出去。 

- **export default**

export default会导出默认输出，即用户不需要知道模块中输出的名字，在导入的时候为其指定任意名字。

```javascript
// 导出
export default function () {
  console.log('foo');
}
// 导入
import customName from './export-default';
```

**注意：** 导入默认模块时不需要大括号，导出默认的变量或方法可以有名字，但是对外无效。export default只能使用一次。

#### （2）import 导入模块

- **正常导入：**

```javascript
import {firstName, lastName, year} from './profile';
```

导入模块位置可以是相对路径也可以是绝对路径，.js可以省略，如果不带路径只是模块名，则需要通过配置文件告诉引擎查找的位置。

- **as关键字：**

```javascript
import { lastName as surname } from './profile';
```

import 命令会被提升到模块头部，所以写的位置不是那么重要，但是不能使用表达式和变量来进行导入。

- **加载整个模块（无输出）**

```javascript
import 'lodash'; //仅仅是加载而已，无法使用
```

- **加载整个模块（有输出）**

```javascript
import * as circle from './circle';
console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));
```

**注意：** import * 会忽略default输出

#### （3）导入导出复合用法

- **先导入后导出**

```javascript
export { foo, bar } from 'my_module';
// 等同于
import { foo, bar } from 'my_module';
export { foo, boo};
```

- **整体先导入再输出以及default**

```javascript
// 整体输出
export * from 'my_module';
// 导出default，正如前面所说，export default 其实导出的是default变量
export { default } from 'foo';
// 具名接口改default
export { es6 as default } from './someModule';
```

#### （4）模块的继承

```javascript
export * from 'circle';
export var e = 2.71828182846;
export default function(x) {
  return Math.exp(x);
}
```

**注意：** export * 会忽略default。



### 数组

#### includes

**includes()** 方法用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回false。该方法不会改变原数组。

```js
arr.includes(searchElement, fromIndex)
```

searchElement：必须，需要查找的元素值。

fromIndex：可选，从fromIndex 索引处开始查找目标值。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。

```js
[1, 2, 3].includes(2);  //  true
[1, 2, 3].includes(4);  //  false
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
```

### 补齐字符串的长度

 padStart()和padEnd()

```js
"1".padStart(3, '0')   // 输出结果： '001'
"15".padStart(3, '0')  // 输出结果： '015'
```

### Object返回数组

```js
let obj = { 
  id: 1, 
  name: 'hello', 
  age: 18 
};
console.log(Object.keys(obj));   // 输出结果: ['id', 'name', 'age']
console.log(Object.values(obj)); // 输出结果: [1, 'hello', 18]
console.log(Object.entries(obj));   // 输出结果: [['id', 1], ['name', 'hello'], ['age', 18]
```

### for await…of

方法被称为**异步迭代器**，该方法是主要用来遍历异步对象。只能在 `async function`内使用

```js
function Gen (time) {
  return new Promise((resolve,reject) => {
    setTimeout(function () {
       resolve(time)
    },time)
  })
}

async function test () {
   let arr = [Gen(2000),Gen(100),Gen(3000)]
   for await (let item of arr) {
      console.log(Date.now(),item)
   }
}
test()
```

### 空值合并运算符（??）

```js
const dogName = false; 
const name =  dogName ?? 'default';  // name = false;
```

### 可选链操作符（?.）

```js
const name = system?.user?.addr?.province?.name || 'default';
```

当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。

```js
a?.[x]
// 等同于
a == null ? undefined : a[x]

a?.b()
// 等同于
a == null ? undefined : a.b()

a?.()
// 等同于
a == null ? undefined : a()
```

### String.prototype.replaceAll()

replaceAll()方法会返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。

```javascript
let string = 'hello world, hello ES12'
string.replace(/hello/g,'hi')    // hi world, hi ES12
string.replaceAll('hello','hi')  // hi world, hi ES12
```

### 数字分隔符

数字分隔符可以在数字之间创建可视化分隔符，通过 _ 下划线来分割数字，使数字更具可读性，可以放在数字内的任何地方：

```javascript
const money = 1_000_000_000
//等价于
const money = 1000000000

```

该新特性同样支持在八进制数中使用：

```javascript
const number = 0o123_456
//等价于
const number = 0o123456
```






## 常用技巧

### 使用&&替代if

```js
const doSometions = () => {}
const isTrue = true
let temp = ''
if(isTrue){
    doSometings()
    temp = 'isTrue'
}

// 替代方案
isTrue && this.doSometings()
isTrue && (temp == 'isTrue')
```

### 使用逻辑运算符

如果有一段这样的代码：

```javascript
if(a > 10) {
    doSomething(a)
}
```

可以使用逻辑运算符来改写：

```javascript
a > 10 && doSomething(a)
```

### 三元运算符简化if else

```js
//Longhand 
let marks = 26; 
let result; 
if (marks >= 30) {
   result = 'Pass'; 
} else { 
   result = 'Fail'; 
} 

//Shorthand 
let result = marks >= 30 ? 'Pass' : 'Fail';
```

### ||运算符给变量指定默认值

本质是利用了`||`运算符的特点，当前面的表达式的结果转成布尔值为`false`时，则值为后面表达式的结果

```js
//Longhand
let imagePath;

let path = getImagePath();

if (path !== null && path !== undefined && path !== '') {
    imagePath = path;
} else {
    imagePath = 'default.jpg';
}

//Shorthand
let imagePath = getImagePath() || 'default.jpg';
```

### 使用字符串模板简化代码

#### 使用模板字符串代替原始的字符串拼接

```js
//Longhand
console.log('You got a missed call from ' + number + ' at ' + time);

//Shorthand
console.log(`You got a missed call from ${number} at ${time}`);
```



### 判断简化

如果有下面的这样的一个判断：

```javascript
if(a === undefined || a === 10 || a=== 15 || a === null) {
    //...
}
```

就可以使用数组来简化这个判断逻辑：

```javascript
if([undefined, 10, 15, null].includes(a)) {
    //...
}

```

这样代码就会简洁很多，并且便于扩展，如果还有需要等于a的判断，直接在数组中添加即可。

### 一元运算符简化字符串转数字

```js
//Longhand
let total = parseInt('453');
let average = parseFloat('42.6');

//Shorthand
let total = +'453';
let average = +'42.6';
```



### 清空数组

如果想要清空一个数组，可以将数组的length置于0:

```javascript
let array = ["A", "B", "C", "D", "E", "F"]
array.length = 0 
console.log(array)  // []
```

### 验证undefined和null

如果有这样一段代码：

```javascript
if(a === null || a === undefined) {
    doSomething()
}
```

也就是如果需要验证一个值如果等于null或者undefined时，需要执行一个操作时，可以使用空值合并运算符来简化上面的代码：

```javascript
a ?? doSomething()
```

### 数组元素转化为数字

如果有一个数组，想要把数组中的元素转化为数字，可以使用map方法来实现：

```javascript
const array = ['12', '1', '3.1415', '-10.01'];
array.map(Number);  // [12, 1, 3.1415, -10.01]
```

### 缩短console.log()

每次进行调试时书写很多console.log()就会比较麻烦，可以使用以下形式来简化这个代码：

```javascript
const c = console.log.bind(document) 
c(996) 
c("hello world")
```

### 生成长度为N的数组

```
// 生成长度为100的数组
const arrN = [...Array(100).keys()]
// [0,1,2,3,...,99]
```



### 取最后一位数字

```javascript
const num = 12345
const num2 = '54321'
console.log(num%10) // 5
console.log(num2%10) // 1 当然隐式转换也是可以的
复制代码
```

### 取整

```javascript
const num = 123.456
console.log(num | 0) // 123
```





### 网页跳转

```js
  //当前窗口跳转
   self.location.href=url
  //新窗口跳转
   window.open(url)
  //跳转链接 返回上一页
   window.history.back(-1);
```

 self 指代当前窗口对象，属于window 最上层的对象。

  location.href 指的是某window对象的url的地址

  self.location.href 指当前窗口的url地址，去掉self默认为当前窗口的url地址，一般用于防止外部的引用

top.location.href:为引用test.html页面url的**父窗口对象的url**

### 滚动到页面顶部

```js
const goToTop = () => window.scrollTo(0, 0);
goToTop();
```

### 邮箱

```js
export const isEmail = (e) => {
return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/.test(e)
}
```

### 手机号码

```js
export const isMobile = (e) => {
return /^1[0-9]{10}$/.test(e)
}
```

### 电话号码

```js
export const isPhone = (e) =>{
return /^([0-9]{3,4}-)?[0-9]{7,8}$/.test(e)
}
```

### 是否url地址

```js
export const isURL = (e) => {
return /^http[s]?:\/\/.*/.test(e)
}
```

### 是否字符串

```js
export const isNumber = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1) === 'String'
}
```

### 是否数字

```js
export const isNumber = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1) ==='Number'
}
```

### 是否boolean

```js
export const isBoolean = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1) ==='Boolean'
}
```

### 是否函数

```js
export const isFunction = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1) === 'Function'
}
```

### 是否为null

```js
export const isNull = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1)==='Null'
}
```

### 是否undefined

```js
export const isUndefined = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1)==='Undefined'
} 
```

### 是否对象

```js
export const isObject = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1) === 'Object'
}
```

### 是否数组

```js
export const isArray = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1)==='Array'
} 
```

### 是否时间

```js
export const isDate = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1)==='Date'
} 
```

### 是否正则

```js
export const isRegExp = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1)==='RegExp'
}
```

### 是否错误对象

```js
export const isError = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1)==='Error'
}
```

### 是否Symbol函数

```js
export const isSymbol = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1)==='Symbol'
}
```

### 是否Promise对象

```js
export const isPromise = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1)==='Promise'
}
```

### 是否Set对象

```js
export const isSet = (e) =>{
return Object.prototype.toString.call(e).slice(8,-1) ==='Set'
}
export const us = navigator.userAgent.toLowerCase();
```

### 是否是微信浏览器

```js
export const isWeiXin = () =>{
return ua.match(/microMessenger/i) == 'micromessenger'
}
```

### 是否是移动端

```js
export const isDeviceMobile =()=>{
return /android|webos|iphone|ipod|balckberry/i.test(ua)
}
```

### 是否是QQ浏览器

```js
export const isQQBrowser = () =>{
return !!ua.match(/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i)
}
```

### 是否是爬虫

```js
export const isSpider =()=>{
return /adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sougou orion spider/.test(ua)
}
```

### 是否ios

```js
export const isIos =()=>{
var u = navigator.userAgent;
if(u.indexOf('Android')>-1||u.indexOf('Linux')>-1){//安卓手机
return false
}else if(u.indexOf('iPhone')>-1){//苹果手机
return true
}else if(u.indexOf('iPad')>-1){//iPad
return false
}else if(u.indexOf('windows Phone')>-1){//winphone手机
return false
}else{
return false
}
}
```

### 是否PC端

```js
export const isPC = ()=>{
var userAgentInfo = navigator.userAgent
var Agents = ['Android','iPhone','SymbuanOS','Windows Phone','iPad','iPod'];
var flag = true;
for(var i = 0;i<Agents.length;i++){
if(userAgentInfo.indexOf(Agents[i])>0){
flag = false;
break;
}
}
return flag;
}                  
```

### 去除html标签

```js
export const removehtmltag = (str)=>{
return str.replace(/<[^>]+>/g,'')
}
```

### 获取url参数

```js
export const getQueryString =(name)=>{
const reg = new RegExp('(^|&)'+name+'=([^&]*)(&|$)','i');
const search = window.location.search.split('?')[1]||'';
const r = search.match(reg) || [];
return r[2];
}
```

### 动态引入js

```js
export const injectScript =(src)=>{
const s = document.createElement('script');
s.type = 'text/JavaScript';
s.async = true;
s.src = src;
const t = document.getElentsByTagName('script')[0];
t.parentNode.insertBefore(s,t)
}
```

### 根据url地址下载

```js
export const download = (url)=>{
var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome')>-1;
var isSafari = navigator.userAgent.toLowerCase().indexOf('safari')>-1;
if(isChrome || isSafari){
var link = document.createElement('a');
link.href = url;
if(link.download !== undefined){
var fileName = url.substring(url.lastIndexOf('/')+1,url.length);
link.download = fileName
}
if(document.createEvent){
var e = document.createEvent('MouseEvents');
e.initEvent('click',true,true);
link.dispatchEvent(e);
return true;
}
}
if(url.indexOf('?')===-1){
url+='?download'
}
window.open(url,'_self');
return true;
}
```

### el是否包含某个class

```js
export const hasClass = (el,className)=>{
let reg = new RegExp('(^|\\s)'+className+'(\\s|$)')
return reg.test(el.className)
}
```

### el添加某个class

```js
export const addClass = (el,className)=>{
if(hasClass(el,className)){
return
}
let newClass = el.className.split(' ')
newClass.push(className)
el.className = newClass.join(' ')
}
```

### el去除某个class

```js
export cosnt removeClass = (el,className)=>{
if(!hasClass(el,className)){
return
}
let reg = new RegExp('(^|\\s)'+className+'(\\s|$)','g')
el.className = el.className.replace(reg,'')
}
```

### 获取滚动的坐标

```js
export const getScrollPosition = (el = window) => ({
x:el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
y:el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop
})
```

### 滚动到顶部

```js
export cosnt scrollToTop = ()=>{
const c = document.documentElement.scrollTop || document.body.scrollTop;
if(c>0){
window.requestAnimationFrame(scrollToTop);
window.scrollTo(0,c-c/8);
}
}
```

### el是否在视口范围

```js
export const elementIsVisibleInViewport = (el,partiallyVisib = false)=>{
cosnt {top,left,right,bottom} = el.getBoundingClienRect();
const {innerHeight,innerWidth} = window;
return partiallyVisible
? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) && ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth)) : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;
}
```

### 洗牌算法随机

```js
export const shuffle = (arr) => { 
var result = [],
random;
while (arr.length > 0) { 
random = Math.floor(Math.random() * arr.length); result.push(arr[random])
arr.splice(random, 1) 
} 
return result;
}
```

### 拦截粘贴板

```js
export const copyTextToClipboard = (value) => { 
var textArea = document.createElement("textarea"); textArea.style.background = 'transparent'; 
textArea.value = value;
document.body.appendChild(textArea);
textArea.select(); 
try { 
var successful = document.execCommand('copy'); 
} catch (err) { 
console.log('Oops, unable to copy'); 
} 
document.body.removeChild(textArea); 
}
```

### 判断类型集合

```js
export const checkStr = (str, type) => { 
switch (type) { 
case 'phone':
//手机号码
return /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(str); 
case 'tel':
//座机
return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);
case 'card':
//身份证 
return /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/.test(str); 
case 'pwd':
//密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 
return /^[a-zA-Z]\w{5,17}$/.test(str)
case 'postal':
//邮政编码
return /[1-9]\d{5}(?!\d)/.test(str);
case 'QQ':
//QQ号
return /^[1-9][0-9]{4,9}$/.test(str);
case 'email':
//邮箱 
return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str); 
case 'money':
//金额(小数点2位) 
return /^\d*(?:\.\d{0,2})?$/.test(str);
case 'URL':
//网址
return /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?/.test(str) 
case 'IP': 
//IP
return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str); 
case 'date':
//日期时间
return /^(\d{4})\-(\d{2})\-(\d{2}) (\d{2})(?:\:\d{2}|:(\d{2}):(\d{2}))$/.test(str) || /^(\d{4})\-(\d{2})\-(\d{2})$/.test(str) case 'number':
//数字
return /^[0-9]$/.test(str);
case 'english':
//英文
return /^[a-zA-Z]+$/.test(str);
case 'chinese': 
//中文
return /^[\\u4E00-\\u9FA5]+$/.test(str);
case 'lower':
//小写 
return /^[a-z]+$/.test(str);
case 'upper':
//大写
return /^[A-Z]+$/.test(str);
case 'HTML': 
//HTML标记
return /<("[^"]*"|'[^']*'|[^'">])*>/.test(str); 
default: 
return true; 
} 
}
```

### 严格的身份证校验

```js
export const isCardID =(sId)=>{
if (!/(^\d{15}$)|(^\d{17}(\d|X|x)$)/.test(sId)) {
console.log('你输入的身份证长度或格式错误')
return false 
}
//身份证城市 
var aCity = { 11: "北京", 12: "天津", 13: "河北", 14: "山西", 15: "内蒙古", 21: "辽宁", 22: "吉林", 23: "黑龙江", 31: "上海", 32: "江苏", 33: "浙江", 34: "安徽", 35: "福建", 36: "江西", 37: "山东", 41: "河南", 42: "湖北", 43: "湖南", 44: "广东", 45: "广西", 46: "海南", 50: "重庆", 51: "四川", 52: "贵州", 53: "云南", 54: "西藏", 61: "陕西", 62: "甘肃", 63: "青海", 64: "宁夏", 65: "新疆", 71: "台湾", 81: "香港", 82: "澳门", 91: "国外" };
if (!aCity[parseInt(sId.substr(0, 2))]) { 
console.log('你的身份证地区非法')
return false
}
// 出生日期验证
var sBirthday = (sId.substr(6, 4) + "-" + Number(sId.substr(10, 2)) + "-" + Number(sId.substr(12, 2))).replace(/-/g, "/"), d = new Date(sBirthday) 
if (sBirthday != (d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate())) { 
console.log('身份证上的出生日期非法') 
return false 
}
// 身份证号码校验
var sum = 0, weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],
codes = "10X98765432" 
for (var i = 0; i < sId.length - 1; i++) { 
sum += sId[i] * weights[i]; 
} 
var last = codes[sum % 11];
//计算出来的最后一位身份证号码 
if (sId[sId.length - 1] != last) { 
console.log('你输入的身份证号非法') 
return false 
}
return true
}
```

### 随机数范围

```js
export const random = (min, max) => { 
if (arguments.length === 2) { 
return Math.floor(min + Math.random() * ((max + 1) - min)) 
} else { 
return null; 
} 
```

### 将阿拉伯数字翻译成中文的大写数字

```js
export const numberToChinese = (num) => {
var AA = new Array("零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十");
var BB = new Array("", "十", "百", "仟", "萬", "億", "点", ""); 
var a = ("" + num).replace(/(^0*)/g, "").split("."), k = 0, re = "";
for (var i = a[0].length - 1; i >= 0; i--) { 
switch (k) { 
case 0: re = BB[7] + re;
break; 
case 4:
if (!new RegExp("0{4}//d{" + (a[0].length - i - 1) + "}$") .test(a[0])) re = BB[4] + re;
break;
case 8:
re = BB[5] + re; BB[7] = BB[5]; k = 0;
break;
}
if (k % 4 == 2 && a[0].charAt(i + 2) != 0 && a[0].charAt(i + 1) == 0) re = AA[0] + re;
if (a[0].charAt(i) != 0) re = AA[a[0].charAt(i)] + BB[k % 4] + re; k++; }
if (a.length > 1) { re += BB[6]; 
for (var i = 0; i < a[1].length; i++) re += AA[a[1].charAt(i)];
} 
if (re == '一十') re = "十";
if (re.match(/^一/) && re.length == 3) re = re.replace("一", ""); return re;
}
```

### 将数字转换为大写金额

```js
export const changeToChinese = (Num) => {
//判断如果传递进来的不是字符的话转换为字符
if (typeof Num == "number") { 
Num = new String(Num);
};
Num = Num.replace(/,/g, "") 
//替换tomoney()中的“,” 
Num = Num.replace(/ /g, "") 
//替换tomoney()中的空格
Num = Num.replace(/￥/g, "") 
//替换掉可能出现的￥字符 
if (isNaN(Num)) { 
//验证输入的字符是否为数字 
//alert("请检查小写金额是否正确");
return "";
}; 
//字符处理完毕后开始转换，采用前后两部分分别转换
var part = String(Num).split(".");
var newchar = ""; 
//小数点前进行转化
for (var i = part[0].length - 1; i >= 0; i--) { 
if (part[0].length > 10) { 
return ""; 
//若数量超过拾亿单位，提示
} 
var tmpnewchar = ""
var perchar = part[0].charAt(i); 
switch (perchar) {
case "0":
tmpnewchar = "零" + tmpnewchar;
break;
case "1": 
tmpnewchar = "壹" + tmpnewchar; 
break;
case "2":
tmpnewchar = "贰" + tmpnewchar; 
break;
case "3":
tmpnewchar = "叁" + tmpnewchar;
break;
case "4": tmpnewchar = "肆" + tmpnewchar;
break;
case "5": tmpnewchar = "伍" + tmpnewchar;
break;
case "6": tmpnewchar = "陆" + tmpnewchar; 
break;
case "7": tmpnewchar = "柒" + tmpnewchar;
break; 
case "8": tmpnewchar = "捌" + tmpnewchar; 
break; 
case "9": tmpnewchar = "玖" + tmpnewchar;
break;
}
switch (part[0].length - i - 1) {
case 0: 
tmpnewchar = tmpnewchar + "元";
break; 
case 1:
if (perchar != 0) tmpnewchar = tmpnewchar + "拾"; 
break;
case 2: 
if (perchar != 0) tmpnewchar = tmpnewchar + "佰";
break; 
case 3: 
if (perchar != 0) tmpnewchar = tmpnewchar + "仟";
break; 
case 4: 
tmpnewchar = tmpnewchar + "万"; 
break; 
case 5:
if (perchar != 0) tmpnewchar = tmpnewchar + "拾";
break;
case 6:
if (perchar != 0) tmpnewchar = tmpnewchar + "佰";
break;
case 7:
if (perchar != 0) tmpnewchar = tmpnewchar + "仟"; 
break; 
case 8:
tmpnewchar = tmpnewchar + "亿"; 
break; 
case 9: 
tmpnewchar = tmpnewchar + "拾"; 
break;
} 
var newchar = tmpnewchar + newchar; 
}
//小数点之后进行转化 
if (Num.indexOf(".") != -1) {
if (part[1].length > 2) {
// alert("小数点之后只能保留两位,系统将自动截断"
);
part[1] = part[1].substr(0, 2) } 
for (i = 0; i < part[1].length; i++) {
tmpnewchar = "" perchar = part[1].charAt(i) 
switch (perchar) { 
case "0":
tmpnewchar = "零" + tmpnewchar;
break;
case "1": 
tmpnewchar = "壹" + tmpnewchar;
break; 
case "2":
tmpnewchar = "贰" + tmpnewchar;
break;
case "3":
tmpnewchar = "叁" + tmpnewchar;
break;
case "4": 
tmpnewchar = "肆" + tmpnewchar;
break; 
case "5":
tmpnewchar = "伍" + tmpnewchar;
break; 
case "6":
tmpnewchar = "陆" + tmpnewchar;
break;
case "7": tmpnewchar = "柒" + tmpnewchar; 
break; 
case "8":
tmpnewchar = "捌" + tmpnewchar;
break;
case "9": 
tmpnewchar = "玖" + tmpnewchar; 
break; 
} 
if (i == 0) tmpnewchar = tmpnewchar + "角"; 
if (i == 1) tmpnewchar = tmpnewchar + "分"; 
newchar = newchar + tmpnewchar; } } 
//替换所有无用汉字 
while (newchar.search("零零") != -1) 
newchar = newchar.replace("零零", "零"); 
newchar = newchar.replace("零亿", "亿"); 
newchar = newchar.replace("亿万", "亿"); 
newchar = newchar.replace("零万", "万"); 
newchar = newchar.replace("零元", "元"); 
newchar = newchar.replace("零角", ""); 
newchar = newchar.replace("零分", ""); 
if (newchar.charAt(newchar.length - 1) == "元") { 
newchar = newchar + "整" 
} 
return newchar;
}
```

### 判断一个元素是否在数组中

```js
export const contains = (arr, val) => { 
return arr.indexOf(val) != -1 ? true : false; 
}
```

### 数组排序，{type} 1：从小到大 2：从大到小 3：随机

```js
export const sort = (arr, type = 1) => {
return arr.sort((a, b) => { 
switch (type) { 
case 1:
return a - b;
case 2:
return b - a;
case 3: 
return Math.random() - 0.5;
default:
return arr; 
} 
}) 
}
```

### 去重

```js
export const unique = (arr) => { 
if (Array.hasOwnProperty('from')) { 
return Array.from(new Set(arr));
} else { 
var n = {},
r = []; 
for (var i = 0; i < arr.length; i++) { 
if (!n[arr[i]]) { 
n[arr[i]] = true;
r.push(arr[i]);
} 
} 
return r; 
}
}
```

### 求两个集合的并集

```js
export const union = (a, b) => { 
var newArr = a.concat(b); 
return this.unique(newArr); 
}
```

### 求两个集合的交集

```js
export const intersect = (a, b) => {
var _this = this;
a = this.unique(a);
return this.map(a, function (o) { 
return _this.contains(b, o) ? o : null; });
}
```

### 删除其中一个元素

```js
export const remove = (arr, ele) => { 
var index = arr.indexOf(ele); 
if (index > -1) { 
arr.splice(index, 1); 
}
return arr; 
}
```

### 将类数组转换为数组

```js
export const formArray = (ary) => { 
var arr = [];
if (Array.isArray(ary)) {
arr = ary;
} else {
arr = Array.prototype.slice.call(ary); 
}; 
return arr; 
}
```

### 最大值

```js
export const max = (arr) => { 
return Math.max.apply(null, arr); 
}
```

### 最小值

```js
export const min = (arr) => { 
return Math.min.apply(null, arr); 
}
```

### 求和

```js
export const sum = (arr) => { 
return arr.reduce((pre, cur) => { return pre + cur }) 
}
```

### 平均值

```js
export const average = (arr) => {
return this.sum(arr) / arr.length 
}
```

### 去除空格,type: 1-所有空格 2-前后空格 3-前空格 4-后空格

```js
export const trim = (str, type) => {
type = type || 1 
switch (type) { 
case 1: 
return str.replace(/\s+/g, "");
case 2:
return str.replace(/(^\s*)|(\s*$)/g, "");
case 3:
return str.replace(/(^\s*)/g, "");
case 4: 
return str.replace(/(\s*$)/g, ""); 
default: 
return str;
} 
}
```

### 字符转换，type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写

```js
export const changeCase = (str, type) => { 
type = type || 4 
switch (type) {
case 1: 
return str.replace(/\b\w+\b/g, function (word) { 
return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(); 
});
case 2: 
return str.replace(/\b\w+\b/g, function (word) { 
return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase(); 
}); 
case 3:
return str.split('').map(function (word) { 
if (/[a-z]/.test(word)) { 
return word.toUpperCase();
} else { 
return word.toLowerCase() } 
}).join('')
case 4:
return str.toUpperCase();
case 5: 
return str.toLowerCase();
default:
return str;
}
}

```

### 检测密码强度

```js
export const checkPwd = (str) => {
var Lv = 0; 
if (str.length < 6) { 
return Lv 
} 
if (/[0-9]/.test(str)) { Lv++ } 
if (/[a-z]/.test(str)) { Lv++ }
if (/[A-Z]/.test(str)) { Lv++ } 
if (/[\.|-|_]/.test(str)) { Lv++ }
return Lv; 
}
```

### 函数节流器

```js
export const debouncer = (fn, time, interval = 200) => { 
if (time - (window.debounceTimestamp || 0) > interval) {
fn && fn();
window.debounceTimestamp = time; 
} 
}
```

### 在字符串中插入新字符串

```js
export const insertStr = (soure, index, newStr) => {
var str = soure.slice(0, index) + newStr + soure.slice(index); return str; 
}
```

### 判断两个对象是否键值相同

```js
export const isObjectEqual = (a, b) => { 
var aProps = Object.getOwnPropertyNames(a);
var bProps = Object.getOwnPropertyNames(b); 
if (aProps.length !== bProps.length) {
return false; 
} 
for (var i = 0; i < aProps.length; i++) {
var propName = aProps[i]; 
if (a[propName] !== b[propName]) {
return false; 
} 
}
return true;
}
```

### 16进制颜色转RGBRGBA字符串

```js
export const colorToRGB = (val, opa) => { 
var pattern = /^(#?)[a-fA-F0-9]{6}$/; 
//16进制颜色值校验规则 
var isOpa = typeof opa == 'number';
//判断是否有设置不透明度
if (!pattern.test(val)) {
//如果值不符合规则返回空字符
return ''; 
} 
var v = val.replace(/#/, ''); 
//如果有#号先去除#号 
var rgbArr = [];
var rgbStr = '';
for (var i = 0; i < 3; i++) { 
var item = v.substring(i * 2, i * 2 + 2);
var num = parseInt(item, 16); 
rgbArr.push(num); 
}
rgbStr = rgbArr.join();
rgbStr = 'rgb' + (isOpa ? 'a' : '') + '(' + rgbStr + (isOpa ? ',' + opa : '') + ')';
return rgbStr;
}
```

### 追加url参数

```js
export const appendQuery = (url, key, value) => { 
var options = key;
if (typeof options == 'string') {
options = {}; 
options[key] = value;
} 
options = $.param(options);
if (url.includes('?')) {
url += '&' + options 
} else { 
url += '?' + options 
}
return url; 
}
```

## 日期处理

### 1. 检查日期是否有效

该方法用于检测给出的日期是否有效：

```javascript
const isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf());

isDateValid("December 17, 1995 03:24:00");  // true
```

### 2. 计算两个日期之间的间隔

该方法用于计算两个日期之间的间隔时间：

```javascript
const dayDif = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)
    
dayDif(new Date("2021-11-3"), new Date("2022-2-1"))  // 90
```

距离过年还有90天~

### 3. 查找日期位于一年中的第几天

该方法用于检测给出的日期位于今年的第几天：

```javascript
const dayOfYear = (date) => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);

dayOfYear(new Date());   // 307
```

2021年已经过去300多天了~

### 4. 时间格式化

该方法可以用于将时间转化为hour:minutes:seconds的格式：

```javascript
const timeFromDate = date => date.toTimeString().slice(0, 8);
    
timeFromDate(new Date(2021, 11, 2, 12, 30, 0));  // 12:30:00
timeFromDate(new Date());  // 返回当前时间 09:00:00
```

## 字符串处理

### 1. 字符串首字母大写

该方法用于将英文字符串的首字母大写处理：

```javascript
const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1)

capitalize("hello world")  // Hello world
```

### 2. 翻转字符串

该方法用于将一个字符串进行翻转操作，返回翻转后的字符串：

```javascript
const reverse = str => str.split('').reverse().join('');

reverse('hello world');   // 'dlrow olleh'
```

### 3. 随机字符串

该方法用于生成一个随机的字符串：

```javascript
const randomString = () => Math.random().toString(36).slice(2);

randomString();
```

### 4. 截断字符串

该方法可以从指定长度处截断字符串:

```javascript
const truncateString = (string, length) => string.length < length ? string : `${string.slice(0, length - 3)}...`;

truncateString('Hi, I should be truncated because I am too loooong!', 36)   // 'Hi, I should be truncated because...'
```

### 5. 去除字符串中的HTML

该方法用于去除字符串中的HTML元素：

```javascript
const stripHtml = html => (new DOMParser().parseFromString(html, 'text/html')).body.textContent || '';
```

## 三、数组处理

### 1. 从数组中移除重复项

该方法用于移除数组中的重复项：

```javascript
const removeDuplicates = (arr) => [...new Set(arr)];

console.log(removeDuplicates([1, 2, 2, 3, 3, 4, 4, 5, 5, 6]));
```

### 2. 判断数组是否为空

该方法用于判断一个数组是否为空数组，它将返回一个布尔值：

```javascript
const isNotEmpty = arr => Array.isArray(arr) && arr.length > 0;

isNotEmpty([1, 2, 3]);  // true
```

### 3. 合并两个数组

可以使用下面两个方法来合并两个数组：

```javascript
const merge = (a, b) => a.concat(b);

const merge = (a, b) => [...a, ...b];
```

## 数字操作

### 1. 判断一个数是奇数还是偶数

该方法用于判断一个数字是奇数还是偶数：

```javascript
const isEven = num => num % 2 === 0;

isEven(996); 
```

### 2. 获得一组数的平均值

```javascript
const average = (...args) => args.reduce((a, b) => a + b) / args.length;

average(1, 2, 3, 4, 5);   // 3
```

### 3. 获取两个整数之间的随机整数

该方法用于获取两个整数之间的随机整数

```javascript
const random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);

random(1, 50);
```

### 4. 指定位数四舍五入

该方法用于将一个数字按照指定位进行四舍五入：

```javascript
const round = (n, d) => Number(Math.round(n + "e" + d) + "e-" + d)

round(1.005, 2) //1.01
round(1.555, 2) //1.56
```

## 颜色操作

### 1. 将RGB转化为十六机制

该方法可以将一个RGB的颜色值转化为16进制值：

```javascript
const rgbToHex = (r, g, b) => "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);

rgbToHex(255, 255, 255);  // '#ffffff'
```

### 2. 获取随机十六进制颜色

该方法用于获取一个随机的十六进制颜色值：

```javascript
const randomHex = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, "0")}`;

randomHex();
```

## 浏览器操作

### 1. 复制内容到剪切板

该方法使用 navigator.clipboard.writeText 来实现将文本复制到剪贴板：

```javascript
const copyToClipboard = (text) => navigator.clipboard.writeText(text);

copyToClipboard("Hello World");
```

### 2. 清除所有cookie

该方法可以通过使用 document.cookie 来访问 cookie 并清除存储在网页中的所有 cookie：

```javascript
const clearCookies = document.cookie.split(';').forEach(cookie => document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`));
```

### 3. 获取选中的文本

该方法通过内置的 getSelection 属性获取用户选择的文本：

```javascript
const getSelectedText = () => window.getSelection().toString();

getSelectedText();
```

### 4. 检测是否是黑暗模式

该方法用于检测当前的环境是否是黑暗模式，它是一个布尔值：

```javascript
const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches

console.log(isDarkMode)
```

### 5. 滚动到页面顶部

该方法用于在页面中返回顶部：

```javascript
const goToTop = () => window.scrollTo(0, 0);

goToTop();
```

### 6. 判断当前标签页是否激活

该方法用于检测当前标签页是否已经激活：

```javascript
const isTabInView = () => !document.hidden; 
```

### 7. 判断当前是否是苹果设备

该方法用于检测当前的设备是否是苹果的设备：

```javascript
const isAppleDevice = () => /Mac|iPod|iPhone|iPad/.test(navigator.platform);

isAppleDevice();
```

### 8. 是否滚动到页面底部

该方法用于判断页面是否已经底部：

```javascript
const scrolledToBottom = () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;
```

### 9. 重定向到一个URL

该方法用于重定向到一个新的URL：

```javascript
const redirect = url => location.href = url

redirect("https://www.google.com/")
```

### 10. 打开浏览器打印框

该方法用于打开浏览器的打印框：

```javascript
const showPrintDialog = () => window.print()
```

## 其他操作

### 1. 随机布尔值

该方法可以返回一个随机的布尔值，使用Math.random()可以获得0-1的随机数，与0.5进行比较，就有一半的概率获得真值或者假值。

```javascript
const randomBoolean = () => Math.random() >= 0.5;

randomBoolean();
```

### 2. 变量交换

可以使用以下形式在不适用第三个变量的情况下，交换两个变量的值：

```javascript
[foo, bar] = [bar, foo];
```

### 3. 获取变量的类型

该方法用于获取一个变量的类型：

```javascript
const trueTypeOf = (obj) => Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();

trueTypeOf('');     // string
trueTypeOf(0);      // number
trueTypeOf();       // undefined
trueTypeOf(null);   // null
trueTypeOf({});     // object
trueTypeOf([]);     // array
trueTypeOf(0);      // number
trueTypeOf(() => {});  // function
```

### 4. 华氏度和摄氏度之间的转化

该方法用于摄氏度和华氏度之间的转化：

```javascript
const celsiusToFahrenheit = (celsius) => celsius * 9/5 + 32;
const fahrenheitToCelsius = (fahrenheit) => (fahrenheit - 32) * 5/9;

celsiusToFahrenheit(15);    // 59
celsiusToFahrenheit(0);     // 32
celsiusToFahrenheit(-20);   // -4
fahrenheitToCelsius(59);    // 15
fahrenheitToCelsius(32);    // 0
```

### 5. 检测对象是否为空

该方法用于检测一个JavaScript对象是否为空：

```javascript
const isEmpty = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object;
```

## 截取字符串

substr()、substring()和 slice() 方法都可以用来截取字符串。

#### （1） slice()

slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：

```javascript
string.slice(start,end)
```

该方法有两个参数：

- start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。
- end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。

上面说了，如果start是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：

```javascript
let str = "abcdefg";
str.slice(1,6);   // 输出结果："bcdef" 
str.slice(1);     // 输出结果："bcdefg" 
str.slice();      // 输出结果："abcdefg" 
str.slice(-2);    // 输出结果："fg"
str.slice(6, 1);  // 输出结果：""
```

注意，该方法返回的子串**包括开始处的字符**，但**不包括结束处的字符**。

#### （2） substr()

substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：

```javascript
string.substr(start,length)
```

该方法有两个参数：

- start	必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。
- length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。

```javascript
let str = "abcdefg";
str.substr(1,6); // 输出结果："bcdefg" 
str.substr(1);   // 输出结果："bcdefg" 相当于截取[1,str.length-1]
str.substr();    // 输出结果："abcdefg" 相当于截取[0,str.length-1]
str.substr(-1);  // 输出结果："g"
```

#### （3） substring()

substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：

```javascript
string.substring(from, to)
```

该方法有两个参数：

- from：必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。
- to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。

**注意：** 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。

```javascript
let str = "abcdefg";
str.substring(1,6); // 输出结果："bcdef" [1,6)
str.substring(1);   // 输出结果："bcdefg" [1,str.length-1]
str.substring();    // 输出结果："abcdefg" [0,str.length-1]
str.substring(6,1); // 输出结果 "bcdef" [1,6)
str.substring(-1);  // 输出结果："abcdefg"
```

注意，该方法返回的子串**包括开始处的字符**，但**不包括结束处的字符**。





# TypeScript



##  基础类型

| 类型           | 示例                                                         |      |
| -------------- | ------------------------------------------------------------ | ---- |
| Number         | let count: number = 10;                                      |      |
| Boolean        | let isDone: boolean = false;                                 |      |
| String         | let name: string = 'Semliker';                               |      |
| Array          | let list: number[] = [1,2,3];   <br/>let list: Array<number> = [1,2,3]; |      |
| Any (动态类型) | let notSure: any = 4;<br/>notSure = "maybe a string instead";<br/>notSure = false; |      |



#### Enum

```javascript
enum Direction {
	NORTH,
    SOUTH,
    EAST,
    WEST
};

let dir: Direction = Direction.NORTH;
```

默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。

当然我们也可以设置 NORTH 的初始值，比如：

```javascript
enum Direction {
	NORTH = 3,
  SOUTH,
  EAST,
  WEST
};
```

在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。

```javascript
enum Direction {
  NORTH = 'NORTH',
  SOUTH = 'SOUTH',
  EAST = 'EAST',
  WEST = 'WEST',
}
```



#### Tuple

元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。

```javascript
let x: [string, number];
x = ['semlinker', 10]; // 正常赋值
x = [10, 'semlinker']; // 类型不匹配
```

当访问一个已知索引的元素，会得到正确的类型：

```javascript
console.log(x[0].substr(1)); // OK
// Error, 'number' does not have 'substr' method
console.log(x[1].substr(1));
```

当访问一个越界的元素，会使用联合类型替代：

```javascript
x[3] = 'world'; // OK, 字符串可以赋值给(string | number) 类型
console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString 方法
x[6] = true; // Error, 布尔不是(string | number) 类型
```

#### Void

某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：

```javascript
// 声明函数返回值为void
function warnUser(): void { 
    console.log("This is my warning message");
}

=> tsc =>  
function warnUser() {
	console.log("This is my warning message");
}
```



#### Never

`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。

```javascript
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {}
}
```

### 类型断言

通过这种方式可以告诉编译器，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。

类型断言有两种形式：

- “尖括号”语法

```javascript
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```

- as 语法

```javascript
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```

### 联合类型

联合类型（Union Types）表示取值可以为多种类型中的一种 未赋值时联合类型上只能访问两个类型共有的属性和方法

```ts
let name: string | number;
console.log(name.toString());
name = 1;
console.log(name.toFixed(2));
name = "hello";
console.log(name.length);
```






## 函数

### 箭头函数

```javascript
myBooks.forEach(() => console.log('Done reading'));

myBooks.forEach(title => console.log(title));

myBooks.forEach((title, idx, arr) => 
  console.log(idx + '-' + title);
);

myBooks.forEach((title, idx, arr) => {
  console.log(idx + '-' + title);
});
```

- 使用示例

```javascript
// 未使用箭头函数
function Book() {
  let self = this;
  self.publishDate = 2016;
  setInterval(function() {
    console.log(self.publishDate);
  }, 1000);
}

// 使用箭头函数
function Book() {
  this.publishDate = 2016;
  setInterval(() => {
    console.log(this.publishDate);
  }, 1000);
}
```

### 参数类型和返回类型

```javascript
function createUserId(name: string, id: number): string {
  return name + id;
}
```

### 函数类型

```javascript
let IdGenerator: (chars: string, nums: number) => string;

function createUserId(name: string, id: number): string {
  return name + id;
}
IdGenerator = createUserId;
```

### 可选参数及默认参数

```javascript
// 可选参数
function createUserId(name: string, age?: number, 
  id: number): string {
    return name + id;
}

// 默认参数
function createUserId(name: string = 'Semlinker', age?: number, 
  id: number): string {
    return name + id;
}
```

### 剩余参数

```javascript
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
  });
}

let a = [];
push(a, 1, 2, 3);
```

## 数组

### 数组解构

```javascript
let x: number, let y: number ,let z: number;
let five_array = [0,1,2,3,4];
[x,y,z] = five_array;
```

### 数组展开运算符

```javascript
let two_array = [0,1];
let five_array = [...two_array,2,3,4];
```

### 数组循环

```javascript
let colors: string[] = ["red", "green", "blue"];
for(let i in colors) {
  console.log(i);
}
```

##  Object

### 对象解构

```javascript
let person = {
  name: 'Semlinker',
  gender: 'male'
};

let {name, gender} = person;
```

### 对象展开运算符

```javascript
let person = {
  name: 'Semlinker',
  gender: 'male',
  address: 'Xiamen'
};

// 组装对象
let personWithAge = {...person, age: 31};

// 获取除了某些项外的其它项
let {name, ...rest} = person;
```

### TypeScript Interface

在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。

TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象](https://ts.xcatliu.com/advanced/class-and-interfaces.html#类实现接口)以外，也常用于对「对象的形状（Shape）」进行描述。

#### 对象的形状

```javascript
interface Person {
  name: string;
  age: number;
}

let semlinker: Person = {
  name: 'Semlinker',
  age: 31
};
```

#### 可选 | 只读属性

```javascript
interface Person {
  readonly name: string;
  age?: number;
}
```

只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。

```javascript
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

## Class 类

在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。

在 TypeScript 中，我们可以通过 `Class` 关键字来定义一个类：

```javascript
class Greeter {
   static cname: string = 'Greeter'; // 静态属性
   greeting: string; // 成员属行

   constructor(message: string) { // 构造函数 - 执行初始化操作
     this.greeting = message;
   }
    static getClassName() { // 静态方法
      return 'Class name is Greeter';
    }
    greet() { // 成员方法
      return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
```

## Accessors

我们可以通过 `getter` 和 `setter` 方法来实现数据的封装和有效性校验，防止出现异常数据。

```javascript
let passcode = "hello angular 5";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "hello angular 5") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}
```

##  Inheritance

继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类 (称为子类、子接口) 继承另外的一个类 (称为父类、父接口) 的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种 [is-a](https://zh.wikipedia.org/wiki/Is-a) 关系。

我们可以通过 `extends` 关键字来实现继承：

```javascript
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
sam.move();
```

##  Generics

泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。

### 泛型接口

```javascript
interface GenericIdentityFn<T> {
    (arg: T): T;
}
```

### 泛型类

```javascript
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

### 使用示例

```javascript
interface Hero { // Hero 接口
    id: number;
    name: string;
}

getHeroes(): Observable<Hero[]> {
  return Observable.of([
     { id: 1, name: 'Windstorm' },
     { id: 13, name: 'Bombasto' },
     { id: 15, name: 'Magneta' },
     { id: 20, name: 'Tornado' }
  ]);
}
```

上面 `getHeroes(): Observable<Hero[]>` 表示调用 `getHeroes()` 方法后返回的是一个 Observable 对象，`<Hero[]>` 用于表示该 Observable 对象的观察者，将会收到的数据类型。示例中表示将会返回 `<Hero[]>` 英雄列表。

## tsconfig.json

### tsconfig.json 的作用

- 用于标识 TypeScript 项目的根路径；
- 用于配置 TypeScript 编译器；
- 用于指定编译的文件。

### tsconfig.json 重要字段

- files - 设置要编译的文件的名称；
- include - 设置需要进行编译的文件，支持路径模式匹配；
- exclude - 设置无需进行编译的文件，支持路径模式匹配；
- compilerOptions - 设置与编译流程相关的选项。

compilerOptions 支持很多选项，常见的有 `baseUrl`、 `target`、`baseUrl`、 `moduleResolution` 和 `lib` 等。

### tsconfig.json 示例

```javascript
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "node",
    "isolatedModules": false,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true,
    "types": ["vite/client"],
    "baseUrl": ".",
    "lib": ["dom", "esnext"],
    "paths": {
      "@/*": ["src/*"],
      "@comp/*": ["src/components/*"],
      "@api/*": ["src/api/*"],
      "@vi/*": ["src/views/*"],
      "@h/*": ["src/hooks/*"]
    }
  },
  "exclude": ["node_modules", "dist"]
}

```

### compilerOptions 选项

```ts
{
  "compilerOptions": {

    /* 基本选项 */
    "target": "es5",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'
    "module": "commonjs",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'
    "lib": [],                             // 指定要包含在编译中的库文件
    "allowJs": true,                       // 允许编译 javascript 文件
    "checkJs": true,                       // 报告 javascript 文件中的错误
    "jsx": "preserve",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'
    "declaration": true,                   // 生成相应的 '.d.ts' 文件
    "sourceMap": true,                     // 生成相应的 '.map' 文件
    "outFile": "./",                       // 将输出文件合并为一个文件
    "outDir": "./",                        // 指定输出目录
    "rootDir": "./",                       // 用来控制输出目录结构 --outDir.
    "removeComments": true,                // 删除编译后的所有的注释
    "noEmit": true,                        // 不生成输出文件
    "importHelpers": true,                 // 从 tslib 导入辅助工具函数
    "isolatedModules": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.

    /* 严格的类型检查选项 */
    "strict": true,                        // 启用所有严格类型检查选项
    "noImplicitAny": true,                 // 在表达式和声明上有隐含的 any类型时报错
    "strictNullChecks": true,              // 启用严格的 null 检查
    "noImplicitThis": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误
    "alwaysStrict": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'

    /* 额外的检查 */
    "noUnusedLocals": true,                // 有未使用的变量时，抛出错误
    "noUnusedParameters": true,            // 有未使用的参数时，抛出错误
    "noImplicitReturns": true,             // 并不是所有函数里的代码都有返回值时，抛出错误
    "noFallthroughCasesInSwitch": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    "moduleResolution": "node",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)
    "baseUrl": "./",                       // 用于解析非相对模块名称的基目录
    "paths": {},                           // 模块名到基于 baseUrl 的路径映射的列表
    "rootDirs": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容
    "typeRoots": [],                       // 包含类型声明的文件列表
    "types": [],                           // 需要包含的类型声明文件名列表
    "allowSyntheticDefaultImports": true,  // 允许从没有设置默认导出的模块中默认导入。

    /* Source Map Options */
    "sourceRoot": "./",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    "mapRoot": "./",                       // 指定调试器应该找到映射文件而不是生成文件的位置
    "inlineSourceMap": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    "inlineSources": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    "experimentalDecorators": true,        // 启用装饰器
    "emitDecoratorMetadata": true          // 为装饰器提供元数据的支持
  }
}
```






## 编码规范

### 变量和函数

使用驼峰（camelCase）命名变量和函数名

```javascript
var FooVar;
function BarFunc() { }
```

**Good**

```javascript
var fooVar;
function barFunc() { }
```

### 类

使用帕斯卡（PascalCase）命名类名

**Bad**

```javascript
class foo { }
```

**Good**

```javascript
class Foo { }
```

使用帕斯卡（PascalCase）命名类成员与方法

**Bad**

```javascript
class Foo {
    Bar: number;
    Baz() { }
}
```

**Good**

```javascript
class Foo {
    bar: number;
    baz() { }
}
```

### 接口

- 使用帕斯卡（PascalCase）命名接口
- 使用驼峰（camelCase）命令成员
- 误使用 `I` 前缀

**Bad**

```javascript
interface IFoo { }
```

**Good**

```javascript
interface Foo { }
```

### 类型

- 使用帕斯卡（PascalCase）命名
- 使用驼峰（camelCase）命令成员

### 命名空间

使用帕斯卡（PascalCase）命名

**Bad**

```javascript
namespace foo { }
```

**Good**

```javascript
namespace Foo { }
```

### 枚举

使用帕斯卡（PascalCase）命名枚举

**Bad**

```javascript
enum color { }
```

**Good**

```javascript
enum Color { }
```



### Null vs Undefined

最好不好显式使用不可用的值

**Bad**

```javascript
let foo = { x:123, y:undefined };
```

**Good**

```javascript
let foo: { x:number, y?:number } = { x:123 };
```

通常使用 undefined（ 而不是返回一个类似于 { valid:boolean, value?:Foo } 的对象 ）

**Bad**

```javascript
return null;
```

**Good**

```javascript
return undefined;
```

参考 Node.js 回调函数 Error First 风格（若未发生异常，error 参数值设置为 null）

**Bad**

```javascript
cb(undefined)
```

**Good**

```javascript
cb(null)
```

避免使用值比较判断对象是否为 null 或 undefined

**Bad**

```javascript
if (error === null)
```

**Good**

```javascript
if (error)
```

### 数组

声明数组时使用 `foos:Foo[]` 而不是 `foos:Array<Foo>`，便于阅读

### 类型 vs 接口

当你需要复合类型时，使用 type

```javascript
type Foo = number | { someProperty: number }
```

当你需要继承或实现时，使用 interface

```javascript
interface Foo {
  foo: string;
}

interface FooBar extends Foo {
  bar: string;
}

class X implements FooBar {
  foo: string;
  bar: string;
}
```

## 风格指南

1. 使用箭头函数代替匿名函数表达式。

2. 只要需要的时候才把箭头函数的参数括起来。比如，

   ```
   (x) => x + x
   ```

    是错误的，下面是正确的做法：

   - `x => x + x`
   - `(x,y) => x + y`
   - `<T>(x: T, y: T) => x === y`

3. 总是使用 `{}` 把循环体和条件语句括起来。

4. 小括号里开始不要有空白。逗号，冒号，分号后要有一个空格。比如：

   - `for (let i = 0, n = str.length; i < 10; i++) { }`
   - `if (x < 10) { }`
   - `function f(x: number, y: string): void { }`

5. 每个变量声明语句只声明一个变量 。比如：使用 `let x = 1; var y = 2;` 而不是 `let x = 1, y = 2;`）。

6. 如果函数没有返回值，最好使用 `void`



### 接口(interface)

#### 定义使用

```tsx
interface User {
  brief: string;
}

const state: User = reactive({
  brief: "",
});
```

### 非必填(?)



字段为**非必填**, 用"?"标记:

```ts
interface User {
  brief: string;
  test?: string;
}
const state: User = reactive({
  brief: "",
});
```

### 用接口定义函数

接口不仅可以定义对象, 还可以定义函数:

```tsx
// 声明接口
interface Core {
    (n:number, s:string):[number,string]
}

// 声明函数遵循接口定义
const core:Core = (a,b)=>{
    return [a,b];
}
```

### 用接口定义类

先简单看下如何给类定义接口, 后面的课程具体讲类:

```tsx
// 定义
interface Animate {
    head:number;
    body:number;
    foot:number;
    eat(food:string):void;
    say(word:string):string;
}
```

```tsx
// implements
class Dog implements Animate{
    head=1;
    body=1;
    foot=1;
    eat(food){
        console.log(food);
    }
    say(word){
        return word;
    }
}
```

### 交叉类型(&)

交叉类型是将多个类型合并为一个类型, 表示"并且"的关系,用&连接多个类型, 常用于对象合并:

```tsx
interface A {a:number};
interface B {b:string};

const a:A = {a:1};
const b:B = {b:'1'};
const ab:A&B = {...a,...b};
```

### 联合类型(|)

交叉类型也是将多个类型合并为一个类型, 表示"或"的关系,用|连接多个类型:

```tsx
function setWidth(el: HTMLElement, width: string | number) {
    el.style.width = 'number' === typeof width ? `${width}px` : width;
}
```

### 定义倒计时

```ts
      setTimeout(async () => {
        await ConutSort();
        await GetFySortTitleAsync();
        dataList.spinning = false;
      }, 2000);
    });
```

###  readonly 只读属性

readonly 修饰的变量只能在**构造函数**中初始化 TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly readonly 实际上只是在编译阶段进行代码检查。

```ts
class Animal {
  public readonly name: string;
  constructor(name: string) {
    this.name = name;
  }
  changeName(name: string) {
    this.name = name; //这个ts是报错的
  }
}

let a = new Animal("hello");
```






# Vue



##  生命周期

```js
setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method
//挂载阶段
onBeforeMount() : 组件挂载到节点上之前执行的函数。
onMounted() : 组件挂载完成后执行的函数。
//更新
onBeforeUpdate(): 组件更新之前执行的函数。
onUpdated(): 组件更新完成之后执行的函数。
//销毁
onBeforeUnmount(): 组件卸载之前执行的函数。
onUnmounted(): 组件卸载完成后执行的函数
onActivated(): 被包含在<keep-alive>中的组件，会多出两个生命周期钩子函数。被激活时执行。
onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。
onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数（不太会用。还在了解中）
```



## 基础指令

### 文本插值

```js
{{ }}
```

### v-once

- v-once 用于指定元素或者组件只渲染一次
- 当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过；
- 该指令可以用于性能优化；
- 如果是子节点，也是只会渲染一次

```html
<span v-once>这个将不会改变: {{ msg }}</span>
```

### v-html

该指令后面往往会跟上一个string类型会将string的html解析出来并且进行渲染

```html
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

### v-if

```vue
<h1 v-if="awesome">Vue is awesome!</h1>
<h1 v-else>Oh no 😢</h1>
```

### v-show

cbbaa tfftt只是简单地切换元素的 CSS property `display`。

```vue
<h1 v-show="ok">Hello!</h1>
```

### v-for

- v-for的基本格式是 "item in 数组
- v-for也支持遍历对象，并且支持有一二三个参数

1. 一个参数： "value in object";
2. 二个参数： "(value, key) in object";
3. 三个参数： "(value, key, index) in object";

- v-for同时也支持数字的遍历

#### 基于一个数组来渲染一个列表

```vue
<ul id="example-1">
  <li v-for="item in items" :key="item.message">
    {{ item.message }}
  </li>
</ul>
```

```js
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
```

可选的第二个参数，即当前项的索引。

```vue
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
```

###### 以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法：

```vue
<div v-for="item of items"></div>
```

####   遍历对象

```vue
<ul id="v-for-object" class="demo">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>
```

```js
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
```

提供第二个的参数为 property 名称 (也就是键名)：

```vue
<div v-for="(value, name) in object">
  {{ name }}: {{ value }}
</div>
```

还可以用第三个参数作为索引：

```vue
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```

唯一key

```vue
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
```



####  使用值范围

`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。

```vue
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
```

#### 在template使用

```vue
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
```

#### 自定义组件上使用

```vue
<my-component v-for="item in items" :key="item.id"></my-component>
```



##### for if同时使用

当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量，这时，可以把 v-for 移到 <template> 中

```vue
//示例1
<template v-for="(item, index) in ResultList" :key="index">
   <a @click="onk(item.path)" v-if="item.identity">
    {{item.title}}
   </a>
</template>
//示例2
<template v-for="todo in todos" :key="todo.name">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```



### v-bind

```vue
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a :[key]="url"> ... </a>
```

#### img绑定属性

```vue
<img v-bind:src="imgUrl"/>
```

#### 动态绑定

```vue
<a v-bind:[attributeName]="url"> ... </a>
```

> **v-bind 动态绑定class（对象语法）**
>
> - 可以通过{ }绑定一个类
> - 也可以通过判断，传入多个值
> - 和普通类同时存在，并不冲突
> - 如果过于复杂，可以放在一个methods或者computed中

#### 对象语法

```js

<template>
  <div id="snHeader">
      <el-menu
        :class="{active: isActive , line: isLine}"
      >
        <button @click="but()">a</button>
      </el-menu>
  </div>
</template>

<script>

  export default {
    name: "SnHeader",
    components: {},
    data() {
      return {
        active: 'el-menu',
        isActive: true,  //设置boolean值决定是否启用
        isLine: true
      };
    },

    methods: {
      but() {
        this.isActive = !this.isActive
        // return { active: this.isActive, line: this.isLine }
      },
    }
  };
</script>

<style lang="scss" scoped>
    
    .active {
      color: blue;
      @apply bg-red-400;
    }
  }

</style>

```

#### **数组语法**

```vue
<div id="app">
  <!-- 如果在[]数组里的元素加了引号，代表他是一个字符串，而不是引用一个变量 -->
  <h2 :class="[active,line]">{{massage}}</h2>
  <h2 :class="['active','line']">{{massage}}</h2>
</div>
```

####  绑定style

```vue
<div id="app">
<!-- <h2 :style="{key(属性名):value(属性值)}">{{massage}}</h2> -->
  <!-- 这里要加' '要不然vue会去解析50px这个变量然后报错 -->
  <h2 :style="{fontSize: '50px'}">{{massage}}</h2>
  
  <!-- finalSize当成一个变量在使用 -->
  <h2 :style="{fontSize: finalSize}">{{massage}}</h2>

  <!-- 也可以拼接 -->
  <h2 :style="{fontSize: finalSize + 'px',color:finalColor}">{{massage}}</h2>

  <!-- 数组语法 -->
  <h2 :style="[baseStyle,baseStyle1]">{{massage}}</h2>
</div>

<body>
	<script src="../js/vue.js"></script>
	<script>
		const app = new Vue({
			el: "#app",
			data: {
				massage: "你好",
        finalSize: 100,
        finalColor: 'red',
        baseStyle:{color:'red'},
        baseStyle1:{fontSize:'75px'}
			}
		})
	</script>
</body>
```

### v-on:click

#### 基础语法

```vue
<a v-on:click="doSomething">...</a>
```

动态的事件名绑定处理函数

```vue
<a v-on:[eventName]="doSomething"> ... </a>
```

```vue
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a @[event]="doSomething"> ... </a>
```

#### 事件修饰符

```vue
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a
    
    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

#### 按键修饰符

```vue
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```

#### .exact 修饰符

修饰符允许你控制由精确的系统修饰符组合触发的事件

```vue
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button v-on:click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button v-on:click.exact="onClick">A</button>
```

#### 鼠标按钮修饰符

```
.left
.right
.middle
```

### v-model

`v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。

#### 文本

```vue
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```

#### 多行文本

```vue
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
```

#### 复选框

单个复选框，绑定到布尔值：

```vue
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
```

多个复选框，绑定到同一个数组：

```vue
<div id='example-3'>
  <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
  <label for="jack">Jack</label>
  <input type="checkbox" id="john" value="John" v-model="checkedNames">
  <label for="john">John</label>
  <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
  <label for="mike">Mike</label>
  <br>
  <span>Checked names: {{ checkedNames }}</span>
</div>
```

```js
new Vue({
  el: '#example-3',
  data: {
    checkedNames: []
  }
})
```

单选按钮

```vue
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br>
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>
```

```js
new Vue({
  el: '#example-4',
  data: {
    picked: ''
  }
})
```

#### 选择框

单选时：

```vue
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>
```

```js
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
```

多选时 (绑定到一个数组)：

```vue
<div id="example-6">
  <select v-model="selected" multiple style="width: 50px;">
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <br>
  <span>Selected: {{ selected }}</span>
</div>
```

```js
new Vue({
  el: '#example-6',
  data: {
    selected: []
  }
})
```

用 `v-for` 渲染的动态选项：

```vue
<select v-model="selected">
  <option v-for="option in options" v-bind:value="option.value">
    {{ option.text }}
  </option>
</select>
<span>Selected: {{ selected }}</span>
```

```js
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})
```

#### 值绑定

```vue
<!-- 当选中时，`picked` 为字符串 "a" -->
<input type="radio" v-model="picked" value="a">

<!-- `toggle` 为 true 或 false -->
<input type="checkbox" v-model="toggle">

<!-- 当选中第一个选项时，`selected` 为字符串 "abc" -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>
```

### 修饰符

- .lazy：默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步：

  ```html
  <!-- 在“change”时而非“input”时更新 -->
  <input v-model.lazy="msg" />
  复制代码
  ```

- .number：如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：

  ```html
  <input v-model.number="age" type="number" />
  复制代码
  ```

- .trim：如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：

```html
<input v-model.trim="msg" />
```








### v-text

都是用于将数据显示在界面中，但是通常只接受一个string类型

用于更新元素的 textContent

```vue
<div v-text="message"></div>
<div v-text="msg"></div> 等价于 <div>{{msg}}</div>
```

### v-pre

- v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签
- 跳过不需要编译的节点，加快编译的速度

```html
<h2 v-pre>{{massage}}</h2> <!-- {{massage}} -->
```

### v-cloak

保持在元素上直到关联组件实例结束编译； 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实 例准备完毕。

### watch

侦听的是data中的数据 默认情况下侦听data数据本身的改变（内部侦听的改变是不能侦听的） 如：侦听data中的 msg 的变化，由`msg: { name: "wx", age: 20 }`改变成`msg: { name: "wxwx", age: 20 }`是侦听不到`msg.name`的变化的。

需要侦听到内部的变化需要做如下处理: 对msg做深度侦听，不在是写成函数形式，而写成对象形式

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("侦听msg内部数据是不是变化了", msg.name);
      },
      deep: true, // 深度侦听
    }
}
methods: {
    changeMsgName() {
      this.msg.name = "wxwx"
    }
}
```

可执行了以上代码的console，所以msg内部数据的改变有被侦听到。

watch还可以在页面渲染的时候对需要立即执行的data数据进行侦听，需要在对象中加上一个 immediate 就行

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("newInfo", newInfo, "oldInfo", oldInfo)
      },
      deep: true, // 深度侦听
      immediate: true // 立即执行
    }
}
```

页面渲染时会有以上console的打印，但是 oldInfo 是 undefined。

注意：当去改变data数据中对象的内部值时，newInfo 和 oldInfo 的值都是改变后的值

通过一下方式可以拿到oldInfo（旧值）

```js
watch: {
    "msg.name": function(newName, oldName) {
      console.log(newName, oldName);
    },
},
```

以上console打印 wx wxx

```js
watch: {
    msg: {
      handler: function(newInfo, oldInfo) {
        console.log("newValue:", newInfo.name, "oldValue:", oldInfo.name);
      },
      deep: true, // 深度侦听
    }
},
methods: {
    changeMsgName() {
      this.msg.name = "wxwx";
    },
}
```

以上console输出的 newInfo 和 oldInfo 都是 "wxwx"

#### watch 实现侦听的其他方式

1. 只侦听某个对象中的值

```js
watch: {
    "msg.name": function(newName, oldName) {
      console.log(newName, oldName);
    },
},
```

1. 使用this.$watch来侦听

```js
created() {
    this.$watch("msg", function(newInfo, oldInfo) {
      console.log(newInfo, oldInfo);
    }, {
      deep: true,
      immediate: true
    })
}
```



## 组件基础

### 基本示例

```js
// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})
```

Vue 根实例中，把组件作为自定义元素来用：

```
 <button-counter></button-counter>
```

### 组件名

```js
Vue.component('my-component-name', { /* ... */ })
```

这些组件是**全局注册的**。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (`new Vue`) 的模板中

### 局部注册

通过一个普通的 JavaScript 对象来定义组件：

```js
var ComponentA = { /* ... */ }

```

然后在 `components` 选项中定义你想要使用的组件：

```js
new Vue({
  components: {
    'component-a': ComponentA,
  }
})
```

### 模块中局部注册

```js
import ComponentA from './ComponentA'
export default {
  components: {
    ComponentA,
  },
  // ...
}
```

### 自动化全局注册

可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为[基础组件](https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐)，它们会在各个组件中被频繁的用到。

```js
import Vue from 'vue'
import upperFirst from 'lodash/upperFirst'
import camelCase from 'lodash/camelCase'

const requireComponent = require.context(
  // 其组件目录的相对路径
  './components',
  // 是否查询其子目录
  false,
  // 匹配基础组件文件名的正则表达式
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName => {
  // 获取组件配置
  const componentConfig = requireComponent(fileName)

  // 获取组件的 PascalCase 命名
  const componentName = upperFirst(
    camelCase(
      // 获取和目录深度无关的文件名
      fileName
        .split('/')
        .pop()
        .replace(/\.\w+$/, '')
    )
  )
  // 全局注册组件
  Vue.component(
    componentName,
    // 如果这个组件选项是通过 `export default` 导出的，
    // 那么就会优先使用 `.default`，
    // 否则回退到使用模块的根。
    componentConfig.default || componentConfig
  )
})
```



### Prop 向子组件传递数据

Prop 是你可以在组件上注册的一些自定义 attribute。为了给博文组件传递内容



```vue

<template>
  <div class="index-si-count">
        <div class="index-si-count-frame-title">文章数量:</div>
        <div class="index-si-count-frame-text">{{ ArticleCount }} 篇</div>
        <div class="index-si-count-frame-title">总字段数:</div>
        <div class="index-si-count-frame-text">{{ TextCount }} 字</div>
  </div>
</template>

<script>
  export default {
    props: ['ArticleCount', 'TextCount'],
  }
</script>
```

```vue
      <!-- 站点统计框 -->
      <blog-information
        :ArticleCount="ArticleCount"
        :TextCount="textCount"
      ></blog-information>
```

#### 数组方式：

```tsx
<template>
 <a>{{ title }}</a>
</template>

<script>
  export default {
    props: ['title'],
  }
</script>

```

并想要为每篇博文渲染一个组件：

```html
 <!-- 标签框内容 -->
      <div class="index-si-tag">
        <blog-tag
          v-for="Labeslss in Labels"
          :key="Labeslss.labelId"
          :title=" Labeslss.labelName"
          @click="TagSkip(Labeslss.labelId)"
        ></blog-tag>
      </div>
```

## 事件处理

### 内联处理器中的方法

有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：

```javascript
<button @click="warn('Form cannot be submitted yet.', $event)">Submit</button>
    let warn = async (message: any, event: any) => {
      // 现在可以访问到原生事件
      if (event) {
        event.preventDefault()
      }
      alert(message)
    }
```

### 多事件处理器

事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：

```javascript
<button @click="one($event), two($event)">Submit</button>
methods: {
  one(event) {
    // 第一个事件处理器逻辑...
  },
  two(event) {
   // 第二个事件处理器逻辑...
  }
}
```

### 事件修饰符

- .stop：阻止事件冒泡
- .prevent：阻止默认事件发生
- .capture：捕获冒泡，即有冒泡发生时，有该修饰符的dom元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件
- .self：将事件绑定到自身，只有自身才能触发，通常用于避免冒泡事件的影响
- .once：设置事件只触发一次
- .passive：用于对DOM的默认事件进行性能优化
- .native：在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加'. native'事件是无法触 发的。

### 按键别名

- .enter
- .tab
- .delete (捕获“删除”和“退格”键)
- .esc
- .space
- .up
- .down
- .left
- .right

### 系统修饰键

可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。

- .ctrl
- .alt
- .shift
- .meta

注意修饰键与常规按键不同，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 `ctrl` 的情况下释放其它按键，才能触发 `keyup.ctrl`。而单单释放 `ctrl` 也不会触发事件。

### .exact 修饰符

`.exact` 修饰符允许你控制由精确的系统修饰符组合触发的事件。

```html
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button @click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button @click.exact="onClick">A</button>
```

## **keep-alive**



### 默认缓存所有组件

```vue
<router-view  class="content" v-slot="{ Component }">
  <keep-alive>
    <component :is="Component" />
  </keep-alive>
</router-view>
```

### 搭配`<router-view />`路由使用

Vue3.0配合的slot插槽使用，使用is来绑定对应路由的组件。

```vue
<template> 
    <router-view v-slot="{ Component }"> 
    <keep-alive> 
        <component :is="Component" v-if="$route.meta.keepAlive"/> 
    </keep-alive> 
        <component :is="Component" v-if="!$route.meta.keepAlive"/> 
    </router-view> 
</template>
```

 router添加meta配置

可以注释哪一页面需要使用缓存，但是也可以不设置，不设置的情况需要将上面的属性都删掉。如果需要更多的缓存限制，可以看底下的参考网站。

```js
const routes = [
  {
    path: '/keepalive',
    name: 'keepalive',
    component: ()=>import('../views/keepalive.vue'),
    meta: {
          keepAlive: false //是否需要使用缓存
    }
  }
 ]
```

### 清除缓存组件

```js
 // beforeRouteLeave()钩子
  beforeRouteLeave(to, from, next) {
      if (to.path === "/goods_detail") {
        from.meta.keepAlive = true;
      } else {
        from.meta.keepAlive = false;
        // this.$destroy()
      }
      next();
    }
```



## Compostition API

### script setup

`script setup`可以和`script`同时存在

```vue
<script>
  export const name = 1
</script>
<script setup>
  import { ref } from 'vue'
  const count = ref(0)
</script>
```



### ref

```vue
<template>
    <div>{{ numberRef }}</div>
</template>
<script setup lang="ts">
import { ref } from 'vue';
const numberRef = ref(0) // ===> Ref<number>
const stringRef = ref("") // ===> Ref<string>
interface IFoo {
    bar: string
}
const fooRef = ref<IFoo>() // ===> Ref<IFoo | undefined>
</script>

```

### reactive

```js
<template>
    <div>{{ book1.bar }}</div>
</template>
<script setup lang="ts">
import { reactive } from 'vue';
interface IFoo {
    bar: string
}
// 第一种
const book1 = reactive<IFoo>({ bar: 'bar' })
// 第二种
const book2: IFoo = reactive({ bar: 'bar' })
// 第三种
const book3 = reactive({ bar: 'bar' }) as IFoo
</script>

```

### computed

`computed`方法会自动推导出类型

```js
<script setup>
  import { computed, ref } from 'vue'

  const count = ref(1)

  // 通过computed获得doubleCount
  const doubleCount = computed(() => {
    return count.value * 2
  })
</script>
```



### toRefs

#### ref和toRef的区别

- ref 和toRef 修改响应式数据都会会影响以前的数据
- ref 数据发生改变，界面就会自动更新
- toRef数据发生改变，界面也不会自动更新

将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 [`ref`](https://link.juejin.cn?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Frefs-api.html%23ref)。

或者说将一个对象身上的所有属性变为响应式数据可以使用。 **以上这些方法都是为了提升性能。主要用的多的还是ref和reactive**

```js
<script setup>
  import { reactive, toRefs } from 'vue'
  // reactive声明响应式数据，用于声明引用数据类型
  const state = reactive({
    name: 'Jerry',
    sex: '男'
  })
  
  // 使用toRefs解构
  const {name, sex} = toRefs(state)
  // template可直接使用{{name}}、{{sex}}
</script>

```

### method

```vue
<template>
  // 调用方法
  <button @click='changeName'>按钮</button>  
</template>
<script setup>
  // 声明method方法
  const changeName = () => {
    state.name = 'Tom'
  }  
</script>
```

### watch

```js
<script setup>
  import { watch, reactive } from 'vue'
  const state = reactive({
    count: 1
  })

  // 声明方法
  const changeCount = () => {
    state.count = state.count * 2
  }

  // 监听count
  watch(
    () => state.count,
    (newVal, oldVal) => {
      console.log(state.count)
      console.log(`watch监听变化前的数据：${oldVal}`)
      console.log(`watch监听变化后的数据：${newVal}`)
    },
    {
      immediate: true, // 立即执行
      deep: true // 深度监听,深度监听,也就是监听复杂数据类型
    }
  )
</script>

```



### watchEffect

这个也是用来监听数据变化，默认就会执行一次所以这里就不需要配置，而且不用指定 `data`,使用哪些响应式数据就监听哪些

```js
let user = reactive({
    name: '小浪',
    age: 21,
})
// 只有 user.name 发生改变这个就会执行
watchEffect(() => {
    console.log(user.name)
});
```

### nextTick

定义: 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

```js
<template>
    <div></div>
</template>
<script setup lang="ts">
import { nextTick } from 'vue';

nextTick(() => {
    // ...
})

// 还可以使用 async/await
async () => {
    await nextTick()
    // ....
}
</script>

```



### provide / inject

提供 和 注入 是很简单理解的

> 实现跨层级组件(祖孙)间通信

在多层嵌套组件中使用，不需要将数据一层一层地向下传递,可以实现跨层级组件通信



 **父组件**

```js
    const info = reactive({
        title: 'Vue3学习'
    })
    //  提供的数据名，数据值
    provide('info', info)
```

**子组件**

```js
    //获取对应数据的值
    const color = inject('info')
```

### 递归组件

一个单文件组件可以通过它的文件名被其自己所引用，但是在有命名冲入的情况下，需要使用import 别名导入来避免冲突

```js
// FooBar.vue
<template>
    <div>
        <!-- 一个单文件组件可以通过它的文件名被其自己所引用 -->
        <FooBar></FooBar>
        <foo-bar></foo-bar>
        <foo-bar-other></foo-bar-other>
    </div>
</template>
<script setup lang="ts">
// 使用 import 别名导入避免冲突
import { default as FooBarOther } from './others/FooBar.vue'
</script>

```

### Teleport 传送组件

 (瞬移)这个组件特别有趣，可以把组件进行传送

```html
<teleport v-if="flag" to=".test">
    <div class="dog">狗子</div>
</teleport>
复制代码
```

`to` 是目标的地址 `body` , `#XXX` , `.XXX` 这些都是 `css` 选择器



### 插槽slot

子组件

```javascript
<template>
  // 匿名插槽
  <slot/>
  // 具名插槽
  <slot name='title'/>
  // 作用域插槽
  <slot name="footer" :scope="state" />
</template>

<script setup>
  import { useSlots, reactive } from 'vue'
  const state = reactive({
    name: '张三',
    age: '25岁'
  })
  
  const slots = useSlots()
  // 匿名插槽使用情况
  const defaultSlot = reactive(slots.default && slots.default().length)
  console.log(defaultSlot) // 1
  // 具名插槽使用情况
  const titleSlot = reactive(slots.title && slots.title().length)
  console.log(titleSlot) // 3
</script>
```

父组件

```javascript
<template>
  <child>
    // 匿名插槽
    <span>我是默认插槽</span>
    // 具名插槽
    <template #title>
      <h1>我是具名插槽</h1>
      <h1>我是具名插槽</h1>
      <h1>我是具名插槽</h1>
    </template>
    // 作用域插槽
    <template #footer="{ scope }">
      <footer>作用域插槽——姓名：{{ scope.name }}，年龄{{ scope.age }}</footer>
    </template>
  </child> 
</template>

<script setup>
  // 引入子组件
  import child from './child.vue'
</script>
```



### props

```js
// 数组:不建议使用
props:[]

// 对象
props:{
 inpVal:{
  type:Number, //传入值限定类型
  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol
  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认
  required: true, //是否必传
  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=>[]
  validator:(value) {
    // 这个值必须匹配下列字符串中的一个
    return ['success', 'warning', 'danger'].indexOf(value) !== -1
  }
 }
}

```



### defineProps

#### 简单使用

```vue
defineProps<{ msg: string }>()
<h1>{{ msg }}</h1>
```



#### 单字段使用

##### 子组件

```tsx
<script setup lang="ts">
 // import { defineProps } from 'vue'
 // defineProps在<script setup>中自动可用，无需导入
 // 需在.eslintrc.js文件中【globals】下配置【defineProps: true】
defineProps({
  title: {
    type: String,
    default: () => 'title',
  },
  oneText: String,
})
</script>
<template>
   <a>{{ title }}</a>
   <div>{{ oneText }}</div>
</template>
```

##### 父组件

```tsx
   <OneTop
     :title="state.dataOne.oneTitle"
     :oneText="state.dataOne.oneText"
   ></OneTop>
```

#### 数组泛型方式

##### 子组件

```tsx
<script lang="ts" setup>
import { method } from '../index'

interface one {
  oneId: number
  oneTitle: string
}

defineProps({
  resultData: {
    type: Array as () => Array<one>, //(string也可以是其他你自定义的接口)
    required: true,
    default: () => [],
  },
})
</script>

<template>
    <div v-for="data in resultData" :key="data.oneId">
          <a @click="method.setModal1Visible(true, data.oneId)">
            {{ data.oneTitle }}
          </a>
        <p>{{ data.oneText }}</p>
    </div>
</template>
```

##### 父组件

```vue
   <!-- list -->
   <OneContent :resultData="state.resultData"></OneContent>
   <!-- end list -->
```

#### Unexpected mutation of "props" prop

```js
<script setup lang="ts">
import { onBeforeUpdate, reactive } from 'vue'
//v-model 不能直接修改
const props = defineProps<{
  result: string
  loading?: boolean
}>()

const state = reactive({
  result: props.result,
})
//在更新之前赋值
onBeforeUpdate(async () => {
  state.result = props.result
})
</script>

 <v-md-editor v-model="state.result" mode="preview"></v-md-editor>
```



### defineEmits

子组件向父组件事件传递。

#### 示例一

**子组件**

```js
<template>
  <div>
    我是子组件{{name}}
    <button @click="ziupdata">按钮</button>
  </div>
</template>

<script setup>
  import {defineEmits} from 'vue'

  //自定义函数，父组件可以触发
  const em=defineEmits(['updata'])
  const ziupdata=()=>{
    em("updata",'我是子组件的值')
  }

</script>
```

**父组件**

```js
<template>
  <div class="die">
    <h3>我是父组件</h3>
    <zi-hello @updata="updata"></zi-hello>
  </div>
</template>

<script setup>
  import ziHello from './ziHello'
  
  const updata = (data) => {
    console.log(data); //我是子组件的值
  }
</script>
```



#### 示例二

 子组件

```javascript
<template>
  <span>{{props.name}}</span>
  // 可省略【props.】
  <span>{{name}}</span>
  <button @click='changeName'>更名</button>
</template>

<script setup>
  // import { defineEmits, defineProps } from 'vue'
  // defineEmits和defineProps在<script setup>中自动可用，无需导入
  // 需在.eslintrc.js文件中【globals】下配置【defineEmits: true】、【defineProps: true】
	
  // 声明props
  const props = defineProps({
    name: {
      type: String,
      default: ''
    }
  }) 
  // 声明事件
  const emit = defineEmits(['updateName'])
  
  const changeName = () => {
    // 执行
    emit('updateName', 'Tom')
  }
</script>
```

 父组件

```javascript
<template>
  <child :name='state.name' @updateName='updateName'/>  
</template>

<script setup>
  import { reactive } from 'vue'
  // 引入子组件
  import child from './child.vue'

  const state = reactive({
    name: 'Jerry'
  })
  
  // 接收子组件触发的方法
  const updateName = (name) => {
    state.name = name
  }
</script>
```







### defineExpose

在标准组件写法里，子组件的数据都是默认隐式暴露给父组件的，但在 script-setup 模式下，所有数据只是默认 return 给 template 使用，不会暴露到组件外，所以父组件是无法直接通过挂载 ref 变量获取子组件的数据。

如果要调用子组件的数据，需要先在子组件显示的暴露出来，才能够正确的拿到，这个操作，就是由 defineExpose 来完成。

组件暴露出自己的属性，在父组件中可以拿到。示例:

**子组件**

```js
<template>
  <div>
    我是子组件
  </div>
</template>

<script setup>
  import {defineExpose,reactive,ref} from 'vue'
  let ziage=ref(18)
  let ziname=reactive({
    name:'赵小磊'
  })
  //暴露出去的变量
  defineExpose({
    ziage,
    ziname
  })
</script>
```

**父组件**

```js
<template>
  <div class="die">
    <h3 @click="isclick">我是父组件</h3>
    <zi-hello ref="zihello"></zi-hello>
  </div>
</template>

<script setup>
  import ziHello from './ziHello'
  import {ref} from 'vue'
  const zihello = ref()

  const isclick = () => {
    console.log('接收ref暴漏出来的值',zihello.value.ziage)
    console.log('接收reactive暴漏出来的值',zihello.value.ziname.name)
  }
</script>
```



## vite.config.ts

```ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'
import Components from 'unplugin-vue-components/vite'
import { AntDesignVueResolver } from 'unplugin-vue-components/resolvers'
import eslintPlugin from 'vite-plugin-eslint'
import { VitePWA } from 'vite-plugin-pwa'
import WindiCSS from 'vite-plugin-windicss'
import viteCompression from 'vite-plugin-compression'
import { injectHtml } from 'vite-plugin-html'
import AutoImport from 'unplugin-auto-import/vite'
import tsconfigPaths from 'vite-tsconfig-paths'
import styleImport, { AndDesignVueResolve } from 'vite-plugin-style-import'

export default defineConfig({
  plugins: [
    vue(),
    VitePWA(),
    tsconfigPaths(),
    injectHtml({
      injectData: {
        title: '少年的博客!'
      }
    }),
    AutoImport({
      imports: [
        'vue',
        'vue-router',
        '@vueuse/core',
        {
          axios: [
            ['default', 'axios'] // import { default as axios } from 'axios',
          ]
        }
      ],
      // 可以在这自定义自己的东西，比如接口api的引入，工具函数等等
      // see https://github.com/antfu/unplugin-auto-import/pull/23/
      resolvers: [
        /* ... */
      ]
    }),
    Components({
      dts: true, // ts支持
      dirs: ['src/components', 'src/views'], // 自定义路径按需导入
      resolvers: [AntDesignVueResolver()] // antd直接使用组件,无需在任何地方导入组件
    }),
    styleImport({
      resolves: [AndDesignVueResolve()]
    }),
    WindiCSS(),
    // gzip压缩 生产环境生成 .gz 文件
    viteCompression({
      verbose: true,
      disable: false,
      threshold: 10240,
      algorithm: 'gzip',
      ext: '.gz'
    }),
    eslintPlugin({
      cache: false // 关闭缓存
    })
  ],
  resolve: {
    extensions: ['.vue', '.mjs', '.js', '.ts', '.jsx', '.tsx', '.json', '.node', '.scss'],
    alias: {
      '@': resolve('./src'),
      '@vi': resolve('./src/views'),
      '@api': resolve('./src/api'),
      '@h': resolve('./src/hooks')
    }
  },
  base: '/', // 设置打包路径
  server: {
    port: 4001, // 设置服务启动端口号
    open: true, // 设置服务启动时是否自动打开浏览器
    cors: true // 允许跨域
  },
  css: {
    preprocessorOptions: {
      scss: {
        // 避免出现: build时的 @charset 必须在第一行的警告
        charset: true,
        additionalData: '@import "./src/design/methodCss.scss";'
      },
      less: {
        javascriptEnabled: true
      }
    }
  },
  build: {
    terserOptions: {
      // 打包后移除console和注释
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    // 拆分打包的配置方法
    assetsDir: 'static/img/',
    rollupOptions: {
      output: {
        chunkFileNames: 'static/js/[name]-[hash].js',
        entryFileNames: 'static/js/[name]-[hash].js',
        assetFileNames: 'static/[ext]/[name]-[hash].[ext]'
      }
    }
  }
})

```



## CSS变量注入

```js
<template>
  <span>Jerry</span>  
</template>

<script setup>
  import { reactive } from 'vue'

  const state = reactive({
    color: 'red'
  })
</script>
  
<style scoped>
  span {
    // 使用v-bind绑定state中的变量
    color: v-bind('state.color');
  }  
</style>
```



## 原型绑定与组件内使用

### main.js

```javascript
import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App)
// 获取原型
const prototype = app.config.globalProperties
// 绑定参数
prototype.name = 'Jerry'
```

### 组件内使用

```javascript
<script setup>
  import { getCurrentInstance } from 'vue'
  // 获取原型
  const { proxy } = getCurrentInstance()
  // 输出
  console.log(proxy.name)
</script>
```

## 对 await 的支持

不必再配合 async 就可以直接使用 await 了，这种情况下，组件的 setup 会自动变成 async setup 。

```javascript
<script setup>
  const post = await fetch('/api').then(() => {})
</script>
```

## 定义组件的name

用单独的`<script>`块来定义

```javascript
<script>
  export default {
    name: 'ComponentName',
  }
</script>
```



## 常用封装



### class 与 style 动态绑定

**对象写法**

```html
<template>
  <div :class="{ active: isActive }"></div>
  <div :style="{ fontSize: fontSize }">
</template>
<script>
export default {
  data() {
    return {
      isActive: true,
      fontSize: 30
    }
  }
}
</script>
```

**数组写法**

```html
<template>
  <div :class="[activeClass]"></div>
  <div :style="[styleFontSize]">
</template>
<script>
export default {
  data() {
    return {
      activeClass: 'active',
      styleFontSize: {
        fontSize: '12px'
      }
    }
  }
}
</script>
```



### 使用 v-if和v-else或者(v-show)

```js
<Com1 v-if="istrue" />
<Com2 v-else />
```



### is特性来进行动态组件的切换

```js
// 点击切换登录,注册,退出组件

   <template>
     <div>
        <a href="#" @click.prevent="comName = 'login'">登录</a>
        <a href="#" @click.prevent="comName = 'register'">注册</a>
        <a href="#" @click.prevent="comName = 'logOut'">退出</a>
        
        //  <component></component> 来展示对应名称的组件,相当于一个占位符
        //    :is 属性指定 组件名称

      <component :is="comName"></component>
      </div>
    </template>

```

### 清除缓存组件

```js
 // beforeRouteLeave()钩子
 
// 判断是否要到详情页

  beforeRouteLeave(to, from, next) {
      if (to.path === "/goods_detail") {
        from.meta.keepAlive = true;
      } else {
        from.meta.keepAlive = false;
      }
      next();
    }
```




### vue传值的编码和解码

```js
//编码
let paths = encodeURIComponent(path)
//解码
let paths = decodeURIComponent(path)
```



### 回到顶部-BackTop

```vue
 <div id="backtop">
   <p @click="backtop"></p>
 </div>
```

```js
  static BackTop() {
    // eslint-disable-next-line func-names
    const timer = setInterval(function () {
      const osTop = document.documentElement.scrollTop || document.body.scrollTop
      const isPeed = Math.floor(-osTop / 5)
      document.body.scrollTop = osTop + isPeed
      document.documentElement.scrollTop = document.body.scrollTop
      if (osTop === 0) {
        clearInterval(timer)
      }
    }, 30)
  }
```

### 日期格式化

```js
 /**
   * 日期格式化
   * @param time
   */
  static MomentTime(time: any) {
    moment(time).format('YYYY-MM-DD- H:mm:ss')
  }

  /**
   *  日期格式化
   * @param time
   */
  static async MomentTimeList(time: any) {
    await time.data.forEach((res: any) => {
      res.timeCreate = moment(res.timeCreate).format('YYYY-MM-DD- H:mm:ss')
      res.timeModified = moment(res.timeModified).format('YYYY-MM-DD- H:mm:ss')
    })
  }


```

### 产生随机数

```js
  /**
   * 随机数
   * @param minNum 最小值
   * @param maxNum 最大值
   * @param counts 循环次数
   * @returns
   */
  static Random(minNum: number, maxNum: number, counts: number) {
    let i = 0
    let count
    do {
      i += 1
      const res = `${Math.random() * (maxNum - minNum + 1) + minNum}`
      count = parseInt(res, 10)
    } while (i < counts)
    return count
  }
```



### 动态导入css样式

**dynamicScss.ts**

```ts
const SCSS: number = 1
async function toScss(nameCss: string) {
  switch (nameCss) {
    case 'sAbout':
      if (SCSS === 1) {
        import('../views/sAbout/index.scss')
      }
      break

    case 'index':
      if (SCSS === 1) {
        import('../views/sAbout/index.scss')
      }
      break
    default:
      /* code */
      break
  }
}
export default toScss
```

**vue组件导入**

```tsx
import { toScss } from "../../hooks/dynamicScss";
await toScss("sAbout");
```

###  vue 封装ts属性

 **data.ts**

```tsx
import { reactive } from "vue";
export interface BlogsList {
  dataResult: any, // 显示的数据
  page: number, //页码
  pagesize: number, //每页条数
  count: number, //总数
}

export const blogsList: BlogsList = reactive({
  dataResult: [],
  page: 1,
  pagesize: 10,
  count: 0,
})
```

 **vue**

```tsx
import { blogsList } from "../Blogs/components/data";
```

###  封装函数

 **index.ts**

```tsx
import { article } from '@/api/index';
import { blogsList } from "./components/data";
export class blogs {

  static async GetFySortTitle() {
    await article.GetFySortTitleAsync(blogsList.page, blogsList.pagesize).then((result: any) => {
      return blogsList.dataResult = result.data;
    });
  }
}
```

**index.vue**

```ts
import { blogs } from "./index";
await blogs.GetFySortTitle();
```

###  全局挂载

```tsx
//main
import axios from './api/axios'
const app = createApp(App);
// 全局ctx(this) 上挂载 $axios
app.config.globalProperties.$api = axios

//vue
const { proxy }: any = getCurrentInstance() //获取上下文实例，ctx=vue2的this
 proxy.$api
```

### 封装getCurrentInstance

```tsx
import { ComponentInternalInstance, getCurrentInstance } from 'vue'
export default function useCurrentInstance() {
  const { appContext } = getCurrentInstance() as ComponentInternalInstance
  const proxy = appContext.config.globalProperties
  return {
    proxy
  }
}
```

```tsx
  import useCurrentInstance from '@/utils/common/useCurrentInstance'
  const { proxy }: any = useCurrentInstance()
  console.log('%c [ proxy ]', 'font-size:13px; background:pink; color:#bf2c9f;', proxy)
```



### Vue3防抖节流

- 函数防抖（debounce）

就是指触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间。
简单的说，当一个动作连续触发，只执行最后一次。

- 函数节流（throttle）

  在一段时间内，函数最多可以触发一次执行,限制一个函数在一定时间内只能执行一次

#### 防抖节流封装

```tsx
/**
 * @description: 防抖 debounce
 * @param {any} fn
 * @param {number} delay
 * @return {*}
 */
function debounce(fn: any, delay: number) {
  let timer: any
  return function () {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn()
    }, delay)
  }
}

export {
  debounce
}
```

#### 使用

```tsx
import { debounce,throttle } from '@/utils/dethrottle'
   //防抖
    const num = ref(1)
    const add = debounce(() => {
      alert(num.value++)
    }, 1000)
    //节流
    const add = throttle(() => {
    console.log('节流')
    }, 5000)  
    const UpGive = throttle(() => {
    message.info('已点赞')
    state.article_String.give++
    article.UpdatePortionAsync(state.article_String, 'Give')
    }, 1000)
```

### 调试 template

场景:在Vue开发过程中, 经常会遇到template模板渲染时JavaScript变量出错的问题, 此时也许你会通过console.log来进行调试 这时可以在开发环境挂载一个 log 函数

```js
// main.js
app.config.globalProperties.$log = window.console.log

// 组件内部
<div>{{$log(info)}}</div>
```



### 本地图片动态加载

```js
\\ 封装一个引入图片方法
function getImageUrl(name) { 
return new URL(`../assets/blogPhotos/${name}.jpg`, import.meta.url).href;
}

\\ App.vue
<img :src="" alt="getImageUrl(name)" />
```

### svg-icon通用组件

- 为了更方便使用svg图标，封装一个svg-icon组件。用到的一个插件vite-plugin-svg-icons。
- 首先安装插件

```
yarn add vite-plugin-svg-icons -D 或者 npm i vite-plugin-svg-icons -D
```

- 配置vite.config.js

```js
import viteSvgIcons from 'vite-plugin-svg-icons';
import path from 'path'; // ts如果报错 npm i @types/node -D
export default () => {
  return {
    plugins: [
      viteSvgIcons({
        // 配置路劲在你的src里的svg存放文件
        iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')],
        symbolId: 'icon-[dir]-[name]',
      }),
    ],
  };
};
复制代码
```

- icon文件存放路径 /src/assets/icons

```js
# src/assets/icons 

icon1.svg 
icon2.svg 
icon3.svg
dir/icon1.svg
复制代码
```

- 定义svg-icon 组件

```js
<template>
  <svg :class="svgClass" aria-hidden="true">
    <use :xlink:href="iconName" :fill="color" />
  </svg>
</template>
<script lang="ts">
import { computed, defineComponent } from 'vue';
export default defineComponent({
  props: {
    iconClass: {
      type: String,
      required: true,
    },
    className: {
      type: String,
      default: '',
    },
    color: {
      type: String,
      default: '#889aa4',
    },
  },
  setup(props) {
    return {
      iconName: computed(() => `#icon-${props.iconClass}`),
      svgClass: computed(() => {
        if (props.className) {
          return `svg-icon ${props.className}`;
        }
        return 'svg-icon';
      }),
    };
  },
});
</script>
<style scope>
.svg-icon {
  width: 1em;
  height: 1em;
  fill: currentColor;
  vertical-align: middle;
}
</style>
复制代码
```

- 全局注册通用组件

```js
// main.ts
// svg-icons通用组件
import 'vite-plugin-svg-icons/register';
import svgIcon from './components/common/SvgIcon/index.vue';

app.component('svg-icon', svgIcon)
复制代码
```

- 组件的使用方法

```js
<div>
  <svg-icon icon-class="icon1" />
</div>
```




## Props

经常这样写 prop:

```tsx
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：

```tsx
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
```



# VueRouter



## Vue-Router 完整的导航解析流程

1. 导航被触发
2. 在失活的组件里调用  beforeRouteLeave 守卫
3. 调用全局 beforeEach 前置守卫
4. 重用的组件调用 beforeRouteUpdate 守卫（2.2+）
5. 路由配置调用 beforeEnter
6. 解析异步路由组件
7. 在被激活的组件里调用 beforeRouteEnter 守卫
8. 调用全局的 beforeResolve 守卫（2.5+）
9. 导航被确认
10. 调用全局的 afterEach
11. 触发 DOM 更新
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入



### 路由useRoute和useRouter

```javascript
<script setup>
  import { useRoute, useRouter } from 'vue-router'
	
  // 必须先声明调用
  const route = useRoute()
  const router = useRouter()
	
  // 路由信息
  console.log(route.query)

  // 路由跳转
  router.push('/newPage')
</script>
```

### 路由导航守卫

```javascript
<script setup>
  import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'
	
  // 添加一个导航守卫，在当前组件将要离开时触发。
  onBeforeRouteLeave((to, from, next) => {
    next()
  })

  // 添加一个导航守卫，在当前组件更新时触发。
  // 在当前路由改变，但是该组件被复用时调用。
  onBeforeRouteUpdate((to, from, next) => {
    next()
  })
</script>
```



## Vue-Router 有哪几种导航守卫

### 全局前置守卫

在路由跳转前触发，可在执行 next 方法前做一些身份登录验证的逻辑。

```js
const router = new VueRouter({})

router.beforeEach((to, from, next) => {
  ...
  // 必须执行 next 方法来触发路由跳转 
  next() 
})
复制代码
```

### 全局解析守卫

与 beforeEach 类似，也是路由跳转前触发，区别是还需在`所有组件内守卫和异步路由组件被解析之后`，也就是在组件内 beforeRouteEnter 之后被调用。

```js
const router = new VueRouter({})

router.beforeResolve((to, from, next) => {
  ...
  // 必须执行 next 方法来触发路由跳转 
  next() 
})
复制代码
```

### 全局后置钩子

和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身。

```js
router.afterEach((to, from) => {
  // ...
})
复制代码
```

1. 路由独享守卫

可在路由配置上直接定义 beforeEnter

```js
const router = new VueRouter({
  routes: [
    {
      path: '/home',
      component: Home,
      beforeEnter: (to, from, next) => {
      
      }
    }
  ]
})
复制代码
```

### 组件内的守卫

组件内可直接定义如下路由导航守卫

```js
const Foo = {
  template: `...`,
  beforeRouteEnter(to, from, next) {
    // 不能获取组件实例 this
    // 当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate(to, from, next) {
    // 当前路由改变，但是组件被复用时调用
    // 可访问实例 this
  },
  beforeRouteLeave(to, from, next) {
    // 导航离开组件时被调用
  }
}
```





## router封装

index.js

```js
import {
  createRouter,
  createWebHistory,
  createWebHashHistory
} from 'vue-router'
import BlogHome from '@/components/home/Home.vue'

const routes = [{
  path: '/',
  //重定向，当前路径'/'没有对应的组件，需要重定向到其他路由页面
  redirect: '/BlogHome',
  name: 'Home',
  component: BlogHome,
},
{
  path: '/BlogHome',
  name: 'BlogHome',
  component: () => import('@/components/home/Home.vue'),
  meta: {
    keepAlive: false
  },
},

{
  path: '/Admin-index',
  name: 'Admin-index',
  component: () => import('@/views/admin/index/index.vue'),
  children: [   // 添加子路由
    {
      path: 'ArticleTable',
      name: 'ArticleTable',
      component: () => import('@/views/admin/article/ArticleTable.vue'),
    },
    {
      path: 'Logins',
      name: 'Logins',
      component: () => import('@/views/admin/login/Login.vue')
    },
  ]
},
]
//createWebHashHistory createWebHistory
const router = createRouter({
  history: createWebHistory(), //HTML5模式
  routes,
})
export default router
```



##  路由跳转

### 导入使用

```tsx
 import {useRoute,useRouter} from 'vue-router'
   const route = useRoute()  // 参数的获取  this.$route
   const router= useRouter() // 方法使用  this.$router
           router.push({
              path: num,
              query: {
                t: +new Date()
              }
            })
```

### 无参跳转

```js
// 字符串
router.push('home')
// 对象
router.push({ path: 'home' })
```

### 带参数跳转

```js
this.$router.push({ path: '/Index-text', query: { id: cid } })
 await router.push({
          path: "/IndexText",
          query: {
            id: id,
          },
        });
```

###  路由调用

示例1

```js
data () {
    return {
      id: this.$route.query.id,
    }
url: '/api/Contents/AsyGetTestID?id=' + this.id
```

示例2

```tsx
import { useRoute } from 'vue-router'
 const route = useRoute()
 const state = reactive({
      id: route.query.id,
 })
```



###  点击刷新当前路由

```js
   this.$router.push({
     path: "./SnNavigation",
     query: {
       t: +new Date() //保证每次点击路由的query项都是不一样的，确保会重新刷新view
      }
    })
```

### 跳转新窗口

```ts
       const { href } = await router.resolve({
          path: "/IndexText",
          query: { id: id }
        });
        window.open(href, '_blank');
```

###  replace

 跟 `router.push` 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。（下面会具体说明）

| 声明式                            | 编程式                |
| :-------------------------------- | :-------------------- |
| `<router-link :to="..." replace>` | `router.replace(...)` |

### router.go(n)

这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。

```tsx
// 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)
// 后退一步记录，等同于 history.back()
router.go(-1)
// 前进 3 步记录
router.go(3)
// 如果 history 记录不够用，那就默默地失败呗
router.go(-100)
router.go(100)
```

### 比较说明

1.this.$router.push()：

   跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面。

2.this.$router.replace()

   同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。

3.this.$router.go(n)

   相对于当前页面向前或向后跳转多少个页面,类似 `window.history.go(n)`。n可为正数可为负数。正数返回上一个页面



## 路由嵌套

实现嵌套路由有两个要点：

- 在组件内部使用<router-view>标签
- `VueRouter 的参数中使用 `children 配置

### 父路由 index

引入子路由

```vue
<div>
<a-menu-item key="1" @click="Routers('/Admin-index/ArticleTable')">文章列表</a-menu-item>
<a-menu-item key="2" @click="Routers('/Admin-index/Logins')">option2</a-menu-item>
<router-view></router-view>
</div>
```

### 路由配置

```tsx
{
  path: '/Admin-index',
  name: 'Admin-index',
  component: () => import('@/views/admin/index/index.vue'),
  children: [   // 添加子路由
    {
      path: 'ArticleTable',
      name: 'ArticleTable',
      component: () => import('@/views/admin/article/ArticleTable.vue'),
    },
    {
      path: 'Logins',
      name: 'Logins',
      component: () => import('@/views/admin/login/Login.vue')
    },
  ]
},
```



## Vue-Router 配置 404 页面

\* 代表通配符，若放在任意路由前，会被先匹配，导致跳转到 404 页面，所以需将如下配置置于最后。

```js
{
  path: '*',
  name: '404'
  component: () => import('./404.vue')  
}
```







# 状态管理

##  Pinia 

Pinia 是一个用于 Vue 的状态管理库，类似 Vuex, 是 Vue 的另一种状态管理方案

### 安装 Pinia

```
# 使用 npm
npm install pinia@next
# 使用 yarn
yarn add pinia@next
```

### 创建一个 pinia（根存储）

main.ts

```
import { createPinia } from 'pinia';
const pinia = createPinia()
app.use(pinia)
```

### Store

Store 是一个保存状态和业务逻辑的实体，可以自由读取和写入，并通过导入后在 setup 中使用
 创建一个 store

```javascript
// pinia.ts
import { defineStore } from "pinia";

// defineStore 调用后返回一个函数，调用该函数获得 Store 实体
export const useStore = defineStore({
  // id: 必须的，在所有 Store 中唯一
  id: "myGlobalState",
  // state: 返回对象的函数
  state: ()=> ({
    count: 1
  }),
});
```

### 使用 Store

```js
<script lang="ts" setup>
import { useAppStore } from '@/store/pinia'
const store = useAppStore()
console.log('%c [ store ]-12', 'font-size:13px; background:pink; color:#bf2c9f;', store.count)
</script>
```

### Getters

Pinia 中的 Getters 直接在 Store 上读取，形似 Store.xx，就和一般的属性读取一样

### Getter基本使用

> Getter 第一个参数是 state，是当前的状态，也可以使用 this.xx 获取状态
>  Getter 中也可以访问其他的 Getter， 或者是其他的 Store

```javascript
// 修改 store.js
import { defineStore } from "pinia";
import { otherState } from "@/store/otherState.js";

export const useStore = defineStore({
  id: "myGlobalState",
  state: ()=> ({
    count: 2
  }),
  getters: {
    // 一个基本的 Getter： 计算 count 的平方
    // 使用参数
    countPow2(state) {
      return state.count ** 2;
    },

    // 获取其它 Getter， 直接通过 this
    countPow2Getter() {
      return this.countPow2;
    }

    // 使用其它 Store
    otherStoreCount(state) {
      // 这里是其他的 Store，调用获取 Store，就和在 setup 中一样
      const otherStore = useOtherStore();
      return otherStore.count;
    },
  }
});

// otherState.js
import { defineStore } from "pinia";
export const useStore = defineStore({
  id: "otherState",
  state: ()=> ({
    count: 5
  }),
});

```

### actions

Pinia 没有 Mutations，统一在 actions 中操作 state，通过this.xx 访问相应状态
 虽然可以直接操作 Store，但还是推荐在 actions 中操作，保证状态不被意外改变
 action 和普通的函数一样
 action 同样可以像 Getter 一样访问其他的 Store，同上方式使用其它 Store，这里不在赘述,详细请移步 [官方文档 Actions](https://link.juejin.cn?target=https%3A%2F%2Fpinia.esm.dev%2Fcore-concepts%2Factions.html)

### action 基本使用

```javascript
// store.js
export const useStore({
  state: ()=> ({
    count: 2,
    // ...
  })
  // ...
  actinos: {
    countPlusOne() {
      this.count++;
    },
    countPlus(num) {
      this.count += num;
    }
  }
})
```

 Pinia 可以自由扩展 [官方文档 Plugins](https://link.juejin.cn?target=https%3A%2F%2Fpinia.esm.dev%2Fcore-concepts%2Fplugins.html)








# Axios



## 基本封装实例

建network 文件夹 下新建 request.js

```js
 import axios from 'axios'
 export function request(config) {
   // 1创建axios实例
   const intstance = axios.create({
     baseURL: 'https://localhost:44398/',
     timeout: 5000
     // contentType: 'application/json;charset=UTF-8',
     // dataType: 'json'
   })
   // 1.axios拦截器
   intstance.interceptors.request.use(config => {
     return config
   }, er => {
   })

   // 1.axios响应拦截拦截
   intstance.interceptors.response.use(res => {
     return res
   }, er => {
   })
   return intstance(config)
 }
 export default request
```

### 调用

在vue的页面导入

```js
import Headers from './Headers'
```

```js
methods: {
    AsyGetTest () {
      request({
        url: '/api/Contents/AsyGetTest'
      }).then(res => {
        // 只获取0到4之间的数据
        this.newinfo = res.data.slice(0, 4);
        console.log(this.newinfo)
      }).catch((e) => {
        console.log('获取数据失败');
      });
    }
  }
```

展示接口内容

```js
v-for="info in newinfo" :key="info.cid"
{{ info.title }}
```

## vue3封装实例

### axios.ts

```tsx
import axios from 'axios'
import qs from 'qs'
import { message } from 'ant-design-vue'
import { reactive } from 'vue'
import store from '@/store/index'
import router from '@/router/index'
import { resData } from '@/components/aspin/data'
import { storage } from '../storage/storage'
import { removePending, addPending } from './pending'

const obj: any = reactive({
  urls: import.meta.env.VITE_API_DOMAIN
})
// 全局配置
axios.defaults.withCredentials = false
axios.defaults.headers.post['Content-Type'] = 'application/json;charset=UTF-8'
// 允许跨域
axios.defaults.headers.post['Access-Control-Allow-Origin-Type'] = '*'

function myAxios(axiosConfig: any, customOptions: any) {
  const service = axios.create({
    baseURL: obj.urls, // 设置统一的请求前缀
    timeout: 10000 // 设置统一的超时时长
  })

  // 是否开启取消重复请求
  const qiXiao = {
    qiXiao_cancel: false, // 是否开启取消重复请求, 默认为 false
    ...customOptions
  }
  // 请求拦截器
  service.interceptors.request.use(
    function request(req: any) {
      removePending(req) // 在请求开始前，对之前的请求做检查取消操作
      if (qiXiao.qiXiao_cancel) {
        addPending(req) // 将当前请求添加到 pending 中
      }
      if (req.method === 'post' || req.method === 'put' || req.method === 'delete') {
        // 序列化
        req.data = qs.parse(req.data)
      }
      // 若是有做鉴权token , 就给头部带上token
      if (storage.get('token')) {
        req.headers.Authorization = storage.get('token') as string
      }
      return req
    },
    (error) => {
      message.error(error.data.error.message)
      return Promise.reject(error.data.error.message)
    }
  )
  // 响应拦截器
  service.interceptors.response.use(
    function response(res) {
      resData.show = true
      removePending(res) // 在请求结束后，移除本次请求
      if (res.status === 200 || res.status === 204) {
        setTimeout(() => {
          resData.show = false
        }, 1000)

        return Promise.resolve(res)
      }
      return Promise.reject(res)
    },
    (error: any) => {
      console.log('%c [ error ]', 'font-size:13px; background:pink; color:#bf2c9f;', error)

      if (error.response.status) {
        switch (error.response.status) {
          case 400:
            message.error(`发出的请求有错误，服务器没有进行新建或修改数据的操作==>${error.response.status}`)
            break
          case 401: // 重定向
            message.error(`token:登录失效==>${error.response.status}:${'token'}`)
            storage.remove('token')
            router.replace({
              path: '/Login'
            })
            break

          case 403:
            message.error(`用户得到授权，但是访问是被禁止的==>${error.response.status}`)
            break
          case 404:
            message.error(`网络请求不存在==>${error.response.status}`)
            break
          case 406:
            message.error(`请求的格式不可得==>${error.response.status}`)
            break
          case 410:
            message.error(`请求的资源被永久删除，且不会再得到的==>${error.response.status}`)
            break
          case 422:
            message.error(`当创建一个对象时，发生一个验证错误==>${error.response.status}`)
            break
          case 500:
            message.error(`服务器发生错误，请检查服务器==>${error.response.status}`)
            break
          case 502:
            message.error(`网关错误==>${error.response.status}`)
            break
          case 503:
            message.error(`服务不可用，服务器暂时过载或维护==>${error.response.status}`)
            break
          case 504:
            message.error(`网关超时==>${error.response.status}`)
            break
          default:
            message.error(`其他错误错误==>${error.response.status}`)
        }
        return Promise.reject(error.response)
      }
      store.commit('changeNetwork', false)

      return true
    }
  )
  return service(axiosConfig)
}
export default myAxios
```

### 重复请求

pending.ts

```js
import axios from 'axios'

// 声明一个 Map 用于存储每个请求的标识 和 取消函数
const pending = new Map()
/**
 * 添加请求
 * @param {Object} res
 */
export const addPending = (res: any) => {
  const url = [res.method, res.url, JSON.stringify(res.params), JSON.stringify(res.data)].join('&')
  res.cancelToken =
    res.cancelToken ||
    new axios.CancelToken((cancel) => {
      if (!pending.has(url)) {
        // 如果 pending 中不存在当前请求，则添加进去
        pending.set(url, cancel)
        console.log('[ 添加请求 ]=>', url)
      }
    })
}
/**
 * 移除请求
 * @param {Object} config
 */
export const removePending = (config: any) => {
  const url = [config.method, config.url, JSON.stringify(config.params), JSON.stringify(config.data)].join('&')
  if (pending.has(url)) {
    // 如果在 pending 中存在当前请求标识，需要取消当前请求，并且移除
    const cancel = pending.get(url)
    cancel(url)
    pending.delete(url)
    console.log('[ 移除请求 ]=>', url)
  }
}
/**
 * 清空 pending 中的请求（在路由跳转时调用）
 */
export const clearPending = () => {
  for (const [url, cancel] of pending) {
    cancel(url)
    console.log('[ 清空请求 ]=>', url)
  }
  pending.clear()
}
```



###  接口调用

```tsx
import request from '@/utils/http/axios'
import { IntArticle } from '@/api/data/interData'
import { tool } from '@/utils/common/tool'

class article {
  /**
   * @description: 查询总数
   * @param {number} identity 所有:0 || 分类:1 || 标签:2
   * @param {string} type
   * @param {boolean} cache
   */
  static GetCountAsync(identity: number, type: string, cache: boolean) {
    return request(
      {
        url: `/api/SnArticle/GetCountAsync?identity=${identity}&type=${type}&cache=${cache}`,
        method: 'get'
      },
      {
        qiXiao_cancel: false
      }
    )
  }

  /**
   * @description: 更新
   * @param {any} resultData
   * @param {string} type
   */
  static async UpdatePortionAsync(resultData: any, type: string): Promise<any> {
    return request(
      {
        // 更新
        url: `/api/SnArticle/UpdatePortionAsync?type=${type}`,
        method: 'put',
        data: resultData
      },
      {
        qiXiao_cancel: false
      }
    )
  }

  /**
   * @description: 新增数据
   * @param {any} resultData
   */
  static async AddAsync(resultData: IntArticle) {
    return request(
      {
        url: '/api/SnArticle/AddAsync',
        method: 'post',
        data: resultData
      },
      {
        qiXiao_cancel: false
      }
    )
  }
  /**
   * @description: 更新数据
   * @param {IntArticle} resultData
   */
  static async UpdateAsync(resultData: IntArticle) {
    return request(
      {
        url: '/api/SnArticle/UpdateAsync',
        method: 'put',
        data: resultData
      },
      {
        qiXiao_cancel: false
      }
    )
  }

  /**
   * @description: 删除
   * @param {number} id
   * @return {*}
   */
  static async DeleteAsync(id: number) {
    return request(
      {
        url: `/api/SnArticle/DeleteAsync?id=${id}`,
        method: 'delete'
      },
      {
        qiXiao_cancel: false
      }
    )
  }
}
export { article }
```

###  并发请求

并发

处理并发请求的助手函数

 axios.all(iterable)

 axios.spread(callback)

```js
//示例:
import { article } from '@/api/index';
import { blogsList } from "./components/data";
import axios from '@/utils/http/axios'
class methods {
  static async GetFySortTitle() {
    await article.GetFySortTitleAsync(blogsList.page, blogsList.pagesize, true).then((res: any) => {
      blogsList.dataResult = res.data;
    });
  }
  static async ConutSort() {
    await article.ConutSort(7).then((result: any) => {
      blogsList.count = result.data;
    });
  }
}
async function QueryAll() {
  // axios.all([await methods.ConutSort(), await methods.GetFySortTitle()]).then(axios.spread((Fy, co: any) => {
  //   blogsList.count = co.data;
  //   blogsList.dataResult = Fy.data;
  // }))
  axios.all([await methods.ConutSort(), await methods.GetFySortTitle()])
}

export {
  methods,
  QueryAll
}
```

## 异常问题解决

### AXIOS String contains non ISO-8859-1 code point.

 **原因**

在头信息中存在中文，需要对其进行编码。

**解决方法**

使用encodeURIComponent()对中文信息进行编码即可。

```js
if (storage.get(store.state.Roles)) {
      req.headers.Authorization = encodeURIComponent(storage.get(store.state.Roles)) as string
    }
```

### 请求超时

我们更改node服务延时响应来制造超时效果

```
// app.js
app.get('/api/list', (req, res) => {
  setTimeout(() => {
    res.end();
  },  150000)
});
```







# Vue 插件



## 样式normalize

```
npm install --save normalize.css
import 'normalize.css/normalize.css'
```



### highlight

```js
npm i highlight.js
```

```js
import 'highlight.js/styles/googlecode.css'
import hljs from 'highlight.js' //导入代码高亮文件
```



## Icon

首先下载好的iconfont.js放到assets/icon 引入css 文件，在同级目录下创建一个icon.css文件

```css
.icon {
    width: 1em;
    height: 1em;
    vertical-align: -0.15em;
    fill: currentColor;
    overflow: hidden;
}
main.js导入
import './assets/icon/fonts/iconfont.js'
import './assets/icon/icon.css'
引用
 <svg class="icon" aria-hidden="true">
   <use xlink:href="#icon-bingqilinqiu"></use>
 </svg>
```



## vue-aplayeryer

### 安装使用

```css
yarn add @moefe/vue-aplayer
```

```vue
<aplayer :audio="audio" :lrcType="3" fixed />
```

### main.js

```js
import APlayer from '@moefe/vue-aplayer';
Vue.use(APlayer, {
  defaultCover: 'https://github.com/u3u.png',
  productionTip: true,
});
```

### js

```js
  export default {
        name: "Vueaplayer",
        components: {
        },
        data() {
            return {
                audio: [{
                    name: '东西（Cover：林俊呈）',
                    artist: '纳豆',
                    url: 'http://localhost:8081/mp3/0003.mp3',
                    cover: 'https://p1.music.126.net/5zs7IvmLv7KahY3BFzUmrg==/109951163635241613.jpg?param=300y300', // prettier-ignore
                    lrc: 'https://cdn.moefe.org/music/lrc/thing.lrc',
                },
                    {
                        name: "0001",
                        artist: "0001",
                        url: 'http://localhost:8081/mp3/0001.mp3',
                        cover: "",
                        lrc: "[00:00.00]lrc here\n[00:01.00]aplayer"
                    }
                ]
            }
        },        
    }
```



## [v-md-editor](https://ckang1229.gitee.io/vue-markdown-editor/zh/)



### 安装支持 vue3 的版本

```bash
# 使用 npm
npm i @kangc/v-md-editor@next -S

# 使用 yarn
yarn add @kangc/v-md-editor@next
```

### 在 vue3 中注册

```tsx
// v-md
import VueMarkdownEditor from '@kangc/v-md-editor';
import '@kangc/v-md-editor/lib/style/base-editor.css';
// vuepress github 主题
// import vuepressTheme from '@kangc/v-md-editor/lib/theme/vuepress.js';
// import '@kangc/v-md-editor/lib/theme/style/vuepress.css';
import githubTheme from '@kangc/v-md-editor/lib/theme/github.js';
import '@kangc/v-md-editor/lib/theme/style/github.css';

// import Prism from 'prismjs';
import hljs from 'highlight.js';

VueMarkdownEditor.use(githubTheme, {
  // Prism,
  Hljs: hljs,
  // extend(md) {
  //   // md为 markdown-it 实例，可以在此处进行修改配置,并使用 plugin 进行语法扩展
  //   // md.set(option).use(plugin);
  // },
});
//  end v-md
```

### 使用

```vue
      <v-md-editor
        v-model="state.blog"
        left-toolbar=""
        right-toolbar="toc"
        :include-level="[2, 3]"
        mode="preview"
      />
```

### 渲染html文本

```tsx
// main.js
import VMdPreviewHtml from '@kangc/v-md-editor/lib/preview-html';
import '@kangc/v-md-editor/lib/style/preview-html.css';

// 引入使用主题的样式
import '@kangc/v-md-editor/lib/theme/style/vuepress';

Vue.use(VMdPreviewHtml);


<template>
  <!-- preview-class 为主题的样式类名，例如vuepress就是vuepress-markdown-body -->
  <v-md-preview-html :html="html" preview-class="vuepress-markdown-body"></v-md-preview-html>
</template>

<script>
export default {
  data() {
    return {
      html: '<div data-v-md-line="1"><h1 align="center">Markdown Editor built on Vue</h1>',
    };
  },
};
</script>
```

### 渲染 markdown

```tsx
// main.js
import VMdPreview from '@kangc/v-md-editor/lib/preview';
import '@kangc/v-md-editor/lib/style/preview.css';
// 引入你所使用的主题 此处以 github 主题为例
import githubTheme from '@kangc/v-md-editor/lib/theme/github';
import '@kangc/v-md-editor/lib/theme/style/github.css';

// highlightjs
import hljs from 'highlight.js';

VMdPreview.use(githubTheme, {
  Hljs: hljs,
});
Vue.use(VMdPreview);
```

vue

```vue
<template>
  <v-md-preview :text="markdown"></v-md-preview>
</template>

<script>
export default {
  data() {
    return {
      markdown: '### 标题',
    };
  },
};
</script>
```

# Vite

## 插件

### vite-plugin-restart

通过监听文件修改，自动重启 vite 服务。

Install

```bash
npm i vite-plugin-restart -D 
yarn add vite-plugin-restart -D
```

Add it to `vite.config.js`

```js
// vite.config.js
import ViteRestart from 'vite-plugin-restart'

export default {
  plugins: [
    ViteRestart({
      restart: [
        'my.config.[jt]s',
      ]
    })
  ],
};
```

### vite-plugin-tips

*// 服务器状态提示*

 Install

```
$ npm install vite-plugin-tips -D
```

 configuration

```
import { viteTips } from 'vite-plugin-tips'

export default {
  plugins: [
    viteTips()
  ]
}
```

 Options

```
interface Options {
  // Whether to enable relevant tips. Default is enabled.
  connect?: boolean
  update?: boolean
  disconnect?: boolean
}
```

### vite-plugin-eslint



vite的eslint插件,可是一个常见的插件,让你的项目可以方便的得到eslint支持,完成eslint配置后,可以快速的将其集成进vite之中,便于在代码不符合eslint规范的第一时间看到提示.

 Install

```bash
npm install vite-plugin-eslint --save-dev
# or
yarn add vite-plugin-eslint --dev
```

 Usage

```js
import { defineConfig } from 'vite';
import eslintPlugin from 'vite-plugin-eslint';

export default defineConfig({
  plugins: [eslintPlugin({
      cache: false // 关闭缓存
  })],
});
```



### vite-plugin-pwa



`vite`的`pwa`支持插件,快速让你的项目开启`pwa`功能.

 Installation

Add `vite-plugin-pwa` dependency to your project as a `dev dependency`:

With **YARN**:

```
yarn add vite-plugin-pwa -D
```

With **NPM**:

```
npm i vite-plugin-pwa -D
```

With **PNPM**:

```
pnpm i vite-plugin-pwa -D
```

 Setup

Edit your `vite.config.ts` file to add `Vite Plugin PWA`:

```js
import { VitePWA } from 'vite-plugin-pwa'
export const defineConfig({
  plugins: [
    VitePWA({})
  ]    
})
```



###  vite-plugin-checker

这是基于上面的vite-plugineslint修改的一个插件,特点是支持异步检测可以加速项目的启动速度,不过缺点也是如果有错误或者警告不会提前停止项目编译.

Install plugin.

```
yarn add vite-plugin-checker -D
```

Add it to Vite config file.

```js
// vite.config.js
import checker from 'vite-plugin-checker'

export default {
  plugins: [checker({
      typescript: true,
      eslint: {
        files: ['./src'],
        extensions: ['.ts']
      }
    }),], // e.g. use TypeScript check
}
```



### vite-plugin-compression

使用 `vite-plugin-compression` 可以 `gzip` 或 `brotli` 的方式来压缩资源，这一步需要服务器端的配合，`vite` 只能帮你打包出 `.gz` 文件。此插件使用简单，你甚至无需配置参数，引入即可。

```bash
# 安装
yarn add --dev vite-plugin-compression
复制代码
```

plugins 中添加：

```js
import viteCompression from 'vite-plugin-compression'

// gzip压缩 生产环境生成 .gz 文件
viteCompression({
      verbose: true,
      disable: false,
      threshold: 10240,
      algorithm: 'gzip',
      ext: '.gz',
    }),
```

### vite-plugin-html

动态HTML内容的插件

```bash
npm install vite-plugin-html -D
```

配置：

```ts
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { injectHtml } from 'vite-plugin-html'

export default defineConfig({
  plugins: [
    vue(),
    injectHtml({
      injectData: {
        title: '用户管理系统'
      }
    })
  ],
})
```

具体使用，动态变量语法简单了许久：

```html
// index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%= title %></title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

### unplugin-auto-import

自动导入vue3的hooks，借助[unplugin-auto-import/vite](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantfu%2Funplugin-auto-import)这个插件

**支持`vue`, `vue-router`, `vue-i18n`, `@vueuse/head`, `@vueuse/core`等自动引入**

为 Vite、Webpack 和 Rollup 按需自动导入 API。

```
npm i -D unplugin-auto-import
```

```js
// vite.config.ts
import AutoImport from 'unplugin-auto-import/vite'

export default defineConfig({
  plugins: [
       AutoImport({
      include: [
        /\.[tj]sx?$/, // .ts, .tsx, .js, .jsx
        /\.vue$/,
        /\.vue\?vue/, // .vue
        /\.md$/ // .md
      ],
      // global imports to register
      imports: [
        // presets
        'vue',
        'vue-router',
        // custom
        {
          axios: [
            // default imports
            ['default', 'axios'] // import { default as axios } from 'axios',
          ]
        }
      ],
      // custom resolvers
      // 可以在这自定义自己的东西，比如接口api的引入，工具函数等等
      // see https://github.com/antfu/unplugin-auto-import/pull/23/
      resolvers: [
        /* ... */
      ]
    }),
  ],
})
```

解决**使用unplugin-auto-import/vite** 报错

*/ .eslintrc.js*

```js
 globals: {
    onMounted: true
  }
```

或

```
npm install vue-global-api -D
```



```js
// .eslintrc.js
module.exports = {
  extends: [
    'vue-global-api'
  ]
};
```

它还为细粒度控制提供了相同的集合和单个 API 选项。

```js
// .eslintrc.js
module.exports = {
  extends: [
    // collections
    'vue-global-api/reactivity',
    'vue-global-api/lifecycle',
    'vue-global-api/component',
    // single apis
    'vue-global-api/ref',
    'vue-global-api/toRef',
  ]
};
```




### vite-tsconfig-paths

用 vite 构建 ts 项目时，如果使用了 [typescript 路径映射](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping)的功能，就需要进行特殊处理，否则会出现模块无法解析（找不到）的错误

```
npm i vite-tsconfig-paths
```

```js
import { defineConfig } from 'vite'
import tsconfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  plugins: [tsconfigPaths()],
})
```

### vite-plugin-style

当你使用unplugin-vue-components来引入ui库的时候

message, notification 等引入样式不生效 安装vite-plugin-style-import即可

该插件可按需导入组件库样式

 为什么只按需引入样式

由于 `vite` 本身已按需导入了组件库，因此仅样式不是按需导入的，因此只需按需导入样式即可。-import

安装 (yarn or npm)

```
yarn add vite-plugin-style-import -D
```

or

```
npm i vite-plugin-style-import -D
```

```js
// vite.config.js
import { defineConfig } from 'vite'
import styleImport, {
  AndDesignVueResolve,
  VantResolve,
  ElementPlusResolve,
  NutuiResolve,
  AntdResolve
} from 'vite-plugin-style-import'

export default defineConfig({
  plugins: [
    styleImport({
      resolves: [ //要导入的库列表 (由插件内置)
        AndDesignVueResolve(),
        VantResolve(),
        ElementPlusResolve(),
        NutuiResolve(),
        AntdResolve()
      ],
      // 自定义规则 要导入的库列表
      libs: [
        {
          libraryName: 'ant-design-vue',
          esModule: true,
          resolveStyle: (name) => {
            return `ant-design-vue/es/${name}/style/index`
          }
        }
      ]
    })
  ],
  // 引用使用less的库要配置一下
  css: {
    preprocessorOptions: {
      less: {
        javascriptEnabled: true
      }
    }
  }
})

```

### vite-plugin-qrcode

在服务器启动时显示二维码。

安装

```
npm install --save-dev vite-plugin-qrcode
```

 用法

```
// vite.config.js 
import  {  qrcode  }  from  'vite-plugin-qrcode' ; 

export  default  defineConfig ( { 
	plugins : [ 
		qrcode ( )  // 仅适用于开发模式
	] 
} ) ;
```

### rollup-plugin-visualizer

可视化并分析您的 Rollup 包，以查看哪些模块占用了空间。



### PostCSS

vite自动对 `*.vue` 文件和导入的`.css` 文件应用PostCSS配置，我们只需要安装必要的插件和添加 `postcss.config.js` 文件即可。

```js
module.exports = {
  plugins: [
    require('autoprefixer'),
  ]
}

npm i postcss autoprefixer@8.1.4
```




## 打包上线

### 打包移除console和注释

```js
 build: {
    terserOptions: {
      // 打包后移除console和注释
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  }
```



### 拆分打包的配置方法

```js
    assetsDir: 'static/img/',
    rollupOptions: {
      output: {
        chunkFileNames: 'static/js/[name]-[hash].js',
        entryFileNames: 'static/js/[name]-[hash].js',
        assetFileNames: 'static/[ext]/[name]-[hash].[ext]'
      }
    }
```

### 打包速度的问题

vite在打包中会计算包的大小，但是只是计算不做处理，会长打包时间，所以可以在build中再添加一个配置项关闭打包计算。

```js
brotliSize: false
```

## 配置服务器代理

```js
export default {
  proxy: {
    '/api': {
      target: 'http://jsonplaceholder.typicode.com',
      changeOrigin: true,
      rewrite: path => path.replace(/^\/api/, '')
    }
  }
}
```

## 环境变量 package.json

```
"dev": "cross-env NODE_ENV=development vite"
```



### 模式和环境变量

使用模式做多环境配置，`vite serve`时模式默认是`development`，`vite build`时是`production`。

创建配置文件`.env.development`

```
VITE_TOKEN=this is token
```

代码中读取

```
import.meta.env.VITE_TOKEN
```



## 错误解决方案

### `Expected a JavaScript module script but the server responded with a MIME type of "text/html"`

##### 解决方案:

上述问题的原因在于：项目build后没有找到正确的静态资源路径，解决如下

```
// vite.config.js目录下，修改内容如下：
export default viteConfig = {
    base: '/'
}
```

### How to solve ESLint's "prefer default export" error when exporting a variable?

```
export default { noFutureDate }
```



# SCSS



## 封装调用

```js
 //vue
<style lang="scss" >
  @import "./scss/indexTitle.scss";
</style>

 //indexTitle.scss
@import "../../assets/sass/com";
@import "../../assets/sass/uitl";
.IndexTitle {
  @include initialize($w, null, $Text_height, null, $ml, null, null);
}
```



## Scss语法

### 变量

变量用来存储需要在CSS中复用的信息，如颜色和字体,通过$符号去声明一个变量。

```scss
$yanse: rgb(223, 148, 148);
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 `!global` 声明：

```scss
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```



### 插值`#{}`

通过 `#{}` 插值语句可以在选择器或属性名中使用变量：

```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```

编译为

```css
p.foo {
  border-color: blue; }
```

### 嵌套

```css
.container{
  .left-area{
    ...
  }
}
```

### 父选择器(&)

`&` 在 scss中表示自身的意思。

```css
.container{
  &.right-area{
   background-color : #0000
 }
}
```

###  Mixin(混合)

用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。

```css
@mixin 名字（参数1，参数2，...）
{
........样式.......
}

div{
    @include 名字;  
}
```

### 继承

继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码

```scss
// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。
%message-common {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

.message {
  @extend %message-common;
}

.success {
  @extend %message-common;
  border-color: green;
}

```

### 函数

Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用：

```scss
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}
#sidebar { width: grid-width(5); }
```

编译为

```css
#sidebar {
  width: 240px; }
```

与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 `@return` 输出结果。

自定义的函数也可以使用关键词参数，上面的例子还可以这样写：

```scss
#sidebar { width: grid-width($n: 5); }
```

建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。

### for循环



```css
结束值不执行：
@for 变量 from 开始值 through 结束值 {
     ......
}
结束值也执行：
@for 变量 from 开始值 to 结束值 {
     ......
}
复制代码
```

例子：

```css
@for $i from 1 to 3 {
    .div#{$i}{
       height: $i*20px;
    }
}
```

### while循环

```css
$gao: 1;
@while $gao<4 {
    .div#{$gao}{
        height: $gao*10px;
    }
   $gao : $gao+1;
}
```



## 常用

### 居中

使用 Flexbox 实现子元素的居中效果，只需三行代码：

```scss
@mixin center-children {
    display: flex;
    justify-content: center;
    align-items: center;
}
```

由于 Flexbox 还是比较新的属性，那么添加上相关的浏览器前缀的话，会让它拥有更广泛的兼容性。

```scss
.parent {
    @include center-children;
}
```







# Eslint

###  .eslintignore

```bash
# eslint 忽略检查 (根据项目需要自行添加)
node_modules
dist
```



## 允许使用自增('++')自减('--')符号

个人觉得自增自减还是挺好用的，看网上很多建议是可以写成 `number.value += 1` 这样子的形式

解决：

```js
// .eslintrc.js
module.exports = {
  ...
  rules: {
    // 允许使用自增自减符号
    'no-plusplus': [
      'off',
      {
        allowForLoopAfterthoughts: true
      }
    ]
  }
}
```

## 去掉alert()的warn提示

有时候为了方便想直接用系统的提示框，这也被提示黄线了。

解决：

```js
// .eslintrc.js
module.exports = {
  ...
  rules: {
    // 去调用使用alert/confirm/prompt的warn
    'no-alert': 0 
  }
}
```



### 允许对函数参数再赋值



大致问题就是 `eslint` 默认不允许对函数参数再进行赋值操作，要不就会报红提示。

```js
// .eslintrc.js
module.exports = {
  ...
  rules: {
    // 允许修改函数的入参
    'no-param-reassign': [
      'error',
      {
        props: true,
        ignorePropertyModificationsFor: [
          'config',
        ]
      }
    ],
  }
}

```

## v-model directives require no argument

```
"vue/no-v-model-argument": "off",
```



# uni App



## 下拉刷新

### pages.json开启刷新

enablePullDownRefresh

```js
    "pages": [{
        "path": "pages/index/index",
        "style": {
            "navigationBarTitleText": "首页",
			"enablePullDownRefresh":true
        }
    }],
```

### 使用下拉刷新

```js
//下拉刷新
		onPullDownRefresh() {
			setTimeout(()=>{
					// 刷新关闭
				uni.stopPullDownRefresh()
				alert("刷新成功")
			},2000)
```



### 页面触底事件

```js
	// 页面触底事件
		onReachBottom() {
			setTimeout(()=>{
				alert("刷新成功")
			},2000)
		},
```



## 请求封装

### 创建一个http.js

```js
const baseUrl = 'http://11111/';
const httpRequest = (opts, data) => {
	let httpDefaultOpts = {
		url: baseUrl + opts.url,
		data: data,
		method: opts.method,
		header: opts.method == 'get' ? {
			'X-Requested-With': 'XMLHttpRequest',
			"Accept": "application/json",
			"Content-Type": "application/json; charset=UTF-8"
		} : {
			'X-Requested-With': 'XMLHttpRequest',
			'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
		},
		dataType: 'json',
	}
	let promise = new Promise(function(resolve, reject) {
		uni.request(httpDefaultOpts).then(
			(res) => {
				resolve(res[1])
			}
		).catch(
			(response) => {
				reject(response)
			}
		)
	})
	return promise
};
//带Token请求
const httpTokenRequest = (opts, data) => {
	let token = "";
	uni.getStorage({
		key: 'token',
		success: function(ress) {
			token = ress.data
		}
	});
	//此token是登录成功后后台返回保存在storage中的
	let httpDefaultOpts = {
		url: baseUrl + opts.url,
		data: data,
		method: opts.method,
		header: opts.method == 'get' ? {
			'Token': token,
			'X-Requested-With': 'XMLHttpRequest',
			"Accept": "application/json",
			"Content-Type": "application/json; charset=UTF-8"
		} : {
			'Token': token,
			'X-Requested-With': 'XMLHttpRequest',
			'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
		},
		dataType: 'json',
	}
	let promise = new Promise(function(resolve, reject) {
		uni.request(httpDefaultOpts).then(
			(res) => {
				resolve(res[1])
			}
		).catch(
			(response) => {
				reject(response)
			}
		)
	})
	return promise
};

export default {
	baseUrl,
	httpRequest,
	httpTokenRequest
}

```

### 将http.js引入

​	

```js
import http from '@/commons/http.js';
```

```js
let opts = {
					url: 'api/SnArticle/GetTest',
					method: 'get'
				};
				let param = {
					deviceId: this.deviceCode,
					deviceName: this.deviceName
				};
				http.httpTokenRequest(opts, param).then(res => {
					
					this.newinfo= res.data;
         // console.log(newinfo);
				}, error => {
					console.log(error);
				})
```







# c#应用



## C# 编码规范

####  **模块头部注释规范**

以一个物理文件为单元的都需要有模块头部注释规范，例如：C#中的.cs文件

用于每个模块开头的说明，主要包括：（**粗体字**为必需部分，其余为可选部分）

1. **文件名称**(File Name)： 此文件的名称
2. **功能描述**(Description)：  此模块的功能描述与大概流程说明
3. **数据表**(Tables)：       所用到的数据表，视图，存储过程的说明，如关系比较复杂，则应说明哪些是可擦写的，哪些表为只读的。
4. **作者**(Author)：
5. **日期**(Create Date)：
6. 参考文档(Reference)(可选)：     该档所对应的分析文档，设计文檔。
7. 引用(Using) (可选)﹕      开发的系统中引用其它系统的Dll、对象时，要列出其对应的出处，是否与系统有关﹙不清楚的可以不写﹚，以方便制作安装档。
8. **修改记录**(Revision History)：若档案的所有者改变，则需要有修改人员的名字、修改日期及修改理由。
9. **分割符：***************************** (前后都要)

#### 方法注释规范

具体应用当中，类、接口、属性、方法必须有<Summary>节，另外方法如果有参数及返回值，则必须有<Param>及<Returns>节。示例如下：

```xml
　　　　/// <summary>
　　　　/// …
　　　　/// </summary>
　　　　/// <param name=””></param>
　　　　/// <returns></returns>
```

#### 命名的基本约定

下表描述了不同类型标识符的大小写规则：

| **标识符** | **大小写** | **示例**                                 |
| ---------- | ---------- | ---------------------------------------- |
| 命名空间   | Pascal     | namespace Com.Techstar.ProductionCenter  |
| 类型       | Pascal     | public class DevsList                    |
| 接口       | Pascal     | public interface ITableModel             |
| 方法       | Pascal     | public void UpdateData()                 |
| 属性       | Pascal     | Public int Length{…}                     |
| 事件       | Pascal     | public event EventHandler Changed;       |
| 私有字段   | Camel      | private string fieldName;                |
| 非私有字段 | Pascal     | public string FieldName；                |
| 枚举值     | Pascal     | FileMode{Append}                         |
| 参数       | Camel      | public void UpdateData(string fieldName) |
| 局部变量   | Camel      | string fieldName;                        |

#### 命名规范

- Pascal法：首字母大写，连接词的首字母也都大写
  →GetInfo
- Camel：第一个单词的首字母小写
  →getInfo
- MENTIONS:

1. 成员变量最好加一个“_”
2. 接口的名称前加前缀“*I*”



#### 代码编写规则

- 尽量使用接口
- 局部变量尽量在最接近的地方使用
- 不要使用goto系列语句（除非是在跳出深层循环时）
- 构建和构建一个长的字符串时，一定要使用**StringBuilder**类型
- switch语句要有**default**来处理意外情况



### 语法糖

####  集合类的声明

之前我们声明一个List并给list赋初始值，必须得这么写：

```c#
List<string> list = new List<string>();
list.Add("a一");
list.Add("b二");
```

现在不需要了，直接写就可以了

```c#
List<string> list = new List<string> {
            "def","OK"
};
```

#### **集合类各个项的操作**

我们为了逐个处理集合中的项，需要这么写：

```c#
foreach (string item in list)
{
Console.WriteLine(item);
}
```

现在不需要了，这样就可以了

```c#
list.ForEach(a => Console.WriteLine(a));
```

#### **using == try finally**

为了在使用完毕时释放资源，我们经常要用using，using实质上就是try fiannaly的一个语法糖而已。例如

```c#
StreamWriter sw = null;
try
{
    sw = new StreamWriter("d:\abc.txt");
    sw.WriteLine("test");
}
finally {
    if(sw!= null) sw.Dispose();
}
```

简化为：

```c#
using (var sw = new StreamWriter("d:\abc.txt")) {
    sw.WriteLine("test");
}
```

#### **问号的演变**

表示左边的变量如果为null则值为右边的变量，否则就是左边的变量值

```c#
string a = null;
var b = a??””;
```

#### **类型实例化的语法糖**

```c#
public class Abc
{
    public int ID { get; set; }
    public string Name { get; set; }
    public string Url { get; set; }
}

public static void Main(string[] args) {
        var abc = new Abc{
            ID=1,
            Name="yukaizhao",
            Url="http://yukaizhao.cnblogs.com/"
        };
    }
```

#### 匿名类

匿名类在linq to sql或者entity framework中返回查询数据时很好用。

```c#
var a = new {
    ID = 1,
    Name=”yukaizhao”,
    BlogUrl=”http://www.cnblogs.com/yukaizhao/”
};
```

#### **NULL条件运算符**

```c#
使用代码
Customer customer = new Customer();
string name = customer?.Name;
编译代码
Customer customer = new Customer();
if (customer != null)
{
    string name = customer.Name;
}
和??组合起来使用
if (customer?.Face()??false)
还可以两个一起组合来使用
int? contactNameLen = contact?.Name?.Length; 
```

这个语法糖的目的是在对象使用前检查是否为null。如果对象为空，则赋值给变量为空值，所以例子中需要一个可以为空的int类型、即int?。如果对象不为空，则调用对象的成员取值，并赋值给变量。

#### **字符串格式化**

String.Format有些不方便的地方是：必须输入String.Format，使用{0}占位符、必须顺序来格式化、这点容易出错。

```c#
    var contactInfo = string.Format("Id:{0} Name:{1} EmailAddr:{2} PhoneNum:{3}", 
    contact.Id, contact.Name, contact.EmailAddress, contact.PhoneNum);
    
    新的语法
    var contactInfo2 = $"Id:{contact.Id} Name:{contact.Name} EmailAddr:
    {contact.EmailAddress} PhoneNum:{contact.PhoneNum}";
        
    新格式化方式还支持任何表达式的直接赋值：
    var contactInfo = $"Id:{contact.Id} Name:{(contact.Name.Length == 0 ? "Frank" : 
    contact.Name)} EmailAddr:{contact.EmailAddress} PhoneNum:{contact.PhoneNum}";
    
```



## efcore



### 连接Mysql DBFirst模式

一：**创建EF的类库，同时将此项目设置为启动项(为Scaffold-DbContext -tables指令使用)，同时安装2个包**  

​      ①Microsoft.EntityFrameworkCore.Tools

​      ②Pomelo.EntityFrameworkCore.MySql (这个是第三方的ef mysql 中间件)

 **Scaffold-DBcontext命令**

```c#
Scaffold-DbContext "server=localhost;userid=root;pwd=woshishui;port=3306;database=snblog;sslmode=none;" Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Force
```

​     server：数据库地址，User Id：账号，Password：登录密码

​      如果是针对单表的更新,加一个-Tables 后面是要更新的表名

```c#
Scaffold-DbContext "server=localhost;userid=root;pwd=woshishui;port=3306;database=snblog;sslmode=none;" Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Tables "sn_interface" -Force
```

 执行完成之后会生成指定的是Model ，注意：表必须有主键，才会生成，如果没有主机会报 Unable to generate entity type for table “xxxx” 警告，当然实体也不会生成

**Scaffold-DbContext命令参数说明:**

-OutputDir (-o) ：实体文件所存放的文件目录

-ContextDir ： DbContext文件存放的目录

-Context ： DbContext文件名

-Schemas ： 需要生成实体数据的数据表所在的模式

-Tables(-t) ： 需要生成实体数据的数据表的集合

-Force (-f)强制执行，重写已经存在的实体文件



### 查询数据

**IQueryable**

就是C#中Linq To SQL语句的返回类型，简单来说IQueryable就是可以叠加处理SQL语句，最后统一访问数据库，这个处理过程就叫`延迟执行`，这一步只是生成了SQL语句，并没有真正执行数据库查询

执行数据库查询

```c#
` ToList()`、`First()`、`FirstOrDefault()`
`Single()`、`SingleOrDefault()`、`Last()`、`LastOrDefault()`//Single只能是一个数据
`Count()`、`LongCount()`、`Min()`、`Max()`、`Average()`、`Sum()`
`Find()`、 `foreach()
```

First返回符合添加的第一条数据；First与FirstOrDefault的区别，First必须有数据，否则会报错，FirstOrDefault可有可无

First()与FirstOrDefault()可以在方法参数里直接写Where查询条件

```C#
_dbContext.Leagues.FirstOrDefault(w => w.Country == "中国");
```





#### **无用追踪**

- 无须追踪的数据没有加AsNoTracking

#### 跟踪与非跟踪查询

跟踪行为决定了 Entity Framework Core 是否将有关实体实例的信息保留在其更改跟踪器中。 如果已跟踪某个实体，则该实体中检测到的任何更改都会在 SaveChanges() 期间永久保存到数据库。 EF Core 还将修复跟踪查询结果中的实体与更改跟踪器中的实体之间的导航属性。

从不跟踪无键实体类型。 无论在何处提到实体类型，它都是指定义了键的实体类型。

#### 跟踪查询

返回实体类型的查询是默认会被跟踪的。 这表示可以更改这些实体实例，然后通过 SaveChanges() 持久化这些更改。 在以下示例中，将检测到对博客评分所做的更改，并在 SaveChanges() 期间将这些更改持久化到数据库中。

```c#
var blog = context.Blogs.SingleOrDefault(b => b.BlogId == 1);
blog.Rating = 5;
context.SaveChanges();
```



#### 非跟踪查询

AsNoTracking 称之为获取不带变动跟踪的实体查询

在一些情况下，我们只需要查询返回一个只读的数据记录，而不会对数据记录进行任何的修改。

在只读方案中使用结果时，非跟踪查询十分有用。 可以更快速地执行非跟踪查询，因为无需设置更改跟踪信息。 如果不需要更新从数据库中检索到的实体，则应使用非跟踪查询。 可以将单个查询替换为非跟踪查询。

AsNoTracking方法查询返回无变动跟踪的DbSet，由于是无变动跟踪，所以对返回的实体集中数据的任何修改，在SaveChanges()时，都不会提交到数据库中。

```c#
var blogs = context.Blogs
   .AsNoTracking()
   .ToList();
```

还可以在上下文实例级别更改默认跟踪行为：

```c#
context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
var blogs = context.Blogs.ToList();
```





#### 查询单个数据

```c#
//第一种
result = await _service.SnArticle.FindAsync(id);
//第一种
var leagues = _service.SnArticle.SingleOrDefault(l => l.Id == _id);
```

ling

```js
//获取全部数据
var blogs = context.Blogs.ToList();

//获取单个实体
var blog = context.Blogs.Single(b => b.BlogId == 1);

//筛选
var blogs = context.Blogs
    .Where(b => b.Url.Contains("dotnet"))
    .ToList();
```



#### 模糊查询

```c#
 s => s.XianWID.StartsWith(str)
 匹配以str开头的
 s => s.XianWID.EndsWith(str)
 匹配以str结尾的
 s => s.XianWID.Contains(str)
 匹配包含str的
            //第一种
           result_List = await _service.SnArticle
           .Where(l => l.Title.Contains(name))//查询条件
           .ToListAsync();

           //第二种
           var league_ef = _dbContext.Leagues
            .Where(l => EF.Functions.Like(l.Country, "中%"))
            .ToList();
```

#### 预加载（Eager Loading）

```c#
[HttpGet("Eager")]
public IActionResult GetEager()
{
    var clubs = _dbContext.Clubs
        .Where(c => c.Name.Contains("足球队"))//过滤条件
        .Include(c => c.League)//关联数据
        .ToList();
    return Ok(clubs);
}
```



### 添加数据

```c#
        public async Task<bool> AddAsync(SnArticle entity)
        {
            _logger.LogInformation("添加数据_SnArticle" + entity);
            await _service.SnArticle.AddAsync(entity);
            return await _service.SaveChangesAsync() > 0;
        }
```



### 更新数据

更新指定列

1.第一种方式

```c#
  public async Task<bool> UpdatePortionAsync(SnArticle snArticle, string type)
        {
            _logger.LogInformation("更新部分参数");
            var date = _service.SnArticle.Update(snArticle);
            //默认不更新
            date.Property("UserId").IsModified = false;
            date.Property("Title").IsModified = false;
            date.Property("TitleText").IsModified = false;
            date.Property("Text").IsModified = false;
            date.Property("Time").IsModified = false;
            date.Property("LabelId").IsModified = false;
            date.Property("Read").IsModified = false;
            date.Property("Give").IsModified = false;
            date.Property("Comment").IsModified = false;
            date.Property("SortId").IsModified = false;
            date.Property("TypeTitle").IsModified = false;
            date.Property("UrlImg").IsModified = false;
            switch (type)
            {    //指定字段进行更新操作
                case "Read":
                    date.Property(type).IsModified = true;
                    break;
                case "Give":
                     date.Property(type).IsModified = true;
                    break;
                case "Comment":
                     date.Property(type).IsModified = true;
                    break;
            }
            return await _service.SaveChangesAsync() > 0;
        }
```

2.第二种方式

```c#
        public async Task<bool> UpdatePortionAsync(SnArticle snArticle, string type)
        {
            _logger.LogInformation("更新部分参数");
            var resulet = await _service.SnArticle.FindAsync(snArticle.ArticleId);
            if (resulet == null) return false;
            switch (type)
            {    //指定字段进行更新操作
                case "Read":
                    //修改属性，被追踪的Read状态属性就会变为Modify
                    resulet.Read = snArticle.Read;
                    break;
                case "Give":
                    resulet.Give = snArticle.Give;
                    break;
                case "Comment":
                    resulet.Comment = snArticle.Comment;
                    break;
            }
            //执行数据库操作
            return await _service.SaveChangesAsync() > 0;
        }
```

### 删除数据

第一种

```c#
        public async Task<bool> DeleteAsync(int id)
        {
            _logger.LogInformation("删除数据_SnArticle" + id);
            var todoItem = await _service.SnArticle.FindAsync(id);
            if (todoItem == null) return false;
            _service.SnArticle.Remove(todoItem);
            return await _service.SaveChangesAsync() > 0;
        }
```

第二种

```c#
        public async Task<bool> DeleteAsync(int id)
        {
            _logger.LogInformation("删除数据_SnArticle" + id);
            //先查询出来，因为只能删除被追踪的数据
            var todoItem = await  _service.SnArticle.FindAsync(id);
            if (todoItem == null) return false;
            //1、单独删除方法
            _service.SnArticle.Remove(todoItem);//删除单个todoItem
            _service.Remove(todoItem);//直接在context上Remove()方法传入model，它会判断类型
            return await _service.SaveChangesAsync() > 0;
        }

-----------------------------------------------------------------------------------------
    //批量删除方法
    var league2 = _dbContext.Leagues.SingleOrDefault(l => l.Country == "中国");
    _dbContext.Leagues.RemoveRange(league, league2);
    _dbContext.RemoveRange(league, league2);
```



##  netCoreApi

### api函数命名

```c#
        /// 查询总数 
        [HttpGet("GetCountAsync")]
        public async Task<IActionResult> GetCountAsync(bool cache)
            
        /// 条件查询总数
        [HttpGet("GetTypeCountAsync")]
        public IActionResult GetTypeCountAsync(int type, bool cache)
            
        
```



### 常用的 HTTP 状态码

| HTTP 状态码 | 涵义                  | 解释说明                                                     |
| ----------- | --------------------- | ------------------------------------------------------------ |
| 200         | OK                    | 用于一般性的成功返回，不可用于请求错误返回                   |
| 201         | Created               | 资源被创建                                                   |
| 202         | Accepted              | 用于资源异步处理的返回，仅表示请求已经收到。对于耗时比较久的处理，一般用异步处理来完成 |
| 204         | No Content            | 此状态可能会出现在 PUT、POST、DELETE 的请求中，一般表示资源存在，但消息体中不会返回任何资源相关的状态或信息 |
| 400         | Bad Request           | 用于客户端一般性错误信息返回, 在其它 4xx 错误以外的错误，也可以使用，错误信息一般置于 body 中 |
| 401         | Unauthorized          | 接口需要授权访问，为通过授权验证                             |
| 403         | Forbidden             | 当前的资源被禁止访问                                         |
| 404         | Not Found             | 找不到对应的信息                                             |
| 500         | Internal Server Error | 服务器内部错误                                               |

### ObjectResult 的方法来表明接口返回的状态码

web API会用到的状态码：

**200级别，表示成功：**

- **200 - OK**
- **201 - Created，表示资源创建成功了**
- **204 - No content，成功执行，但是不应该返回任何东西**

**400级别，表示客户端引起的错误：**

- **400 - Bad request，表示API的消费者发送到服务器的请求是错误的**
- **401 - Unauthorized，表示没有权限**
- **403 - Forbidden，表示用户验证成功，但是该用户仍然无法访问该资源**
- **404 - Not found，表示请求的资源不存在**
- **405 - Method not allowed，这就是当我们尝试发送请求给某个资源时，使用的HTTP方法却是不允许的，例如使用POST api/countries, 而该资源只实现了 GET，所以POST不被允许**
- **406 - Not acceptable，这里涉及到了media type，例如API消费者请求的是application/xml格式的media type，而API只支持application/json**
- **409 - Conflict，表示该请求无法完成，因为请求与当前资源的状态有冲突，例如你编辑某个资源数据以后，该资源又被其它人更新了，这时你再PUT你的数据就会出现409错误；有时也用在尝试创建资源时该资源已存在的情况。**
- **415 - Unsupported media type，这个和406正好返回来，比如说我向服务器提交数据的media type是xml的，而服务器只支持json，那么就会返回415**
- **422 - Unprocessable entity，表示请求的格式没问题，但是语义有错误，例如实体验证错误。**

**500级别，服务器错误：**

- **500 - Internal server error，这表示是服务器发生了错误**

### 接口命名规范

和 C# 命名规范一样，好的、统一的接口命名规范，不仅可以增强其可读性，而且还会减少很多不必要的口头/书面上的解释。可使用"驼峰命名法"按照实现接口的**业务类型、业务场景**等命名



#### 常见命名方式

- `接口名称动词前/后缀化`： 接口名称以接口数据操作的动词为前/后缀，常见动词有：`Add、Delete、Update、Query、Get、Send、Save、Detail、List`等，如：新建用户 `AddUser`、查询订单详情 `QueryOrderDetail`。

- 接口名称动词 + 请求方式

  接口路径中包含具体接口名称的名词，接口数据操作动作以 HTTP 请求方式来区分。常用的 HTTP 请求方式有：

  - `GET`：从服务器取出资源（一项或多项）
  - `POST`：在服务器新建一个资源
  - `PUT`：在服务器更新资源（客户端提供改变后的完整资源）
  - `PATCH`：在服务器更新资源（客户端提供改变的属性）
  - `DELETE`：从服务器删除资源

### 请求参数规范

- 请求方式

  ```
  GET、POST、PUT
  ```

  等含义定义，避免出现不一致现象，对人造成误解、歧义

  - `请求头`：请求头根据项目需求添加配置参数。如：请求数据格式，`accept=application/json` 等。如有需要，请求头可根据项目需求要求传入用户 token、唯一验签码等加密数据
  - `请求参数/请求体`： 请求参数字段，尽可能与数据库表字段、对象属性名等保持一致，因为保持一致是最省事，最舒服的一件事

###  返回数据规范

此处以 json 格式为例。返回数据应包含：**返回状态码、返回状态信息、具体数据**。**返回数据中的状态码、状态信息，常指具体的业务状态，不建议和 HTTP 状态码混在一起**。HTTP 状态，是用来体现 HTTP 链路状态情况，如：404-Not Found。HTTP 状态码和 json 结果中的状态码，并存尚可，用于体现不同维度的状态。

## 常用



### C# 泛型声明

 示例

```c#
//泛型类 
public class GenericClass<T> where T : ISports
{
}
//泛型接口
public interface GenericInterface<S>
{
}
//泛型委托
public delegate void Do<T>() where T : ISports;
//泛型方法
public void test<T>(T param)
{
}
```

#### 封装泛型类



定义一个泛型类就是指的是，定义一个类，这个类中某些字段的类型是不确定的，这些类型可以在类构造的时候确定下来,举例:

```c#
using System.Collections.Generic;

namespace Snblog.Util.components
{
    public class Tool<T>
    {
        public T result = default;
        private List<T> resultList = default;
        public T resultDto = default;
        private List<T> resultListDto = default;
        private int resulInt;
     
    }
}

```

#### 使用

```c#
        Tool<SnArticle> data = new Tool<SnArticle>();
        Tool<SnArticleDto> datas = new Tool<SnArticleDto>();

       public async Task<SnArticleDto> GetByIdAsync(int id, bool cache)
        {
            _logger.LogInformation(message: $"SnArticleDto主键查询 id:{id} 缓存:{cache}");
            datas.resultDto = _cacheutil.CacheString("SnArticleDto_GetByIdAsync=>" + id + cache, datas.resultDto, cache);
            if (datas.resultDto == null)
            {
                data.result = await _service.SnArticles.FindAsync(id);
                //result = await _service.SnArticles.FindAsync(id);
                datas.resultDto = _mapper.Map<SnArticleDto>(data.result);
                _cacheutil.CacheString("SnArticleDto_GetByIdAsync=>" + id + cache, datas.resultDto, cache);
            }
            return datas.resultDto;
        }
```

### C#转义

```c#
        /// <summary>
        /// Url转码
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        public static string UrlEncode(string url)
        {
            return HttpUtility.UrlEncode(url);
        }
        /// <summary>
        /// Url解码
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        public static string UrlDecode(string url)
        {
            return HttpUtility.UrlDecode(url);
        }
```



### Datetime 使用

```c#
        DateTime dt = DateTime.Now; 当前系统时间：
Environment.TickCount可以得到“系统启动到现在”的毫秒

DateTime now = DateTime.Now;
now.ToString("yyyy-MM-dd");  //按yyyy-MM-dd格式输出s
dt.ToString();    //  26/11/2009 AM 11:21:30
dt.ToFileTime().ToString();   //   129036792908014024
        dt.ToFileTimeUtc().ToString();  //     129036792908014024
        dt.ToLocalTime().ToString();   //       26/11/2009 AM 11:21:30
        dt.ToLongDateString().ToString();   //      2009年11月26日
        dt.ToLongTimeString().ToString();  //      AM 11:21:30
        dt.ToOADate().ToString();   //      40143.4732731597
        dt.ToShortDateString().ToString();   //     26/11/2009
        dt.ToShortTimeString().ToString();   //     AM 11:21
        dt.ToUniversalTime().ToString();   //       26/11/2009 AM 3:21:30
        dt.Year.ToString();   //        2009
        dt.Date.ToString();   //        26/11/2009 AM 12:00:00
        dt.DayOfWeek.ToString();  //       Thursday
        dt.DayOfYear.ToString();   //       330
        dt.Hour.ToString();       //        11
        dt.Millisecond.ToString();   //     801        （毫秒）
        dt.Minute.ToString();   //      21
        dt.Month.ToString();   //       11
        dt.Second.ToString();   //      30
        dt.Ticks.ToString();   //       633948312908014024

dt.TimeOfDay.ToString();   //       12:29:51.5181524
// Gets the time of day for this instance.
// 返回 A System.TimeSpan that represents the fraction of the day that has elapsed since midnight.
         dt.ToString();     //     26/11/2009 PM 12:29:51
         dt.AddYears(1).ToString();    //         26/11/2010 PM 12:29:51
         dt.AddDays(1.1).ToString();    //        27/11/2009 PM 2:53:51
         dt.AddHours(1.1).ToString();    //       26/11/2009 PM 1:35:51
         dt.AddMilliseconds(1.1).ToString();    //26/11/2009 PM 12:29:51
         dt.AddMonths(1).ToString();    //        26/12/2009 PM 12:29:51
         dt.AddSeconds(1.1).ToString();    //     26/11/2009 PM 12:29:52
         dt.AddMinutes(1.1).ToString();    //     26/11/2009 PM 12:30:57
         dt.AddTicks(1000).ToString();    //      26/11/2009 PM 12:29:51
         dt.CompareTo(dt).ToString();    //       0
         dt.Add(new TimeSpan(1,0,0,0)).ToString();    // 加上一个时间段
（注：
System.TimeSpan为一个时间段，构造函数如下
public TimeSpan(long ticks); // ticks: A time period expressed in 100-nanosecond units.
                             //nanosecond：十亿分之一秒   new TimeSpan(10,000,000)        为一秒
        public TimeSpan(int hours, int minutes, int seconds);
        public TimeSpan(int days, int hours, int minutes, int seconds);
        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
）
         dt.Equals("2005-11-6 16:11:04").ToString();     //        False
         dt.Equals(dt).ToString();    //      True
         dt.GetHashCode().ToString();    //       1103291775
         dt.GetType().ToString();    //       System.DateTime
         dt.GetTypeCode().ToString();    //       DateTime
  
long Start = Environment.TickCount;   //单位是毫秒
        long End = Environment.TickCount;
        Console.WriteLine("Start is : "+Start);
Console.WriteLine("End is : "+End);
Console.WriteLine("The Time is {0}",End-Start);
Console.WriteLine(dt.GetDateTimeFormats('s')[0].ToString());    //2009-11-26T13:29:06
Console.WriteLine(dt.GetDateTimeFormats('t')[0].ToString());    //PM 1:29
Console.WriteLine(dt.GetDateTimeFormats('y')[0].ToString());    //2009年11月
Console.WriteLine(dt.GetDateTimeFormats('D')[0].ToString());    //2009年11月26日
Console.WriteLine(dt.GetDateTimeFormats('D')[1].ToString());    //星期四, 26 十一月, 2009
Console.WriteLine(dt.GetDateTimeFormats('D')[2].ToString());    //26 十一月, 2009
Console.WriteLine(dt.GetDateTimeFormats('D')[3].ToString());    //星期四 2009 11 26
Console.WriteLine(dt.GetDateTimeFormats('M')[0].ToString());    //26 十一月
Console.WriteLine(dt.GetDateTimeFormats('f')[0].ToString());    //2009年11月26日 PM 1:29
Console.WriteLine(dt.GetDateTimeFormats('g')[0].ToString());    //26/11/2009 PM 1:29
Console.WriteLine(dt.GetDateTimeFormats('r')[0].ToString());    //Thu, 26 Nov 2009 13:29:06 GMT
(注：
常用的日期时间格式：
格式 说明      输出格式
d 精简日期格式 MM/dd/yyyy
D 详细日期格式 dddd, MMMM dd, yyyy
f  完整格式(long date + short time) dddd, MMMM dd, yyyy HH:mm
F 完整日期时间格式(long date + long time) dddd, MMMM dd, yyyy HH:mm:ss
g 一般格式(short date + short time) MM/dd/yyyy HH:mm
G 一般格式(short date + long time) MM/dd/yyyy HH:mm:ss
m, M 月日格式 MMMM dd
s 适中日期时间格式 yyyy-MM-dd HH:mm:ss
t 精简时间格式 HH:mm
T 详细时间格式 HH:mm:ss
)

        string.Format("{0:d}", dt);    //28/12/2009
        string.Format("{0:D}", dt);    //2009年12月28日
        string.Format("{0:f}", dt);    //2009年12月28日 AM 10:29
        string.Format("{0:F}", dt);    //2009年12月28日 AM 10:29:18
        string.Format("{0:g}", dt);    //28/12/2009 AM 10:29
        string.Format("{0:G}", dt);    //28/12/2009 AM 10:29:18
        string.Format("{0:M}", dt);    //28 十二月
        string.Format("{0:R}", dt);    //Mon, 28 Dec 2009 10:29:18 GMT
        string.Format("{0:s}", dt);    //2009-12-28T10:29:18
        string.Format("{0:t}", dt));    //AM 10:29
        string.Format("{0:T}", dt);    //AM 10:29:18
        string.Format("{0:u}", dt);    //2009-12-28 10:29:18Z
        string.Format("{0:U}", dt);    //2009年12月28日 AM 2:29:18
        string.Format("{0:Y}", dt);    //2009年12月
        string.Format("{0}", dt);    //28/12/2009 AM 10:29:18
        string.Format("{0:yyyyMMddHHmmssffff}", dt);    //200912281029182047

计算2个日期之间的天数差
DateTime dt1 = Convert.ToDateTime("2007-8-1");    
DateTime dt2 = Convert.ToDateTime("2007-8-15");
        TimeSpan span = dt2.Subtract(dt1);
        int dayDiff = span.Days;

        计算某年某月的天数
int days = DateTime.DaysInMonth(2009, 8);
        days = 31;                                      

给日期增加一天、减少一天
DateTime dt =DateTime.Now;
dt.AddDays(1); //增加一天 dt本身并不改变
dt.AddDays(-1);//减少一天 dt本身并不改变


参数format格式详细用法：

格式字符关联属性/说明
dShortDatePattern
DLongDatePattern
f完整日期和时间（长日期和短时间）
FFullDateTimePattern（长日期和长时间）
g常规（短日期和短时间）
G常规（短日期和长时间）
m、MMonthDayPattern
r、RRFC1123Pattern
s使用当地时间的SortableDateTimePattern（基于ISO8601）
tShortTimePattern
TLongTimePattern
uUniversalSortableDateTimePattern用于显示通用时间的格式
U使用通用时间的完整日期和时间（长日期和长时间）
y、YYearMonthPattern

下面列出可被合并以构造自定义模式的模式：

d月中的某一天。一位数的日期没有前导零。
dd月中的某一天。一位数的日期有一个前导零。
ddd周中某天的缩写名称，在AbbreviatedDayNames中定义。
dddd周中某天的完整名称，在DayNames中定义。
M月份数字。一位数的月份没有前导零。
MM月份数字。一位数的月份有一个前导零。
MMM月份的缩写名称，在AbbreviatedMonthNames中定义。
MMMM月份的完整名称，在MonthNames中定义。
y不包含纪元的年份。如果不包含纪元的年份小于10，则显示不具有前导零的年份。
yy不包含纪元的年份。如果不包含纪元的年份小于10，则显示具有前导零的年份。
yyyy包括纪元的四位数的年份。
gg时期或纪元。如果要设置格式的日期不具有关联的时期或纪元字符串，则忽略该模式。
h12小时制的小时。一位数的小时数没有前导零。
hh12小时制的小时。一位数的小时数有前导零。
H24小时制的小时。一位数的小时数没有前导零。
HH24小时制的小时。一位数的小时数有前导零。
m分钟。一位数的分钟数没有前导零。
mm分钟。一位数的分钟数有一个前导零。
s秒。一位数的秒数没有前导零。
ss秒。一位数的秒数有一个前导零。
f秒的小数精度为一位。其余数字被截断。
ff秒的小数精度为两位。其余数字被截断。
fff秒的小数精度为三位。其余数字被截断。
ffff秒的小数精度为四位。其余数字被截断。
fffff秒的小数精度为五位。其余数字被截断。
ffffff秒的小数精度为六位。其余数字被截断。
fffffff秒的小数精度为七位。其余数字被截断。
t在AMDesignator或PMDesignator中定义的AM/PM指示项的第一个字符（如果存在）。
tt在AMDesignator或PMDesignator中定义的AM/PM指示项（如果存在）。
z时区偏移量（“+”或“-”后面仅跟小时）。一位数的小时数没有前导零。例如，太平洋标准时间是“-8”。
zz时区偏移量（“+”或“-”后面仅跟小时）。一位数的小时数有前导零。例如，太平洋标准时间是“-08”。
zzz完整时区偏移量（“+”或“-”后面跟有小时和分钟）。一位数的小时数和分钟数有前导零。例如，太平洋标准时间是“-08:00”。
:在TimeSeparator中定义的默认时间分隔符。
/在DateSeparator中定义的默认日期分隔符。
%c其中c是格式模式（如果单独使用）。如果格式模式与原义字符或其他格式模式合并，则可以省略“%”字符。
\c其中c是任意字符。照原义显示字符。若要显示反斜杠字符，请使用“\\”。
```





# mysql

## 数据表设计规则总结

数据库设计是有几大范式的，但是他们都比较高深莫测，实际开发中我们遵循下面的规则即可：

每张表只存储一类数据，比如用户表就存储用户信息；（做关联用的列不算，比如上面例子中人的表中还存储了房子的地址，但是地址是做关联用的）

设计表之前首先要划分清楚各模块是什么，比如用户模块、车、房子，然后理清楚各模块间的关系，两张表之间如果存在关联关系，则该关系可以分为三种：一对一，一对多，多对多。

分别先独立的设计各个表的结构，这样设计完后是一张张相互独立没有关联的表
然后按照两表之间的关系来进行完善即可。

那么两表之间的关系如何完善呢？

A和B之间是1对1关系，则将一张表的唯一字段（唯一能够确定一行数据的）放入另外一张表中：比如用户表和手机表是1对1的关系，那么我们可以将用户身份证号放入手机表中，作为手机表的列名（字段）之一。
A和B之间是1对多 关系，则将“一”这一端的唯一字段放入“多“的一端中：比如用户表和衣服表，一个用户有多件衣服，一件衣服只属于一个用户，那么就将身份证号放入衣服表中即可
A和B之间是 多对多 关系，则建立一张中间表，把AB两表中的唯一键放入中间表即可：比如手机表和APP表，一个手机可以安装多个APP，一个APP可以被多个手机安装。那么我们将APP的ID号和手机的手机号一同放入一张中间表（也叫关联表）中即可。



## MySQL 的最佳性能，需要遵循 3 个基本使用原则

首先是需要让 MySQL 回归存储的基本职能：MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离

其次是查询数据时，尽量单表查询，减少跨库查询和多表关联

还有就是要杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。

大 SQL，复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下

大批量，意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行

大字段，blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新



## 基本设置规则

必须指定默认存储引擎为 InnoDB，并且禁用 MyISAM 存储引擎，随着 MySQL 8.0 版本的发布，所有的数据字典表都已经转换成了 InnoDB，MyISAM 存储引擎已成为了历史。

默认字符集 UTF8mb4，以前版本的 UTF8 是 UTF8mb3，未包含个别特殊字符，新版本的 UTF8mb4 包含所有字符，官方强烈建议使用此字符集。

关闭区分大小写功能。设置 lower_case_tables_name=1，即可关闭区分大小写功能，即大写字母 T 和小写字母 t 一样


## 规范命名

命名规范如下，命名时的字符取值范围为：az，09 和 _（下画线）。

- 所有表名小写，不允许驼峰式命名；

- 不允许使用其他特殊字符作为名称，减少潜在风险。

  

- 命名使用具有意义的英文词汇，词汇中间以下划线分隔，一般为项目名称+代表库含义的简写，比如IM项目的工作流数据库，可以是 im_flow。

  ### 表命名规范

  1、常规表表名以t_开头，t代表table的意思，命名规则即 t + 模块（包含模块含义的简写）+ 表（包含表含义的简写），比如用户模块的教育信息表：t_user_eduinfo。

  2、临时表（RD、QA或DBA同学用于数据临时处理的表），命名规则：temp前缀+模块+表+日期后缀：temp_user_eduinfo_20210719

  3、备份表（用于保存和归档历史数据或者作为灾备恢复的数据）命名规则，bak前缀+模块+表+日期后缀：bak_user_eduinfo_20210719

  4、同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义

  5、多个单词以下划线 _ 分隔

  6、常规表表名尽量不超过30个字符，temp表和bak表视情况而定，也尽量简短为宜，命名应使用小写

  ### 字段命名规范

  1、字段命名需要表示其实际含义的英文单词或简写，单词之间用下划线 _ 进行连接，如 service_ip、service_port。

  2、各表之间相同意义的字段必须同名，比如a表和b表都有创建时间，应该统一为create_time，不一致会很混乱。

  3、多个单词以下划线 _ 分隔

  4、字段名尽量不超过30个字符，命名应该使用小写

### 常见业务表类型

- 临时表，tmp；
- 备份表，bak；
- 字典表，dic；
- 日志表，log。

字段名精确，遵循“见名知意”的原则，格式：名称_后缀。

避免普遍简单、有歧义的名称。

用户表中，用户名的字段为 UserName 比 Name 更好。

布尔型的字段，以助动词（has/is）开头。

用户是否有留言 hasmessage，用户是否通过检查 ischecked 等。

### 常见后缀

流水号/无意义主键，后缀为 id，比如 task_id；

时间，后缀为 time，insert_time。

程序账号与数据库名称保持一致。如果所有的程序账号都是 root@‘%’，密码也一样，很容易错连到其他的数据库，造成误操作。

索引命名格式，主要为了区分哪些对象是索引：

前缀_表名（或缩写）_字段名（或缩写）；

主键必须使用前缀“pk_”；

UNIQUE 约束必须使用前缀“uk_”；

普通索引必须使用前缀“idx_”。

数据库规范库表字段的命名，能够提高数据库的易读性，为数据库表设计打下基础。下面我们具体看看表设计的一些规则。

显式指定需要的属性；
创建表时显示指定字符集、存储引擎、注释信息等。

不同系统之间，统一规范；


### InnoDB 表的注意事项
主键列，UNSIGNED 整数，使用 auto_increment；禁止手动更新 auto_increment，可以删除。

必须添加 comment 注释。

必须显示指定的 engine。

表必备三字段：id、 xxx_create、 xxx_modified。

id 为主键，类型为 unsigned bigint 等数字类型；

xxx_create、xxx_modified 的类型均为 datetime 类型，分别记录该条数据的创建时间、修改时间。

## mysql的性能优化

### 尽量避免null列
not in ,!=等负向条件下null列返回的是空结果

对于null column，count(null column)是不计入统计结果的

null列会占用多一个字节的空间，来表明是否为空

大多数情况下，null列都是可以用默认值来替代的

### 尽量使用更简单的数据类型
简单意味着更低的磁盘存储，内存占用和cpu性能开销，特别是大数据量高并发的情况下，对性能影响比较大
对于索引列，越小的数据类型，意味着每个数据页能存更多的分支，减少索引的次数
###  整数
整数类型主要有： tinyint,smallint,mediumint,int,bigint,分别用8，16，24，32，64个位进行存储，存储范围是-2N-1-1 ~ 2N-1,N表示存储的位数。可以使用unsigned来表明正数，这样可以使存储的上限变成2N-1,将近扩大了一半。

另外特别要注意的是，mysql中整型可以指定宽度，但是这个宽度并不是用来限制这个列的长度的，只是用来对查询的结果进行补0显示。也就是说int(1)和int(7),int(100)都是只能存8个byte32位,范围都是-231-1 ~ 231，指定的宽度唯一的作用就是用来对客户端查询结果进行补0，而且得开启zero_fill才行，比如age int(3) ZEROFILL，如果插入值为10，那么查询的结果为010，插入1000，结果为1000。

如果确定没有负数，可以使用unsigned 类型，让可存储的上限能扩大一倍，间接的使用更小的数据类型

### 实数
 float和double来表示，属于浮点数，存在精度丢失问题，但是因为cpu原生支持浮点运算，所以性能更好,float最大支持存储4个字节，double最大支持8个字节

decimal 属于定点数，精确类型，但是由于是通过mysql实现的精度计算，相对于浮点型来讲性能要差点
**实数类型选择：**

1 如果精度要求不高，直接使用float或double

2 如果对精度要求高，性能要求不高，可以考虑使用decimal

3 如果对精度和性能都有要求，可以考虑将小数转为整型存储，

比如财务系统，需要精确为分，可以将金额乘以100进行保存到int或bigint里面

2.4 字符串
使用varchar要尽量设定小的字节数，因为mysql在创建临时表或排序的时候，会悲观的给varchar类型分配最大的长度

 总结：

1 字段设计时尽量选择小而简单的数据类型越好

2 除非必要，不使用可空列，用默认值代替

3 varchar类型虽然是变长，也应该按实际所需分配字节

4 整型不需要指定长度

5 只有正数考虑用unsigned,可以扩大上限

6 实数精度要求不高情况，优先使用浮点类型float，double,如果精度要求高可考虑用整型转化或直接使用decimal类型

## 数据表关系

### 关联映射

**一对多/多对一**

存在最普遍的映射关系，简单来讲就如球员与球队的关系；

一对多：从球队角度来说一个球队拥有多个球员 即为一对多

多对一：从球员角度来说多个球员属于一个球队 即为多对一

**一对一**

一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。

数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。

**多对多**

多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。

数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多

### 数据表之间的约束

约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。

**主键(PRIMARY KEY)**

是用于约束表中的一行，作为这一行的标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要。主键要求这一行的数据不能有重复且不能为空。

 还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识

===================================================

**默认值约束(DEFAULT)**

规定，当有DEFAULT约束的列，插入数据为空时该怎么办。

DEFAULT约束只会在使用INSERT语句（上一实验介绍过）时体现出来，INSERT语句中，如果被DEFAULT约束的位置没有值，那么这个位置将会被DEFAULT的值填充

===================================================

**唯一约束(UNIQUE)**

比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。

当INSERT语句新插入的数据和已有数据重复的时候，如果有UNIQUE约束，则INSERT失败.

===================================================

**外键(FOREIGN KEY)**

既能确保数据完整性，也能表现表之间的关系。

一个表可以有多个外键，每个外键必须REFERENCES(参考)另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。

在INSERT时，如果被外键约束的值没有在参考列中有对应，比如以下命令，参考列(department表的dpt_name)中没有dpt3，则INSERT失败



RESTRICT（约束）：如果出现在删除时，意思是约束外键主键did记录（主表中的记录）不能直接删除，必须先删除被约束的表（从表）字段中dept_id所有这个外键主键值对应的记录，才能删除外键约束（主表中的记录）

NO ACTION：

CASCADE：删除选择这个时，删除主表中的记录时，主表中的这个主键id关联的从表的这个id值所在的记录也会被删除。建议不选。

SET NULL ：删除选择这个时，如果从表（被约束的字段所在的表中）被约束的字段的值设置为可以为空时，那么当删除主表的记录时，主表中被删除的这个记录对应的主键值（约束从表字段的那个值）在从表中对应的字段中出现的那个记录的被约束字段的值就会变为NULL。

最常用的是选择RESTRICT不让删的这个约束、或者选择SET NULL删除后值表为空。

===================================================

**非空约束(NOT NULL)**

听名字就能理解，被非空约束的列，在插入值时必须非空。

在MySQL中违反非空约束，不会报错，只会有警告.



## 设置字段自动更新

添加 timestamp 类型的字段

添加规则 CURRENT_TIMESTAMP

##### datetime 和 timestamp 的不同点

###### - 两者的存储方式不一样

对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而对于DATETIME，不做任何改变，基本上是原样输入和输出。

# VS常用快捷键

### Ctrl+K+S

使用region分割，快捷键：Ctrl+K+S

```
#region MyRegion
#endregion
```

### 展开关闭代码块

```
CTRL + M, CTRL + O折叠代码定义
CTRL + M, CTRL + L展开代码定义
```

### 注释选定内容

```
Ctrl+K、Ctrl+C
```

### 取消注释

```
Ctrl+K、Ctrl+U
```



### 完成单词

```
或 Ctrl+K、W [工作流设计器]
```

### 在文件中查找

```
Ctrl+Shift+F
```

### 转到声明

```
Ctrl+F12
```

### 转到定义

```
F12
```

### 插入代码片段

```
Ctrl+K、Ctrl+X
```

### 编辑.替换

```
Ctrl+H
```





### 文件：常用快捷方式

| 命令     | 键盘快捷方式 [特殊上下文] | 命令 ID       |
| :------- | :------------------------ | :------------ |
| 新建文件 | **Ctrl+N**                | 文件.新建文件 |
| 新建项目 | **Ctrl+Shift+N**          | 文件.新建项目 |
| 新建网站 | **Shift+Alt+N**           | 文件.新建网站 |
| 打开文件 | **Ctrl+O**                | 文件.打开文件 |
| 打开项目 | **Ctrl+Shift+O**          | 文件.打开项目 |



### 重构：常用快捷方式

| 命令     | 键盘快捷方式 [特殊上下文] | 命令 ID       |
| :------- | :------------------------ | :------------ |
| 提取方法 | **Ctrl+R、Ctrl+M**        | 重构.提取方法 |





### 窗口：常用快捷方式

| 命令               | 键盘快捷方式 [特殊上下文] | 命令 ID                   |
| :----------------- | :------------------------ | :------------------------ |
| 激活文档窗口       | **Esc**                   | 窗口.激活文档窗口         |
| 关闭文档窗口       | **Ctrl+F4**               | 窗口.关闭文档窗口         |
| 下一个文档窗口     | **Ctrl+F6**               | 窗口.下一个文档窗口       |
| 下一个文档窗口导航 | **Ctrl+Tab**              | 窗口.下一个文档窗口导航栏 |
| 下一个拆分窗格     | **F6**                    | 窗口.下一个拆分窗格       |

### 全局快捷键

这些键盘快捷键为全局快捷键，这意味着你可以在任何 Visual Studio 窗口具有焦点时使用它们。

#### 分析：全局快捷方式

| 命令     | 键盘快捷键      | 命令 ID       |
| :------- | :-------------- | :------------ |
| 向后导航 | **Shift+Alt+3** | 分析.向后定位 |
| 向前导航 | **Shift+Alt+4** | 分析.向前定位 |



#### 生成：全局快捷方式

| 命令                   | 键盘快捷键                      | 命令 ID                     |
| :--------------------- | :------------------------------ | :-------------------------- |
| 生成选择               | **Ctrl+B** (Visual Studio 2019) | Build.BuildSelection        |
| 生成解决方案           | **Ctrl+Shift+B**                | 生成.生成解决方案           |
| 取消                   | **Ctrl+Break**                  | 生成.取消                   |
| Compile                | **Ctrl+F7**                     | 生成.编译                   |
| 对解决方案运行代码分析 | **Alt+F11**                     | 生成.对解决方案运行代码分析 |



#### 调试：全局快捷方式

| 命令                            | 键盘快捷键                                                   | 命令 ID                              |
| :------------------------------ | :----------------------------------------------------------- | :----------------------------------- |
| 应用代码更改                    | **Alt+F10**                                                  | 调试.应用代码更改                    |
| 附加到进程                      | **Ctrl+Alt+P**                                               | 调试.附加到进程                      |
| 自动                            | **Ctrl+Alt+V、A**                                            | 调试.自动窗口                        |
| 全部中断                        | **Ctrl+Alt+Break**                                           | 调试.全部中断                        |
| 断点                            | **Ctrl+Alt+B**                                               | 调试.断点                            |
| 删除所有断点                    | **Ctrl+Shift+F9**                                            | 调试.删除所有断点                    |
| 启动                            | **Alt+F2**                                                   | 调试.诊断中心.启动                   |
| 启用断点                        | **Ctrl+F9**                                                  | 调试.启用断点                        |
| 函数断点                        | **Ctrl+K、B** (Visual Studio 2019) **Ctrl**+**B** (Visual Studio 2017) | Debug.FunctionBreakpoint             |
| 即时                            | **Ctrl+Alt+I**                                               | 调试.即时                            |
| 局部变量                        | **Ctrl+Alt+V、L**                                            | 调试.局部变量                        |
| 切换已标记的线程                | **Ctrl+9**                                                   | 调试.位置工具栏.切换标记的线程       |
| 进程                            | **Ctrl+Alt+Z**                                               | 调试.进程                            |
| 快速监视                        | **Shift+F9** 或 **Ctrl+Alt+Q**                               | 调试.快速监视                        |
| 重新附加到进程                  | **Shift+Alt+P**                                              | Debug.ReattachtoProcess              |
| 刷新 Windows 应用               | **Ctrl+Shift+R**                                             | Debug.RefreshWindowsapp              |
| 重启                            | **Ctrl+Shift+F5**                                            | 调试.重新启动                        |
| 运行到光标处                    | **Ctrl+F10**                                                 | 调试.运行到光标处                    |
| 设置下一语句                    | **Ctrl+Shift+F10**                                           | 调试.设置下一语句                    |
| 在代码图上显示调用堆栈          | **Ctrl+Shift+`**                                             | 调试.在代码图上显示调用堆栈          |
| 显示下一语句                    | **Alt+Num** *                                                | 调试.显示下一语句                    |
| 开始                            | **F5**                                                       | 调试.启动                            |
| 启动 Windows Phone 应用程序分析 | **Alt+F1**                                                   | 调试.启动 Windows Phone 应用程序分析 |
| 启动时不调试                    | **Ctrl+F5**                                                  | 调试.开始执行不调试                  |
| “单步执行”                      | **F11**                                                      | 调试.逐语句                          |
| 单步执行当前进程                | **Ctrl+Alt+F11**                                             | 调试.进入并单步执行当前进程          |
| 单步执行特定内容                | **Shift+Alt+F11**                                            | 调试.单步执行特定函数                |
| 单步跳出                        | **Shift+F11**                                                | 调试.跳出                            |
| 跳出当前进程                    | **Ctrl+Shift+Alt+F11**                                       | 调试.跳出当前进程                    |
| 逐过程                          | F10（执行调试时：执行单步跳过操作）                          | 调试.逐过程                          |
| 逐过程                          | F10（未在执行调试时：启动调试，并在第一行用户代码上停止）    | 调试.逐过程                          |



#### 编辑：全局快捷方式

| 命令                 | 键盘快捷键                                                   | 命令 ID                       |
| :------------------- | :----------------------------------------------------------- | :---------------------------- |
| 循环剪贴板环         | **Ctrl+Shift+V**  or  **Ctrl+Shift+Ins**                     | 编辑.循环应用剪贴板中的复制项 |
| 查找                 | **Ctrl+F**                                                   | 编辑.查找                     |
| 查找所有引用         | **Shift+F12**                                                | 编辑.查找所有引用             |
| 在文件中查找         | **Ctrl+Shift+F**                                             | 编辑.在文件中查找             |
| 查找下一个           | **F3**                                                       | 编辑.查找下一个               |
| 查找下一个选择       | **Ctrl+F3**                                                  | 编辑.查找下一个选定项         |
| 查找上一个           | **Shift+F3**                                                 | 编辑.查找上一个               |
| 查找上一个选择       | **Ctrl+Shift+F3**                                            | 编辑.查找上一个选定项         |
| 生成方法             | **Ctrl+K、Ctrl+M**                                           | 编辑.生成方法                 |
| 转到                 | **Ctrl+G**                                                   | 编辑.转到                     |
| 转到全部             | Ctrl+ 或 Ctrl+T                                              | Edit.GoToAll                  |
| 转到声明             | **Ctrl+F12**                                                 | 编辑.转到声明                 |
| 转到定义             | **F12**                                                      | 编辑.转到定义                 |
| 转到成员             | Ctrl+1、Ctrl+M 或 Ctrl+1、M 或 Alt+\                         | Edit.GoToMember               |
| 转到下一个位置       | F8（错误列表或输出窗口中的下一个错误）                       | 编辑.转到下一个位置           |
| 转到上一个位置       | Shift+F8（错误列表或输出窗口中的上一个错误）                 | 编辑.转到上一个位置           |
| 插入代码片段         | **Ctrl+K、Ctrl+X**                                           | 编辑.插入代码片段             |
| 向下移动控件         | **Ctrl+向下键**                                              | 编辑.下移控件                 |
| 向下移动控件网格     | 向下键                                                       | 编辑.将控件移动到下侧网格     |
| 向左移动控件         | **Ctrl+向左键**                                              | 编辑.左移控件                 |
| 向左移动控件网格     | **向左键**                                                   | 编辑.将控件移动到左侧网格     |
| 向右移动控件         | **Ctrl+向右键**                                              | 编辑.右移控件                 |
| 向右移动控件网格     | **向右键**                                                   | 编辑.将控件移动到右侧网格     |
| 向上移动控件         | **Ctrl+向上键**                                              | 编辑.上移控件                 |
| 向上移动控件网格     | 向上键                                                       | 编辑.将控件移动到上侧网格     |
| 下一个书签           | **Ctrl+K、Ctrl+N**                                           | 编辑.下一书签                 |
| 文件夹中的下一个书签 | **Ctrl+Shift+K、Ctrl+Shift+N**                               | 编辑.文件夹中的下一书签       |
| 打开文件             | Ctrl+Shift+G（打开光标下的文件名称）                         | 编辑.打开文件                 |
| 上一个书签           | **Ctrl+K、Ctrl+P**                                           | 编辑.上一书签                 |
| 文件夹中的上一个书签 | **Ctrl+Shift+K、Ctrl+Shift+P**                               | 编辑.文件夹中的上一书签       |
| 快速查找符号         | **Shift+Alt+F12**                                            | 编辑.快速查找符号             |
| 重做                 | **Ctrl+Y**  or  **Ctrl+Shift+Z**  or  **Shift+Alt+Backspace** | 编辑.重做                     |
| 刷新远程引用         | **Ctrl+Shift+J**                                             | 编辑.刷新远程引用             |
| Replace              | **Ctrl+H**                                                   | 编辑.替换                     |
| 在文件中替换         | **Ctrl+Shift+H**                                             | 编辑.在文件中替换             |
| 选择下一个控件       | Tab                                                          | 编辑.选择下一个控件           |
| 选择上一个控件       | **Shift+Tab**                                                | 编辑.选择上一个控件           |
| 显示磁贴网格         | Enter                                                        | 编辑.显示平铺网格             |
| 向下调整控件大小     | **Ctrl+Shift+向下键**                                        | 编辑.向下调大控件大小         |
| 向下调整控件大小网格 | **Shift+向下键**                                             | 编辑.将控件调大到下侧网格     |
| 向左调整控件大小     | **Ctrl+Shift+向左键**                                        | 编辑.向左调整控件大小         |
| 向左调整控件大小网格 | **Shift+向左键**                                             | 编辑.将控件调大到左侧网格     |
| 向右调整控件大小     | **Ctrl+Shift+向右键**                                        | 编辑.向右调整控件大小         |
| 向右调整控件大小网格 | **Shift+向右键**                                             | 编辑.将控件调大到右侧网格     |
| 向上调整控件大小     | **Ctrl+Shift+向上键**                                        | 编辑.向上调整控件大小         |
| 向上调整控件大小网格 | **Shift+向上键**                                             | 编辑.将控件调大到上侧网格     |
| 停止搜索             | **Alt+F3、S**                                                | 编辑.停止搜索                 |
| 环绕                 | **Ctrl+K、Ctrl+S**                                           | 编辑.外侧代码                 |
| 撤消                 | **Ctrl+Z**  or  **Alt+Backspace**                            | 编辑.取消                     |

### 

####  文件：全局快捷方式帮助：全局快捷方式

| 命令               | 键盘快捷键      | 命令 ID                 |
| :----------------- | :-------------- | :---------------------- |
| 添加和删除帮助内容 | **Ctrl+Alt+F1** | 帮助.添加和移除帮助内容 |
| F1 帮助            | F1              | 帮助.F1 帮助            |
| 查看帮助           | **Ctrl+F1**     | Help.ViewHelp           |
| 窗口帮助           | **Shift+F1**    | 帮助.窗口帮助           |



### 

#### 项目：全局快捷方式

| 命令                   | 键盘快捷键            | 命令 ID                     |
| :--------------------- | :-------------------- | :-------------------------- |
| 添加现有项             | **Shift+Alt+A**       | 项目.添加现有项             |
| 添加新项               | **Ctrl+Shift+A**      | 项目.添加新项               |
| 类向导                 | **Ctrl+Shift+X**      | 项目.类向导                 |
| 替代                   | **Ctrl+Alt+Ins**      | 项目.重写                   |
| 预览更改               | 依次按 Alt+; 和 Alt+C | 项目.预览更改               |
| 发布选定的文件         | 依次按 Alt+; 和 Alt+P | 项目.发布选定文件           |
| 替换服务器中的选定文件 | 依次按 Alt+; 和 Alt+R | 项目.替换服务器上的选定文件 |



#### 重构：全局快捷方式

| 命令         | 键盘快捷键                    | 命令 ID           |
| :----------- | :---------------------------- | :---------------- |
| 封装字段     | **Ctrl+R、Ctrl+E**            | 重构.封装字段     |
| 提取接口     | **Ctrl+R、Ctrl+I**            | 重构.提取接口     |
| 提取方法     | **Ctrl+R、Ctrl+M**            | 重构.提取方法     |
| 移除参数     | **Ctrl+R、Ctrl+V**            | 重构.移除参数     |
| 重命名       | **Ctrl+R、Ctrl+R**            | 重构.重命名       |
| 重新排列参数 | **Ctrl+R、Ctrl+O**（字母“O”） | 重构.重新排列参数 |

### 

#### 团队：全局快捷方式

| 命令               | 键盘快捷键                                                   | 命令 ID                 |
| :----------------- | :----------------------------------------------------------- | :---------------------- |
| 转到 git 分支      | **Ctrl+0**（数字“0”）、**Ctrl+N**  or  **Ctrl+0、N**         | 团队.Git.转到 Git 分支  |
| 转到 git 更改      | **Ctrl+0**（数字“0”）、**Ctrl+G**  or  **Ctrl+0、G**         | 团队.Git.转到 Git 更改  |
| 转到 git 提交      | **Ctrl+0**（数字“0”）、**Ctrl+O**（字母“O”）  or  **Ctrl+0、O** | 团队.Git.转到 Git 提交  |
| 团队资源管理器搜索 | **Ctrl+'**                                                   | 团队.团队资源管理器搜索 |



#### 工具：全局快捷方式

| 命令           | 键盘快捷键                                 | 命令 ID           |
| :------------- | :----------------------------------------- | :---------------- |
| 附加到进程     | **Ctrl+Alt+P**                             | 工具.附加到进程   |
| 代码片段管理器 | **Ctrl+K、Ctrl+B**                         | 工具.代码段管理器 |
| 强制 GC        | **Ctrl+Shift+Alt+F12、Ctrl+Shift+Alt+F12** | 工具.强制 GC      |



#  VSCode

## vs快捷键

### 通过匹配文本打开文件

Windows: Ctrl + T



### 集成终端

Windows: Ctrl + `

通过 **Ctrl + `**可以打开或关闭终端

### 逐个选择文本

可以通过快捷键`Ctrl + Shift +右箭头`(Mac: `option + Shift +右箭头`)和`Ctrl + Shift +左箭头`(Mac: option + Shift +左箭头)逐个选择文本。

### 重复的行

一个非常强大和已知的功能是复制行。只需按 `Shift + Alt + 向下箭头` (Mac: `command + Shift + 向下箭头`)

### 移至文件的开头/结尾

要使光标移到文件的第一行或最后一行，最快的方法是按`Ctrl + Home` (`Mac: command + Home`)键开头，然后按`Ctrl + End` (Mac: `command + End`)键结尾。



## 代码片段

第一步，复制自己需要生成代码片段的代码； 第二步，[snippet-generator.app/](https://link.juejin.cn?target=https%3A%2F%2Fsnippet-generator.app%2F) 在该网站中生成代码片段； 第三步，在VSCode中配置代码片段；

### vscode代码片段过程

设置 - 用户代码片段 - - 粘贴生成的代码片段

1. 可以直接打开现有代码片段
2. 可以选择创建全局代码片段
3. 可以选择创建当前文件夹的代码片段

### 个人片段预设

#### s-v3

vue3+ts+scss 基础模板

```vue
"vue3": {
  "prefix": "s-v3",
  "body": [
    "<script lang=\"ts\" setup></script>",
    "<template>",
    "  <div></div>",
    "</template>",
    "",
    "<style lang=\"scss\" scoped></style>"
  ],
  "description": "vue3"
}
```

#### s-on

onMounted

```js
{
  "onMounted-async": {
    "prefix": "s-on",
    "body": ["    onMounted(async () => {", "      ", "    });"],
    "description": "onMounted-async"
  }
}
```



## .eslintrc.js

```js
/*
 * @Author: your name
 * @Date: 2020-12-14 17:18:11
 * @LastEditTime: 2021-08-03 08:55:21
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \blogs-s\src\.eslintrc.js
 */
module.exports = {
  extends: [
    'plugin:vue/vue3-essential',
    'eslint:recommended',
    '@vue/typescript/recommended'
  ],
  plugins: [
    'vue',
    '@typescript-eslint'
  ],
  rules: {
    '@typescript-eslint/no-var-requires': 0,
    '@typescript-eslint/no-unused-vars': 'error',
    // 允许非空断言
    '@typescript-eslint/no-non-null-assertion': 'off',
    // 允许自定义模块和命名空间
    '@typescript-eslint/no-namespace': 'off',
    "@typescript-eslint/no-inferrable-types": "off", // 关闭类型推断
    // 允许对this设置alias
    '@typescript-eslint/no-this-alias': 'off',
    // 允许使用any类型
    '@typescript-eslint/no-explicit-any': ['off'],
    //Missing return type on function
    "@typescript-eslint/explicit-module-boundary-types": "off",
  }
}
```



## 常用插件



### vite-plugin-restart

通过监听文件修改，自动重启 vite 服务。

最常用的场景就是监听 `vite.config.js` 和 `.env.development` 文件，我们知道，修改 vite 配置文件和环境配置文件，是需要重启 vite 才会生效，通过这个插件，我们将从反复重启中解脱出来。



### Code Spell Checker

检测你写代码时拼写的单词是否正确。

#### 安装方法

1. 在应用商店中搜索Code Spell Checker。
2. 点击安装，等待安装完成，然后重启VSCode。

#### Add Word to Workspace Dictionaries

（向工作区词典添加单词）

选中要添加的单词–>右击鼠标–>点击这个Add Word to Workspace Dictionaries，这样下次在拼写这个单词的时候便不会出现波浪线的提示。

#### Add Word to User Dictionary

（将单词添加到用户词典）
操作步骤如上，只需要选中不同的Add Word to User Dictionary功能即可。

#### Ignore Word

（忽略单词）

操作步骤如上，只需要选中不同的Ignore Word功能即可。


#### 删除单词解决方案：

Add Word to Workspace Dictionaries，这就是意味着添加进来了工作区词典，而在VSCode中创建项目时，系统会给我们生成一个.vscode的文件夹，修改settings.json即可




Add Word to User Dictionary，这就需要我们再我们再VSCode的系统设置中修改。

设置–>用户–>扩展–>找到安装的Code Spell Checker–>打开settings.json，在其中找到图6的内容，在其中修改添加错的单词，我在其中添加的是bindblur单词。

 Ignore Word，方法和第一个一样，因为都是在.vscode中的setting.json文件中。


#### 总结
Add Word to Workspace Dictionaries和Ignore Word仅是将word添加到该项目中，如果再新建一个项目以前添加的word将不再在新项目中生效，而Add Word to User Dictionary是将word添加到VSCode的系统中，所以即是新建一个项目也不会提示有波浪线。



### Code Runner

- 可以让你在 `vscode` 里方便的运行某个文件或者运行选取的某段代码。

### Bracket Pair Colorizer 2

- 给你的括号用颜色标记一下，这样当你的函数块里面有很多嵌套，就比较容易理清楚。

### Debugger for Chrome

- 我们知道可以在 `chrome` 浏览器中利用开发者工具打断点调试，那么如何在 `vscode` 进行 `debugger` 调试？
- [在 vscode 中调试 vue](https://xwhx.top/mall/other/vscode-debugger.html)

### ESLint

- 代码检查及错误提示。
- 结合 Prettier 插件可以让我们快速格式化代码。

### Prettier

- 格式化代码，规范代码风格。



### stylelint

#### 配置使用
npm安装stylelint及其用到的插件

```vue
npm i stylelint stylelint-config-standard stylelint-order stylelint-config-rational-order stylelint-scss -D
```

这里用到的插件有：

stylelint

stylelint-config-standard：stylelint官方共享的标准规则集成。里面包括了 Google's CSS Style Guide、

Airbnb's Styleguide、The Idiomatic CSS Principles以及@mdo's Code Guide。想看里面定义的源码可点击此。

stylelint-order：用于规范样式属性写作顺序的插件。

stylelint-config-rational-order：本人目前正在使用的css属性顺序的规则。配合stylelint-order使用。

stylelint-scss：用于支持校验scss语法的插件，例如@extend等。

关于上述插件更详细补充会在下文叙述。

#### 在根目录中创建stylelint配置文件
配置文件可以是.stylelintrc.json、stylelint.config.js的其中一种。或者可以写在package.json的stylelint变量中。这里就直接以.stylelintrc.json为例，配置文件如下所示：

```js
{
  "extends": ["stylelint-config-standard", "stylelint-config-rational-order"],
  "plugins": ["stylelint-order", "stylelint-scss"],
  "rules": {
    "indentation": 2,
    "no-missing-end-of-source-newline": null,
    "max-nesting-depth": 10,
    "selector-max-compound-selectors": 10,
    "at-rule-no-unknown": [
      true,
      {
        "ignoreAtRules": ["screen", "include", "mixin", "if", "layer"]
      }
    ]
  }
}

```

####  在vscode中安装stylelint

在vscode中打开setting.json（文件->首选项->设置）添加以下内容：

```json
 "editor.codeActionsOnSave": {
    "source.fixAll.stylelint": true
  },
  // stylelint配置
  "stylelint.enable": true,
  "css.validate": false,
  "less.validate": false,
  "scss.validate": false,
  "[scss]": {
    "editor.formatOnSave": true
  }
```

### Todo Tree

Todo
Tree 一款待办事项插件
我们写程序的时候，难免会遇到一些情况需要标记或者搁置，在写代码的时候会用一些特殊的注释来表示不同的内容，使我们可以快速的定位我们注释的位置。

主要有以下几种：

TODO: 用来标记待办的地方。常常在有些地方，我们的功能并没有实现，使用ToDo标记我们可以快速定位需要实现的部分。

HACK: 用来标记可能需要更改的地方。在写代码的时候，有的地方我们并不确定他是正确的，可能未来有所更改，这时候可以使用HACK标记。

NOTE: 添加一些说明文字。

INFO: 用来表达一些信息。

TAG: 用来创建一些标记。

XXX: 用来标记一些草率实现的地方。在写代码的时候，有些地方需要频繁修改，这时候使用XXX标记。

BUG: 用来标记BUG~

FIXME: 用来标记一些需要修复的位置，可以快速定位。

下面是我的一些配色：(左侧可以通过点击快速定位到位置)

配置代码：(直接设置里搜索todo tree，然后随便选一个能打开setting.json的选项，复制进去覆盖就好了)

```js
 "todo-tree.filtering.excludeGlobs": ["**/node_modules", "*.xml", "*.XML"],
  "todo-tree.filtering.ignoreGitSubmodules": true,
  "todo-tree.tree.showCountsInTree": true,
  "todo-tree.highlights.customHighlight": {
    "BUG": {
      "icon": "bug",
      "foreground": "#F56C6C",
      "type": "line"
    },
    "FIXME": {
      "icon": "flame",
      "foreground": "#FF9800",
      "type": "line"
    },
    "TODO": {
      "foreground": "#FFEB38",
      "type": "line"
    },
    "NOTE": {
      "icon": "note",
      "foreground": "#67C23A",
      "type": "line"
    },
    "INFO": {
      "icon": "info",
      "foreground": "#909399",
      "type": "line"
    },
    "TAG": {
      "icon": "tag",
      "foreground": "#409EFF",
      "type": "line"
    },
    "HACK": {
      "icon": "versions",
      "foreground": "#E040FB",
      "type": "line"
    },
    "XXX": {
      "icon": "unverified",
      "foreground": "#E91E63",
      "type": "line"
    }
  },
  "todo-tree.general.tags": [
    "BUG",
    "HACK",
    "FIXME",
    "TODO",
    "INFO",
    "NOTE",
    "TAG",
    "XXX"
  ],
  "todo-tree.general.statusBar": "total"
```



# 常用代码片段

## ts延时设定

```tsx
setTimeout(async () => {
dataList.show = false
}, 1200)
```

## bat命令复制文件

```bash

del xxxx.application
del setup.exe
del publish.htm
RD /S /Q "Application Files"
xcopy /E \\10.xx.x.x\mech_production_line_sharing\xxx
start xxxx.application

```

## C# 方法代码片段



安装此  C# Methods Code Snippets 代码段后，您可以使用以下代码段快捷方式。

### method方法

（实例方法的片段）

- 和“method1”，“method2”，“method3”是带参数的版本。

```c#
// Enter "method [Tab]", then...  
public void MyMethod()  {
    throw new NotImplementedException();
}

// Enter "method1 [Tab]", then...  
public void MyMethod(object arg)  {
    throw new NotImplementedException();
}

// Enter "method2 [Tab]", then...  
public void MyMethod(object arg1, object arg2)  {
    throw new NotImplementedException();
}

// Enter "method3 [Tab]", then...  
public void MyMethod(object arg1, object arg2, object arg3)  {
    throw new NotImplementedException();
}
```



### imethod

（片断为界面法）

- 和“imethod1”、“imethod2”、“imethod3”是带参数的版本。

```c#
// Enter "imethod [Tab]", then...  
public void MyMethod();

// Enter "imethod1 [Tab]", then...  
public void MyMethod(object arg);

// Enter "imethod2 [Tab]", then...  
public void MyMethod(object arg1, object arg2);

// Enter "imethod3 [Tab]", then...  
public void MyMethod(object arg1, object arg2, object arg3);
```



### vmethod

（虚拟实例方法的片段）

- 和“vmethod1”、“vmethod2”、“vmethod3”正在使用参数版本。

```c#
// Enter "vmethod [Tab]", then...  
public virtual void MyMethod()  {
    throw new NotImplementedException();
}

// Enter "vmethod1 [Tab]", then...  
public virtual void MyMethod(object arg)  {
    throw new NotImplementedException();
}

// Enter "vmethod2 [Tab]", then...  
public virtual void MyMethod(object arg1, object arg2)  {
    throw new NotImplementedException();
}

// Enter "vmethod3 [Tab]", then...  
public virtual void MyMethod(object arg1, object arg2, object arg3)  {
    throw new NotImplementedException();
}
```



### smethod

（静态方法的片段）

- 和“smethod1”、“smethod2”、“smethod3”是带参数的版本。

```c#
// Enter "smethod [Tab]", then...  
public static void MyMethod()  {
    throw new NotImplementedException();
}

// Enter "smethod1 [Tab]", then...  
public static void MyMethod(object arg)  {
    throw new NotImplementedException();
}

// Enter "smethod2 [Tab]", then...  
public static void MyMethod(object arg1, object arg2)  {
    throw new NotImplementedException();
}

// Enter "smethod3 [Tab]", then...  
public static void MyMethod(object arg1, object arg2, object arg3)  {
    throw new NotImplementedException();
}
```



### xmethod

（扩展方法的片段）

- 和“xmethod1”、“xmethod2”、“xmethod3”正在接受参数版本。

```c#
// Enter "xmethod [Tab]", then...  
public static void MyMethod(this object value)  {
    throw new NotImplementedException();
}

// Enter "xmethod1 [Tab]", then...  
public static void MyMethod(this object value, object arg)  {
    throw new NotImplementedException();
}

// Enter "xmethod2 [Tab]", then...  
public static void MyMethod(this object value, object arg1, object arg2)  {
    throw new NotImplementedException();
}

// Enter "xmethod3 [Tab]", then...  
public static void MyMethod(this object value, object arg1, object arg2, object arg3)  {
    throw new NotImplementedException();
}
```



### **amethod**（异步实例方法的片段）

```c#
// Enter "amethod [Tab]", then...  
public async Task<object> MyMethodAsync()  {
    throw new NotImplementedException();
}
```



### **asmethod**（异步静态方法的片段）

```c#
// Enter "asmethod [Tab]", then...  
public static async Task<object> MyMethodAsync()  {
    throw new NotImplementedException();
}
```



### **eh**（事件处理程序方法的片段）

```c#
// Enter "eh [Tab]", then... 
private void MyMethod(object sender, EventArgs e)
{
    throw new NotImplementedException();
}
// Enter "seh [Tab]", then... 
private static void MyMethod(object sender, EventArgs e)
{
    throw new NotImplementedException();
}
```



### **seh**（事件处理程序静态方法的片段）

```csharp
// Enter "eh [Tab]", then... 
private void MyMethod(object sender, EventArgs e)
{
    throw new NotImplementedException();
}
// Enter "seh [Tab]", then... 
private static void MyMethod(object sender, EventArgs e)
{
    throw new NotImplementedException();
}
```

# Ant Design Vue





## 分页

```js
  <section>
   <!-- 分页 -->
   <div class="blogs-page">
   <a-pagination
    size="small"
    @change="currentchange"
    :total="state.count"
    :pageSize="state.pagesize"
    show-quick-jumper></a-pagination>
   </div>
   <!-- end 分页 -->
 </section>

async function currentchange(val: number) {
  state.page = val;
  await GetFyTit();
}

interface State {
  resultData: any;
  count: number;
  page: number; //页码
  pagesize: number; //每页条数
}
const state: State = reactive({
  resultData: [],
  count: 0,
  page: 1, //页码
  pagesize: 5, //每页条数
});

```

# Windows 快捷操作大全



## 快速关闭和切换程序

Win 键+ D 最小化所有窗口，快速查看桌面，再按一次可以复原。

Win 键+ M 最小化所有窗口，Win 键 + Shift + M 将最小化的窗口还原到桌面。

Win 键+ Home 隐藏除当前窗口外的其它窗口，再按一下就回来了。

Win 键+T 在任务栏进行窗口切换。

Win 键+1,2,3,4... 打开任务栏

Win + B 这个操作当你不用鼠标的时候，肯定会用到的，选中托盘区域的收起按钮，然后回车，之后方向键就可以控制操作了。中固定的程序，1 代表任务栏中第一个应用图标，如果没有，就对任务栏内容按照组进行切换。

Alt+F4 关闭活动项目或者退出活动程序，瞬间退出。

## 其它一些常用的快捷键

Win 键+P 多屏幕的时候，切换屏幕使用，去开会的时候，你会用到。

Win 键+L 锁屏，中午去吃饭的时候，你会用到。

Win 键+E 打开计算机/资源管理器。

Win+ `+` 唤起放大镜，放大，同理，+ `-`，缩小。

Shift+F10 打开右键菜单，当然键盘上在空格右侧的 `Ctrl` 与 `Alt` 中间也存在一个右键菜单的按键，直接点击即可。

Delete  删除被选择的选择项目，删除的文件将被放入回收站，`Shift+Delete ` 永久删除。

## F1 ~ F12

- `F1`：帮助手册，可以看看，有时候还挺有用的，任何软件都可以试试。
- `F2`：重命名选定项目
- `F3`：搜索文件或文件夹

其余命令在不同的软件中，呈现效果不同。

## Alt，Shift ，Ctrl 相关快捷键

键盘上的 Shift，Alt，Ctrl 按键是一个比较有趣的按键，因为它们是对称的。

有些快捷键组合如果只使用左手非常不方便，但是加上你的右手，这时候就便捷多了。

**Alt +**

Alt+空格+C 猛然间关闭了当前打开的窗口，只使用左手非常不方便，但是按下右 `Alt` 键，就舒服多了。

Alt+空格+N 最小化当前窗口。

Alt+空格+R  窗口恢复到最大化之前的状态。

Alt+Tab  窗口切换。

Alt+回车 查看所选文件属性。









# 一些错误办法

## vscode格式化换行长度设置

```
在根目录下新建

.prettierrc文件

内容如下

{ "semi": false, "singleQuote": true, "printWidth": 200 }
```



## error ‘XXX‘ is not defined no-undef

在使用vue的时候，使用一个全局变量，ESLint的语法会出现ESLint: 'Aliplayer' is not defined. (no-undef)，说变量未定义，这时我们可以添加配置，取消这个校验。在.eslintrc.js文件中添加一个配置，位置如下图所示，我的全局变量就是Aliplayer。



```tsx
在eslintrc.js中的module.exports内添加如下代码块:
  "globals":{
    "Aliplayer": true
  }
```

## MySQL插入时间差八小时问题的解决方法

 查看 mysql 中的时间

```json
select now();
```

如果时间和你本地当前时间一致,说明mysql的时间没有问题

**如果查询 mysql 时间和本地不一致,使用以下语句设置mysql时区**

```json
show variables like '%time_zone%'; //查询当前时区
set global time_zone='+8:00';  //在标准时区上加+8小时,即东8区时间
flush privileges; # 立即生效
```

或者在mysql配置中修改

**my.ini**

```json
[mysqld]
default-time-zone = '+8:00'
```

## vite+ts vscode无法识别别名路径

#### 解决办法

配置 tsconfig.json

```
"paths": {
      "@/*": ["src/*"],
      "/#/*": ["types/*"],
      "@comp/*": ["src/components/*"],
      "@api/*": ["src/api/*"]
    }
```



# 开发计划



## NET

### 基本查询接口

查询总数

```c#
 GetCountAsync(int identity = 0, string type = "null", bool cache = false)
```

查询所有

```c#
 GetAllAsync(bool cache = false)
```

模糊查询

```c#
 GetContainsAsync(int identity = 0, string type = "null", string name = "c", bool cache = false)
```

主键查询

```c#
 GetByIdAsync(int id, bool cache = false)
```

条件查询

```c#
GetTypeAsync(int identity = 1, string type = "null", bool cache = false)
```

分页查询

```c#
GetFyAsync(int identity = 0, string type = "null", int pageIndex = 1, int pageSize = 10, string ordering = "id", bool isDesc = true, bool cache = false)
```



### 新增

**Article表**

 新增按用户查询文章页-GetFyAsync  --git

 新增按用户&&分类查询文章页-GetFyAsync

 新增按用户&&标签查询文章页-GetFyAsync--

 新增按用户模糊查询-GetContainsAsync

 新增按用户&标签模糊查询-GetContainsAsync

 新增按用户&分类模糊查询-GetContainsAsync



增加电影接口，书单接口，图册接口



### 更新

**标签,分类表字段更新**

新增userId_关联用户主键

### 修复

 缓存函数修复（全表）

 注释修复（需清晰明了-全表）

### 优化

**查询接口**

 返回关联的外键表-全表

**user表**

登录接口优化--git



## 前端

### 优化

**按需加载** --git

andt--git

**异步加载**

**图片优化** -- git



### 新增

**admin**

 查询需按当前登录用户展示内容(更新接口)

新增按用户&&查询文章页--git

新增按用户&&分类查询文章页（分页）

新增按用户&&标签查询文章页（分页）



### 修复

跳转新页面用户失效 --git



## 项目结构

```
.
├── public # 公共静态资源目录
├── src # 主目录
│   ├── api # 接口文件
│   │   ├── data #实体类接口
│   │   ├── http #axios接口调用
│   ├── assets # 资源文件
│   │   ├── icons # icon sprite 图标文件夹
│   │   ├── img # 项目存放图片的文件夹
│   │   └── svg # 项目存放svg图片的文件夹
│   ├── components # 公共组件
│   ├── design # 样式文件
│   ├── hooks # 钩子
│   │   ├── xxxx # xxxx
│   │   ├── xxxx # xxxx
│   ├── main.ts # 主入口
│   ├── router # 路由配置
│   ├── store # 状态管理
│   ├── utils # 工具类
│   └── views # 页面
├── .env.development # 生产环境
├── .env.production # 生产环境
└── windi.config.ts # windcss配置文件
```

# 前端性能优化

## 指标

关于指标这块，简单介绍下常见指标

- FCP（First Contentful Paint）：**白屏时间**（第一个文本绘制时间）
- Speed Index：**首屏时间**
- TTI（Time To Interactive）: 第一次可交互的时间
- lighthouse score（performance）：Chrome浏览器审查工具性能评分（也可以npm install -g lighthouse，编程式调用）



### 博客园

https://www.cnblogs.com/ouyangkai/

### 掘金

https://juejin.cn/user/3087084382852375

### 51CTO

https://blog.51cto.com/u_12828212

### CSDN

https://blog.csdn.net/qq_35624605?spm=1011.2124.3001.5343

### segmentfault

https://segmentfault.com/u/shaonian_5f461fef28d3b



jwsn1995 woshishui.?12

